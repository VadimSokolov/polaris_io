// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include "InputContext-odb.hxx"

#include <cassert>
#include <cstring>  // std::memcpy

#include <odb/schema-catalog-impl.hxx>
#include <odb/details/shared-ptr.hxx>

#include <odb/sqlite/traits.hxx>
#include <odb/sqlite/database.hxx>
#include <odb/sqlite/transaction.hxx>
#include <odb/sqlite/connection.hxx>
#include <odb/sqlite/statement.hxx>
#include <odb/sqlite/statement-cache.hxx>
#include <odb/sqlite/simple-object-statements.hxx>
#include <odb/sqlite/container-statements.hxx>
#include <odb/sqlite/exceptions.hxx>
#include <odb/sqlite/simple-object-result.hxx>

namespace odb
{
  // shape_geometry
  //

  bool access::composite_value_traits< ::pio::shape_geometry >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // x
    //
    t[0UL] = false;

    // y
    //
    t[1UL] = false;

    // z
    //
    t[2UL] = false;

    return grew;
  }

  void access::composite_value_traits< ::pio::shape_geometry >::
  bind (sqlite::bind* b, image_type& i, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;
  }

  bool access::composite_value_traits< ::pio::shape_geometry >::
  init (image_type& i, const value_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    return grew;
  }

  void access::composite_value_traits< ::pio::shape_geometry >::
  init (value_type& o, const image_type&  i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }
  }

  // signal_time
  //

  bool access::composite_value_traits< ::pio::signal_time >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // start
    //
    t[0UL] = false;

    // end
    //
    t[1UL] = false;

    // timing
    //
    t[2UL] = false;

    // phasing
    //
    t[3UL] = false;

    // notes
    //
    if (t[4UL])
    {
      i.notes_value.capacity (i.notes_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::pio::signal_time >::
  bind (sqlite::bind* b, image_type& i, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // timing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timing_value;
    b[n].is_null = &i.timing_null;
    n++;

    // phasing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phasing_value;
    b[n].is_null = &i.phasing_null;
    n++;

    // notes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.notes_value.data ();
    b[n].size = &i.notes_size;
    b[n].capacity = i.notes_value.capacity ();
    b[n].is_null = &i.notes_null;
    n++;
  }

  bool access::composite_value_traits< ::pio::signal_time >::
  init (image_type& i, const value_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // timing
    //
    {
      int const& v =
        o.timing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.timing_value,
        is_null,
        v);
      i.timing_null = is_null;
    }

    // phasing
    //
    {
      int const& v =
        o.phasing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phasing_value,
        is_null,
        v);
      i.phasing_null = is_null;
    }

    // notes
    //
    {
      ::std::string const& v =
        o.notes;

      bool is_null (false);
      std::size_t cap (i.notes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.notes_value,
        i.notes_size,
        is_null,
        v);
      i.notes_null = is_null;
      grew = grew || (cap != i.notes_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::pio::signal_time >::
  init (value_type& o, const image_type&  i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // timing
    //
    {
      int& v =
        o.timing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.timing_value,
        i.timing_null);
    }

    // phasing
    //
    {
      int& v =
        o.phasing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phasing_value,
        i.phasing_null);
    }

    // notes
    //
    {
      ::std::string& v =
        o.notes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.notes_value,
        i.notes_size,
        i.notes_null);
    }
  }

  // Node
  //

  access::object_traits< ::pio::Node >::id_type
  access::object_traits< ::pio::Node >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.node_value,
        i.node_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Node >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // node
    //
    t[0UL] = false;

    // x
    //
    t[1UL] = false;

    // y
    //
    t[2UL] = false;

    // z
    //
    t[3UL] = false;

    // subarea
    //
    t[4UL] = false;

    // part
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Node >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // node
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.node_value;
      b[n].is_null = &i.node_null;
      n++;
    }

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;

    // subarea
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subarea_value;
    b[n].is_null = &i.subarea_null;
    n++;

    // part
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.part_value;
    b[n].is_null = &i.part_null;
    n++;
  }

  void access::object_traits< ::pio::Node >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Node >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // node
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.node;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.node_value,
        is_null,
        v);
      i.node_null = is_null;
    }

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    // subarea
    //
    {
      int const& v =
        o.subarea;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subarea_value,
        is_null,
        v);
      i.subarea_null = is_null;
    }

    // part
    //
    {
      int const& v =
        o.part;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.part_value,
        is_null,
        v);
      i.part_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Node >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // node
    //
    {
      int& v =
        o.node;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.node_value,
        i.node_null);
    }

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }

    // subarea
    //
    {
      int& v =
        o.subarea;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subarea_value,
        i.subarea_null);
    }

    // part
    //
    {
      int& v =
        o.part;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.part_value,
        i.part_null);
    }
  }

  void access::object_traits< ::pio::Node >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Node >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Node >::persist_statement[] =
  "INSERT INTO \"NODE\" ("
  "\"NODE\","
  "\"X\","
  "\"Y\","
  "\"Z\","
  "\"SUBAREA\","
  "\"PART\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Node >::find_statement[] =
  "SELECT "
  "\"NODE\".\"NODE\","
  "\"NODE\".\"X\","
  "\"NODE\".\"Y\","
  "\"NODE\".\"Z\","
  "\"NODE\".\"SUBAREA\","
  "\"NODE\".\"PART\""
  " FROM \"NODE\""
  " WHERE \"NODE\".\"NODE\"=?";

  const char access::object_traits< ::pio::Node >::update_statement[] =
  "UPDATE \"NODE\" SET "
  "\"X\"=?,"
  "\"Y\"=?,"
  "\"Z\"=?,"
  "\"SUBAREA\"=?,"
  "\"PART\"=?"
  " WHERE \"NODE\"=?";

  const char access::object_traits< ::pio::Node >::erase_statement[] =
  "DELETE FROM \"NODE\""
  " WHERE \"NODE\"=?";

  const char access::object_traits< ::pio::Node >::query_statement[] =
  "SELECT "
  "\"NODE\".\"NODE\","
  "\"NODE\".\"X\","
  "\"NODE\".\"Y\","
  "\"NODE\".\"Z\","
  "\"NODE\".\"SUBAREA\","
  "\"NODE\".\"PART\""
  " FROM \"NODE\""
  " ";

  const char access::object_traits< ::pio::Node >::erase_query_statement[] =
  "DELETE FROM \"NODE\""
  " ";

  const char access::object_traits< ::pio::Node >::table_name[] =
  "\"NODE\"";

  void access::object_traits< ::pio::Node >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Node >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.node);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Node >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Node >::pointer_type
  access::object_traits< ::pio::Node >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Node >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Node >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.node);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Node >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Node >::object_type >
  access::object_traits< ::pio::Node >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Node >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Node >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"NODE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"NODE\" (\n"
                      "  \"NODE\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"X\" REAL,\n"
                      "  \"Y\" REAL,\n"
                      "  \"Z\" REAL,\n"
                      "  \"SUBAREA\" INTEGER NOT NULL,\n"
                      "  \"PART\" INTEGER NOT NULL)");
          db.execute ("CREATE INDEX \"NODE_NODE_i\"\n"
                      "  ON \"NODE\" (\"NODE\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Node_ (
    "",
    &access::object_traits< ::pio::Node >::create_schema);

  // Zone
  //

  access::object_traits< ::pio::Zone >::id_type
  access::object_traits< ::pio::Zone >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.zone_value,
        i.zone_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Zone >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // zone
    //
    t[0UL] = false;

    // x
    //
    t[1UL] = false;

    // y
    //
    t[2UL] = false;

    // z
    //
    t[3UL] = false;

    // area
    //
    t[4UL] = false;

    // min_x
    //
    t[5UL] = false;

    // min_y
    //
    t[6UL] = false;

    // max_x
    //
    t[7UL] = false;

    // max_y
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Zone >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // zone
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.zone_value;
      b[n].is_null = &i.zone_null;
      n++;
    }

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;

    // area
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.area_value;
    b[n].is_null = &i.area_null;
    n++;

    // min_x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_x_value;
    b[n].is_null = &i.min_x_null;
    n++;

    // min_y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_y_value;
    b[n].is_null = &i.min_y_null;
    n++;

    // max_x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_x_value;
    b[n].is_null = &i.max_x_null;
    n++;

    // max_y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_y_value;
    b[n].is_null = &i.max_y_null;
    n++;
  }

  void access::object_traits< ::pio::Zone >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Zone >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // zone
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.zone;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.zone_value,
        is_null,
        v);
      i.zone_null = is_null;
    }

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    // area
    //
    {
      int const& v =
        o.area;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.area_value,
        is_null,
        v);
      i.area_null = is_null;
    }

    // min_x
    //
    {
      double const& v =
        o.min_x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_x_value,
        is_null,
        v);
      i.min_x_null = is_null;
    }

    // min_y
    //
    {
      double const& v =
        o.min_y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_y_value,
        is_null,
        v);
      i.min_y_null = is_null;
    }

    // max_x
    //
    {
      double const& v =
        o.max_x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_x_value,
        is_null,
        v);
      i.max_x_null = is_null;
    }

    // max_y
    //
    {
      double const& v =
        o.max_y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_y_value,
        is_null,
        v);
      i.max_y_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Zone >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // zone
    //
    {
      int& v =
        o.zone;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.zone_value,
        i.zone_null);
    }

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }

    // area
    //
    {
      int& v =
        o.area;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.area_value,
        i.area_null);
    }

    // min_x
    //
    {
      double& v =
        o.min_x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_x_value,
        i.min_x_null);
    }

    // min_y
    //
    {
      double& v =
        o.min_y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_y_value,
        i.min_y_null);
    }

    // max_x
    //
    {
      double& v =
        o.max_x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_x_value,
        i.max_x_null);
    }

    // max_y
    //
    {
      double& v =
        o.max_y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_y_value,
        i.max_y_null);
    }
  }

  void access::object_traits< ::pio::Zone >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Zone >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Zone >::persist_statement[] =
  "INSERT INTO \"ZONE\" ("
  "\"ZONE\","
  "\"X\","
  "\"Y\","
  "\"Z\","
  "\"AREA\","
  "\"MIN_X\","
  "\"MIN_Y\","
  "\"MAX_X\","
  "\"MAX_Y\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Zone >::find_statement[] =
  "SELECT "
  "\"ZONE\".\"ZONE\","
  "\"ZONE\".\"X\","
  "\"ZONE\".\"Y\","
  "\"ZONE\".\"Z\","
  "\"ZONE\".\"AREA\","
  "\"ZONE\".\"MIN_X\","
  "\"ZONE\".\"MIN_Y\","
  "\"ZONE\".\"MAX_X\","
  "\"ZONE\".\"MAX_Y\""
  " FROM \"ZONE\""
  " WHERE \"ZONE\".\"ZONE\"=?";

  const char access::object_traits< ::pio::Zone >::update_statement[] =
  "UPDATE \"ZONE\" SET "
  "\"X\"=?,"
  "\"Y\"=?,"
  "\"Z\"=?,"
  "\"AREA\"=?,"
  "\"MIN_X\"=?,"
  "\"MIN_Y\"=?,"
  "\"MAX_X\"=?,"
  "\"MAX_Y\"=?"
  " WHERE \"ZONE\"=?";

  const char access::object_traits< ::pio::Zone >::erase_statement[] =
  "DELETE FROM \"ZONE\""
  " WHERE \"ZONE\"=?";

  const char access::object_traits< ::pio::Zone >::query_statement[] =
  "SELECT "
  "\"ZONE\".\"ZONE\","
  "\"ZONE\".\"X\","
  "\"ZONE\".\"Y\","
  "\"ZONE\".\"Z\","
  "\"ZONE\".\"AREA\","
  "\"ZONE\".\"MIN_X\","
  "\"ZONE\".\"MIN_Y\","
  "\"ZONE\".\"MAX_X\","
  "\"ZONE\".\"MAX_Y\""
  " FROM \"ZONE\""
  " ";

  const char access::object_traits< ::pio::Zone >::erase_query_statement[] =
  "DELETE FROM \"ZONE\""
  " ";

  const char access::object_traits< ::pio::Zone >::table_name[] =
  "\"ZONE\"";

  void access::object_traits< ::pio::Zone >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Zone >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.zone);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Zone >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Zone >::pointer_type
  access::object_traits< ::pio::Zone >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Zone >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Zone >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.zone);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Zone >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Zone >::object_type >
  access::object_traits< ::pio::Zone >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Zone >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Zone >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"ZONE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"ZONE\" (\n"
                      "  \"ZONE\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"X\" REAL,\n"
                      "  \"Y\" REAL,\n"
                      "  \"Z\" REAL,\n"
                      "  \"AREA\" INTEGER NOT NULL,\n"
                      "  \"MIN_X\" REAL,\n"
                      "  \"MIN_Y\" REAL,\n"
                      "  \"MAX_X\" REAL,\n"
                      "  \"MAX_Y\" REAL)");
          db.execute ("CREATE INDEX \"ZONE_ZONE_i\"\n"
                      "  ON \"ZONE\" (\"ZONE\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Zone_ (
    "",
    &access::object_traits< ::pio::Zone >::create_schema);

  // Shape
  //

  // nested_records
  //

  const char access::object_traits< ::pio::Shape >::nested_records_traits::
  select_all_statement[] =
  "SELECT "
  "\"SHAPE_nested_records\".\"index\","
  "\"SHAPE_nested_records\".\"value_x\","
  "\"SHAPE_nested_records\".\"value_y\","
  "\"SHAPE_nested_records\".\"value_z\""
  " FROM \"SHAPE_nested_records\""
  " WHERE \"SHAPE_nested_records\".\"object_id\"=?"
  " ORDER BY \"SHAPE_nested_records\".\"index\"";

  const char access::object_traits< ::pio::Shape >::nested_records_traits::
  insert_one_statement[] =
  "INSERT INTO \"SHAPE_nested_records\" ("
  "\"object_id\","
  "\"index\","
  "\"value_x\","
  "\"value_y\","
  "\"value_z\")"
  " VALUES (?,?,?,?,?)";

  const char access::object_traits< ::pio::Shape >::nested_records_traits::
  delete_all_statement[] =
  "DELETE FROM \"SHAPE_nested_records\""
  " WHERE \"object_id\"=?";

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        cond_image_type& c)
  {
    ODB_POTENTIALLY_UNUSED (c);

    std::size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type >::bind (b + n, d.value_value, sk);
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  grow (data_image_type& i, bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    if (composite_value_traits< value_type >::grow (
          i.value_value, t + 1UL))
    {
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  init (data_image_type& i, index_type j, const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        j);
      i.index_null = is_null;
    }

    // value
    //
    {
      composite_value_traits< value_type >::init (
        i.value_value,
        v,
        sk);
    }

    if (grew)
      i.version++;
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  init (index_type& j, value_type& v, const data_image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  insert_one (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    binding& b (sts.data_image_binding ());
    data_image_type& di (sts.data_image ());

    init (di, i, v);

    if (di.version != sts.data_image_version ())
    {
      bind (b.bind, 0, sts.id_binding ().count, di);
      sts.data_image_version (di.version);
      b.version++;
      sts.select_image_binding ().version++;
    }

    if (!sts.insert_one_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits< ::pio::Shape >::nested_records_traits::
  load_all (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());
    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_all_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  delete_all (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_all_statement ().execute ();
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  persist (const container_type& c,
           const sqlite::binding& id,
           statements_type& sts)
  {
    using namespace sqlite;

    binding& b (sts.data_image_binding ());
    if (id.version != sts.data_id_binding_version () || b.version == 0)
    {
      bind (b.bind, id.bind, id.count, sts.data_image ());
      sts.data_id_binding_version (id.version);
      b.version++;
      sts.select_image_binding ().version++;
    }

    sts.id_binding (id);
    functions_type& fs (sts.functions ());
    fs.ordered (true);
    container_traits_type::persist (c, fs);
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  load (container_type& c,
        const sqlite::binding& id,
        statements_type& sts)
  {
    using namespace sqlite;

    binding& db (sts.data_image_binding ());
    if (id.version != sts.data_id_binding_version () || db.version == 0)
    {
      bind (db.bind, id.bind, id.count, sts.data_image ());
      sts.data_id_binding_version (id.version);
      db.version++;
      sts.select_image_binding ().version++;
    }

    binding& cb (sts.cond_image_binding ());
    if (id.version != sts.cond_id_binding_version () || cb.version == 0)
    {
      bind (cb.bind, id.bind, id.count, sts.cond_image ());
      sts.cond_id_binding_version (id.version);
      cb.version++;
    }

    select_statement& st (sts.select_all_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    sts.id_binding (id);
    functions_type& fs (sts.functions ());
    fs.ordered (true);
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  update (const container_type& c,
          const sqlite::binding& id,
          statements_type& sts)
  {
    using namespace sqlite;

    binding& db (sts.data_image_binding ());
    if (id.version != sts.data_id_binding_version () || db.version == 0)
    {
      bind (db.bind, id.bind, id.count, sts.data_image ());
      sts.data_id_binding_version (id.version);
      db.version++;
      sts.select_image_binding ().version++;
    }

    binding& cb (sts.cond_image_binding ());
    if (id.version != sts.cond_id_binding_version () || cb.version == 0)
    {
      bind (cb.bind, id.bind, id.count, sts.cond_image ());
      sts.cond_id_binding_version (id.version);
      cb.version++;
    }

    sts.id_binding (id);
    functions_type& fs (sts.functions ());
    fs.ordered (true);
    container_traits_type::update (c, fs);
  }

  void access::object_traits< ::pio::Shape >::nested_records_traits::
  erase (const sqlite::binding& id, statements_type& sts)
  {
    using namespace sqlite;

    binding& b (sts.cond_image_binding ());
    if (id.version != sts.cond_id_binding_version () || b.version == 0)
    {
      bind (b.bind, id.bind, id.count, sts.cond_image ());
      sts.cond_id_binding_version (id.version);
      b.version++;
    }

    sts.id_binding (id);
    functions_type& fs (sts.functions ());
    fs.ordered (true);
    container_traits_type::erase (fs);
  }

  access::object_traits< ::pio::Shape >::id_type
  access::object_traits< ::pio::Shape >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Shape >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // points
    //
    t[2UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Shape >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // points
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.points_value;
    b[n].is_null = &i.points_null;
    n++;
  }

  void access::object_traits< ::pio::Shape >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Shape >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // points
    //
    {
      int const& v =
        o.points;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.points_value,
        is_null,
        v);
      i.points_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Shape >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // points
    //
    {
      int& v =
        o.points;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.points_value,
        i.points_null);
    }
  }

  void access::object_traits< ::pio::Shape >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Shape >::container_statement_cache_type
  {
    sqlite::container_statements_impl< nested_records_traits > nested_records;

    container_statement_cache_type (sqlite::connection& c)
    : nested_records (c)
    {
    }
  };

  const char access::object_traits< ::pio::Shape >::persist_statement[] =
  "INSERT INTO \"SHAPE\" ("
  "\"auto_id\","
  "\"LINK\","
  "\"POINTS\")"
  " VALUES (?,?,?)";

  const char access::object_traits< ::pio::Shape >::find_statement[] =
  "SELECT "
  "\"SHAPE\".\"auto_id\","
  "\"SHAPE\".\"LINK\","
  "\"SHAPE\".\"POINTS\""
  " FROM \"SHAPE\""
  " WHERE \"SHAPE\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Shape >::update_statement[] =
  "UPDATE \"SHAPE\" SET "
  "\"LINK\"=?,"
  "\"POINTS\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Shape >::erase_statement[] =
  "DELETE FROM \"SHAPE\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Shape >::query_statement[] =
  "SELECT "
  "\"SHAPE\".\"auto_id\","
  "\"SHAPE\".\"LINK\","
  "\"SHAPE\".\"POINTS\""
  " FROM \"SHAPE\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"SHAPE\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Shape >::erase_query_statement[] =
  "DELETE FROM \"SHAPE\""
  " ";

  const char access::object_traits< ::pio::Shape >::table_name[] =
  "\"SHAPE\"";

  void access::object_traits< ::pio::Shape >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    {
      ::std::vector< ::pio::shape_geometry > const& v =
        obj.nested_records;

      nested_records_traits::persist (
        v,
        idb,
        sts.container_statment_cache ().nested_records);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Shape >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    // nested_records
    //
    {
      ::std::vector< ::pio::shape_geometry > const& v =
        obj.nested_records;

      nested_records_traits::update (
        v,
        idb,
        sts.container_statment_cache ().nested_records);
    }

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Shape >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    nested_records_traits::erase (
      idb,
      sts.container_statment_cache ().nested_records);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Shape >::pointer_type
  access::object_traits< ::pio::Shape >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Shape >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Shape >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Shape >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  void access::object_traits< ::pio::Shape >::
  load_ (statements_type& sts, object_type& obj)
  {
    sqlite::binding& idb (sts.id_image_binding ());

    // nested_records
    //
    {
      ::std::vector< ::pio::shape_geometry >& v =
        obj.nested_records;

      nested_records_traits::load (
        v,
        idb,
        sts.container_statment_cache ().nested_records);
    }
  }

  result< access::object_traits< ::pio::Shape >::object_type >
  access::object_traits< ::pio::Shape >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Shape >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Shape >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"SHAPE_nested_records\"");
          db.execute ("DROP TABLE IF EXISTS \"SHAPE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"SHAPE\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"POINTS\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"SHAPE_nested_records\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value_x\" REAL,\n"
                      "  \"value_y\" REAL,\n"
                      "  \"value_z\" REAL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"SHAPE\" (\"auto_id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"SHAPE_nested_records_object_id_i\"\n"
                      "  ON \"SHAPE_nested_records\" (\"object_id\")");
          db.execute ("CREATE INDEX \"SHAPE_nested_records_index_i\"\n"
                      "  ON \"SHAPE_nested_records\" (\"index\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Shape_ (
    "",
    &access::object_traits< ::pio::Shape >::create_schema);

  // Link
  //

  access::object_traits< ::pio::Link >::id_type
  access::object_traits< ::pio::Link >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.link_value,
        i.link_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Link >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // link
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // node_a
    //
    t[2UL] = false;

    // node_b
    //
    t[3UL] = false;

    // length
    //
    t[4UL] = false;

    // setback_a
    //
    t[5UL] = false;

    // setback_b
    //
    t[6UL] = false;

    // bearing_a
    //
    t[7UL] = false;

    // bearing_b
    //
    t[8UL] = false;

    // type
    //
    if (t[9UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // divided
    //
    t[10UL] = false;

    // area_type
    //
    t[11UL] = false;

    // use
    //
    t[12UL] = false;

    // grade
    //
    t[13UL] = false;

    // lanes_ab
    //
    t[14UL] = false;

    // speed_ab
    //
    t[15UL] = false;

    // fspd_ab
    //
    t[16UL] = false;

    // cap_ab
    //
    t[17UL] = false;

    // lanes_ba
    //
    t[18UL] = false;

    // speed_ba
    //
    t[19UL] = false;

    // fspd_ba
    //
    t[20UL] = false;

    // cap_ba
    //
    t[21UL] = false;

    // left_ab
    //
    t[22UL] = false;

    // right_ab
    //
    t[23UL] = false;

    // left_ba
    //
    t[24UL] = false;

    // right_ba
    //
    t[25UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Link >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // link
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.link_value;
      b[n].is_null = &i.link_null;
      n++;
    }

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // node_a
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_a_value;
    b[n].is_null = &i.node_a_null;
    n++;

    // node_b
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_b_value;
    b[n].is_null = &i.node_b_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // setback_a
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_a_value;
    b[n].is_null = &i.setback_a_null;
    n++;

    // setback_b
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_b_value;
    b[n].is_null = &i.setback_b_null;
    n++;

    // bearing_a
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bearing_a_value;
    b[n].is_null = &i.bearing_a_null;
    n++;

    // bearing_b
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bearing_b_value;
    b[n].is_null = &i.bearing_b_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // divided
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.divided_value;
    b[n].is_null = &i.divided_null;
    n++;

    // area_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.area_type_value;
    b[n].is_null = &i.area_type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // grade
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.grade_value;
    b[n].is_null = &i.grade_null;
    n++;

    // lanes_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_ab_value;
    b[n].is_null = &i.lanes_ab_null;
    n++;

    // speed_ab
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_ab_value;
    b[n].is_null = &i.speed_ab_null;
    n++;

    // fspd_ab
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.fspd_ab_value;
    b[n].is_null = &i.fspd_ab_null;
    n++;

    // cap_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cap_ab_value;
    b[n].is_null = &i.cap_ab_null;
    n++;

    // lanes_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_ba_value;
    b[n].is_null = &i.lanes_ba_null;
    n++;

    // speed_ba
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_ba_value;
    b[n].is_null = &i.speed_ba_null;
    n++;

    // fspd_ba
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.fspd_ba_value;
    b[n].is_null = &i.fspd_ba_null;
    n++;

    // cap_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cap_ba_value;
    b[n].is_null = &i.cap_ba_null;
    n++;

    // left_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.left_ab_value;
    b[n].is_null = &i.left_ab_null;
    n++;

    // right_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.right_ab_value;
    b[n].is_null = &i.right_ab_null;
    n++;

    // left_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.left_ba_value;
    b[n].is_null = &i.left_ba_null;
    n++;

    // right_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.right_ba_value;
    b[n].is_null = &i.right_ba_null;
    n++;
  }

  void access::object_traits< ::pio::Link >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Link >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // link
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.link;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.link_value,
        is_null,
        v);
      i.link_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // node_a
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.node_a;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_a_value,
          is_null,
          id);
        i.node_a_null = is_null;
      }
      else
        i.node_a_null = true;
    }

    // node_b
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.node_b;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_b_value,
          is_null,
          id);
        i.node_b_null = is_null;
      }
      else
        i.node_b_null = true;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // setback_a
    //
    {
      double const& v =
        o.setback_a;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_a_value,
        is_null,
        v);
      i.setback_a_null = is_null;
    }

    // setback_b
    //
    {
      double const& v =
        o.setback_b;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_b_value,
        is_null,
        v);
      i.setback_b_null = is_null;
    }

    // bearing_a
    //
    {
      int const& v =
        o.bearing_a;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.bearing_a_value,
        is_null,
        v);
      i.bearing_a_null = is_null;
    }

    // bearing_b
    //
    {
      int const& v =
        o.bearing_b;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.bearing_b_value,
        is_null,
        v);
      i.bearing_b_null = is_null;
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // divided
    //
    {
      int const& v =
        o.divided;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.divided_value,
        is_null,
        v);
      i.divided_null = is_null;
    }

    // area_type
    //
    {
      int const& v =
        o.area_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.area_type_value,
        is_null,
        v);
      i.area_type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // grade
    //
    {
      double const& v =
        o.grade;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.grade_value,
        is_null,
        v);
      i.grade_null = is_null;
    }

    // lanes_ab
    //
    {
      int const& v =
        o.lanes_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_ab_value,
        is_null,
        v);
      i.lanes_ab_null = is_null;
    }

    // speed_ab
    //
    {
      double const& v =
        o.speed_ab;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_ab_value,
        is_null,
        v);
      i.speed_ab_null = is_null;
    }

    // fspd_ab
    //
    {
      double const& v =
        o.fspd_ab;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.fspd_ab_value,
        is_null,
        v);
      i.fspd_ab_null = is_null;
    }

    // cap_ab
    //
    {
      int const& v =
        o.cap_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cap_ab_value,
        is_null,
        v);
      i.cap_ab_null = is_null;
    }

    // lanes_ba
    //
    {
      int const& v =
        o.lanes_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_ba_value,
        is_null,
        v);
      i.lanes_ba_null = is_null;
    }

    // speed_ba
    //
    {
      double const& v =
        o.speed_ba;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_ba_value,
        is_null,
        v);
      i.speed_ba_null = is_null;
    }

    // fspd_ba
    //
    {
      double const& v =
        o.fspd_ba;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.fspd_ba_value,
        is_null,
        v);
      i.fspd_ba_null = is_null;
    }

    // cap_ba
    //
    {
      int const& v =
        o.cap_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cap_ba_value,
        is_null,
        v);
      i.cap_ba_null = is_null;
    }

    // left_ab
    //
    {
      int const& v =
        o.left_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.left_ab_value,
        is_null,
        v);
      i.left_ab_null = is_null;
    }

    // right_ab
    //
    {
      int const& v =
        o.right_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.right_ab_value,
        is_null,
        v);
      i.right_ab_null = is_null;
    }

    // left_ba
    //
    {
      int const& v =
        o.left_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.left_ba_value,
        is_null,
        v);
      i.left_ba_null = is_null;
    }

    // right_ba
    //
    {
      int const& v =
        o.right_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.right_ba_value,
        is_null,
        v);
      i.right_ba_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Link >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // link
    //
    {
      int& v =
        o.link;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.link_value,
        i.link_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // node_a
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.node_a;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.node_a_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_a_value,
          i.node_a_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // node_b
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.node_b;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.node_b_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_b_value,
          i.node_b_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // setback_a
    //
    {
      double& v =
        o.setback_a;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_a_value,
        i.setback_a_null);
    }

    // setback_b
    //
    {
      double& v =
        o.setback_b;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_b_value,
        i.setback_b_null);
    }

    // bearing_a
    //
    {
      int& v =
        o.bearing_a;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.bearing_a_value,
        i.bearing_a_null);
    }

    // bearing_b
    //
    {
      int& v =
        o.bearing_b;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.bearing_b_value,
        i.bearing_b_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // divided
    //
    {
      int& v =
        o.divided;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.divided_value,
        i.divided_null);
    }

    // area_type
    //
    {
      int& v =
        o.area_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.area_type_value,
        i.area_type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // grade
    //
    {
      double& v =
        o.grade;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.grade_value,
        i.grade_null);
    }

    // lanes_ab
    //
    {
      int& v =
        o.lanes_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_ab_value,
        i.lanes_ab_null);
    }

    // speed_ab
    //
    {
      double& v =
        o.speed_ab;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_ab_value,
        i.speed_ab_null);
    }

    // fspd_ab
    //
    {
      double& v =
        o.fspd_ab;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.fspd_ab_value,
        i.fspd_ab_null);
    }

    // cap_ab
    //
    {
      int& v =
        o.cap_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cap_ab_value,
        i.cap_ab_null);
    }

    // lanes_ba
    //
    {
      int& v =
        o.lanes_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_ba_value,
        i.lanes_ba_null);
    }

    // speed_ba
    //
    {
      double& v =
        o.speed_ba;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_ba_value,
        i.speed_ba_null);
    }

    // fspd_ba
    //
    {
      double& v =
        o.fspd_ba;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.fspd_ba_value,
        i.fspd_ba_null);
    }

    // cap_ba
    //
    {
      int& v =
        o.cap_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cap_ba_value,
        i.cap_ba_null);
    }

    // left_ab
    //
    {
      int& v =
        o.left_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.left_ab_value,
        i.left_ab_null);
    }

    // right_ab
    //
    {
      int& v =
        o.right_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.right_ab_value,
        i.right_ab_null);
    }

    // left_ba
    //
    {
      int& v =
        o.left_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.left_ba_value,
        i.left_ba_null);
    }

    // right_ba
    //
    {
      int& v =
        o.right_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.right_ba_value,
        i.right_ba_null);
    }
  }

  void access::object_traits< ::pio::Link >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Link >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Link >::persist_statement[] =
  "INSERT INTO \"LINK\" ("
  "\"LINK\","
  "\"NAME\","
  "\"NODE_A\","
  "\"NODE_B\","
  "\"LENGTH\","
  "\"SETBACK_A\","
  "\"SETBACK_B\","
  "\"BEARING_A\","
  "\"BEARING_B\","
  "\"TYPE\","
  "\"DIVIDED\","
  "\"AREA_TYPE\","
  "\"USE\","
  "\"GRADE\","
  "\"LANES_AB\","
  "\"SPEED_AB\","
  "\"FSPD_AB\","
  "\"CAP_AB\","
  "\"LANES_BA\","
  "\"SPEED_BA\","
  "\"FSPD_BA\","
  "\"CAP_BA\","
  "\"LEFT_AB\","
  "\"RIGHT_AB\","
  "\"LEFT_BA\","
  "\"RIGHT_BA\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Link >::find_statement[] =
  "SELECT "
  "\"LINK\".\"LINK\","
  "\"LINK\".\"NAME\","
  "\"LINK\".\"NODE_A\","
  "\"LINK\".\"NODE_B\","
  "\"LINK\".\"LENGTH\","
  "\"LINK\".\"SETBACK_A\","
  "\"LINK\".\"SETBACK_B\","
  "\"LINK\".\"BEARING_A\","
  "\"LINK\".\"BEARING_B\","
  "\"LINK\".\"TYPE\","
  "\"LINK\".\"DIVIDED\","
  "\"LINK\".\"AREA_TYPE\","
  "\"LINK\".\"USE\","
  "\"LINK\".\"GRADE\","
  "\"LINK\".\"LANES_AB\","
  "\"LINK\".\"SPEED_AB\","
  "\"LINK\".\"FSPD_AB\","
  "\"LINK\".\"CAP_AB\","
  "\"LINK\".\"LANES_BA\","
  "\"LINK\".\"SPEED_BA\","
  "\"LINK\".\"FSPD_BA\","
  "\"LINK\".\"CAP_BA\","
  "\"LINK\".\"LEFT_AB\","
  "\"LINK\".\"RIGHT_AB\","
  "\"LINK\".\"LEFT_BA\","
  "\"LINK\".\"RIGHT_BA\""
  " FROM \"LINK\""
  " WHERE \"LINK\".\"LINK\"=?";

  const char access::object_traits< ::pio::Link >::update_statement[] =
  "UPDATE \"LINK\" SET "
  "\"NAME\"=?,"
  "\"NODE_A\"=?,"
  "\"NODE_B\"=?,"
  "\"LENGTH\"=?,"
  "\"SETBACK_A\"=?,"
  "\"SETBACK_B\"=?,"
  "\"BEARING_A\"=?,"
  "\"BEARING_B\"=?,"
  "\"TYPE\"=?,"
  "\"DIVIDED\"=?,"
  "\"AREA_TYPE\"=?,"
  "\"USE\"=?,"
  "\"GRADE\"=?,"
  "\"LANES_AB\"=?,"
  "\"SPEED_AB\"=?,"
  "\"FSPD_AB\"=?,"
  "\"CAP_AB\"=?,"
  "\"LANES_BA\"=?,"
  "\"SPEED_BA\"=?,"
  "\"FSPD_BA\"=?,"
  "\"CAP_BA\"=?,"
  "\"LEFT_AB\"=?,"
  "\"RIGHT_AB\"=?,"
  "\"LEFT_BA\"=?,"
  "\"RIGHT_BA\"=?"
  " WHERE \"LINK\"=?";

  const char access::object_traits< ::pio::Link >::erase_statement[] =
  "DELETE FROM \"LINK\""
  " WHERE \"LINK\"=?";

  const char access::object_traits< ::pio::Link >::query_statement[] =
  "SELECT "
  "\"LINK\".\"LINK\","
  "\"LINK\".\"NAME\","
  "\"LINK\".\"NODE_A\","
  "\"LINK\".\"NODE_B\","
  "\"LINK\".\"LENGTH\","
  "\"LINK\".\"SETBACK_A\","
  "\"LINK\".\"SETBACK_B\","
  "\"LINK\".\"BEARING_A\","
  "\"LINK\".\"BEARING_B\","
  "\"LINK\".\"TYPE\","
  "\"LINK\".\"DIVIDED\","
  "\"LINK\".\"AREA_TYPE\","
  "\"LINK\".\"USE\","
  "\"LINK\".\"GRADE\","
  "\"LINK\".\"LANES_AB\","
  "\"LINK\".\"SPEED_AB\","
  "\"LINK\".\"FSPD_AB\","
  "\"LINK\".\"CAP_AB\","
  "\"LINK\".\"LANES_BA\","
  "\"LINK\".\"SPEED_BA\","
  "\"LINK\".\"FSPD_BA\","
  "\"LINK\".\"CAP_BA\","
  "\"LINK\".\"LEFT_AB\","
  "\"LINK\".\"RIGHT_AB\","
  "\"LINK\".\"LEFT_BA\","
  "\"LINK\".\"RIGHT_BA\""
  " FROM \"LINK\""
  " LEFT JOIN \"NODE\" AS \"NODE_A\" ON \"NODE_A\".\"NODE\"=\"LINK\".\"NODE_A\""
  " LEFT JOIN \"NODE\" AS \"NODE_B\" ON \"NODE_B\".\"NODE\"=\"LINK\".\"NODE_B\""
  " ";

  const char access::object_traits< ::pio::Link >::erase_query_statement[] =
  "DELETE FROM \"LINK\""
  " ";

  const char access::object_traits< ::pio::Link >::table_name[] =
  "\"LINK\"";

  void access::object_traits< ::pio::Link >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Link >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.link);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Link >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Link >::pointer_type
  access::object_traits< ::pio::Link >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Link >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Link >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.link);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Link >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Link >::object_type >
  access::object_traits< ::pio::Link >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Link >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Link >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"LINK\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"LINK\" (\n"
                      "  \"LINK\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"NAME\" TEXT NOT NULL,\n"
                      "  \"NODE_A\" INTEGER,\n"
                      "  \"NODE_B\" INTEGER,\n"
                      "  \"LENGTH\" REAL,\n"
                      "  \"SETBACK_A\" REAL,\n"
                      "  \"SETBACK_B\" REAL,\n"
                      "  \"BEARING_A\" INTEGER NOT NULL,\n"
                      "  \"BEARING_B\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" TEXT NOT NULL,\n"
                      "  \"DIVIDED\" INTEGER NOT NULL,\n"
                      "  \"AREA_TYPE\" INTEGER NOT NULL,\n"
                      "  \"USE\" INTEGER NOT NULL,\n"
                      "  \"GRADE\" REAL,\n"
                      "  \"LANES_AB\" INTEGER NOT NULL,\n"
                      "  \"SPEED_AB\" REAL,\n"
                      "  \"FSPD_AB\" REAL,\n"
                      "  \"CAP_AB\" INTEGER NOT NULL,\n"
                      "  \"LANES_BA\" INTEGER NOT NULL,\n"
                      "  \"SPEED_BA\" REAL,\n"
                      "  \"FSPD_BA\" REAL,\n"
                      "  \"CAP_BA\" INTEGER NOT NULL,\n"
                      "  \"LEFT_AB\" INTEGER NOT NULL,\n"
                      "  \"RIGHT_AB\" INTEGER NOT NULL,\n"
                      "  \"LEFT_BA\" INTEGER NOT NULL,\n"
                      "  \"RIGHT_BA\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"NODE_A_fk\"\n"
                      "    FOREIGN KEY (\"NODE_A\")\n"
                      "    REFERENCES \"NODE\" (\"NODE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"NODE_B_fk\"\n"
                      "    FOREIGN KEY (\"NODE_B\")\n"
                      "    REFERENCES \"NODE\" (\"NODE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"LINK_LINK_i\"\n"
                      "  ON \"LINK\" (\"LINK\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Link_ (
    "",
    &access::object_traits< ::pio::Link >::create_schema);

  // Pocket
  //

  access::object_traits< ::pio::Pocket >::id_type
  access::object_traits< ::pio::Pocket >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Pocket >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // type
    //
    if (t[3UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // lanes
    //
    t[4UL] = false;

    // length
    //
    t[5UL] = false;

    // offset
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Pocket >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;
  }

  void access::object_traits< ::pio::Pocket >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Pocket >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Pocket >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }
  }

  void access::object_traits< ::pio::Pocket >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Pocket >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Pocket >::persist_statement[] =
  "INSERT INTO \"POCKET\" ("
  "\"auto_id\","
  "\"LINK\","
  "\"DIR\","
  "\"TYPE\","
  "\"LANES\","
  "\"LENGTH\","
  "\"OFFSET\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Pocket >::find_statement[] =
  "SELECT "
  "\"POCKET\".\"auto_id\","
  "\"POCKET\".\"LINK\","
  "\"POCKET\".\"DIR\","
  "\"POCKET\".\"TYPE\","
  "\"POCKET\".\"LANES\","
  "\"POCKET\".\"LENGTH\","
  "\"POCKET\".\"OFFSET\""
  " FROM \"POCKET\""
  " WHERE \"POCKET\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Pocket >::update_statement[] =
  "UPDATE \"POCKET\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"TYPE\"=?,"
  "\"LANES\"=?,"
  "\"LENGTH\"=?,"
  "\"OFFSET\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Pocket >::erase_statement[] =
  "DELETE FROM \"POCKET\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Pocket >::query_statement[] =
  "SELECT "
  "\"POCKET\".\"auto_id\","
  "\"POCKET\".\"LINK\","
  "\"POCKET\".\"DIR\","
  "\"POCKET\".\"TYPE\","
  "\"POCKET\".\"LANES\","
  "\"POCKET\".\"LENGTH\","
  "\"POCKET\".\"OFFSET\""
  " FROM \"POCKET\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"POCKET\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Pocket >::erase_query_statement[] =
  "DELETE FROM \"POCKET\""
  " ";

  const char access::object_traits< ::pio::Pocket >::table_name[] =
  "\"POCKET\"";

  void access::object_traits< ::pio::Pocket >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Pocket >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Pocket >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Pocket >::pointer_type
  access::object_traits< ::pio::Pocket >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Pocket >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Pocket >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Pocket >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Pocket >::object_type >
  access::object_traits< ::pio::Pocket >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Pocket >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Pocket >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"POCKET\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"POCKET\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" TEXT NOT NULL,\n"
                      "  \"LANES\" INTEGER NOT NULL,\n"
                      "  \"LENGTH\" REAL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Pocket_ (
    "",
    &access::object_traits< ::pio::Pocket >::create_schema);

  // Lane_Use
  //

  access::object_traits< ::pio::Lane_Use >::id_type
  access::object_traits< ::pio::Lane_Use >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // lanes
    //
    t[3UL] = false;

    // use
    //
    t[4UL] = false;

    // type
    //
    t[5UL] = false;

    // min_type
    //
    t[6UL] = false;

    // max_type
    //
    t[7UL] = false;

    // min_trav
    //
    t[8UL] = false;

    // max_trav
    //
    t[9UL] = false;

    // start
    //
    t[10UL] = false;

    // end
    //
    t[11UL] = false;

    // offset
    //
    t[12UL] = false;

    // length
    //
    t[13UL] = false;

    // toll
    //
    t[14UL] = false;

    // rate
    //
    t[15UL] = false;

    // min_delay
    //
    t[16UL] = false;

    // max_delay
    //
    t[17UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Lane_Use >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // min_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_type_value;
    b[n].is_null = &i.min_type_null;
    n++;

    // max_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_type_value;
    b[n].is_null = &i.max_type_null;
    n++;

    // min_trav
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_trav_value;
    b[n].is_null = &i.min_trav_null;
    n++;

    // max_trav
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_trav_value;
    b[n].is_null = &i.max_trav_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // toll
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.toll_value;
    b[n].is_null = &i.toll_null;
    n++;

    // rate
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.rate_value;
    b[n].is_null = &i.rate_null;
    n++;

    // min_delay
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_delay_value;
    b[n].is_null = &i.min_delay_null;
    n++;

    // max_delay
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_delay_value;
    b[n].is_null = &i.max_delay_null;
    n++;
  }

  void access::object_traits< ::pio::Lane_Use >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // min_type
    //
    {
      int const& v =
        o.min_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_type_value,
        is_null,
        v);
      i.min_type_null = is_null;
    }

    // max_type
    //
    {
      int const& v =
        o.max_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_type_value,
        is_null,
        v);
      i.max_type_null = is_null;
    }

    // min_trav
    //
    {
      int const& v =
        o.min_trav;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_trav_value,
        is_null,
        v);
      i.min_trav_null = is_null;
    }

    // max_trav
    //
    {
      int const& v =
        o.max_trav;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_trav_value,
        is_null,
        v);
      i.max_trav_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // toll
    //
    {
      int const& v =
        o.toll;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.toll_value,
        is_null,
        v);
      i.toll_null = is_null;
    }

    // rate
    //
    {
      double const& v =
        o.rate;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.rate_value,
        is_null,
        v);
      i.rate_null = is_null;
    }

    // min_delay
    //
    {
      double const& v =
        o.min_delay;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_delay_value,
        is_null,
        v);
      i.min_delay_null = is_null;
    }

    // max_delay
    //
    {
      double const& v =
        o.max_delay;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_delay_value,
        is_null,
        v);
      i.max_delay_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Lane_Use >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // min_type
    //
    {
      int& v =
        o.min_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_type_value,
        i.min_type_null);
    }

    // max_type
    //
    {
      int& v =
        o.max_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_type_value,
        i.max_type_null);
    }

    // min_trav
    //
    {
      int& v =
        o.min_trav;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_trav_value,
        i.min_trav_null);
    }

    // max_trav
    //
    {
      int& v =
        o.max_trav;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_trav_value,
        i.max_trav_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // toll
    //
    {
      int& v =
        o.toll;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.toll_value,
        i.toll_null);
    }

    // rate
    //
    {
      double& v =
        o.rate;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.rate_value,
        i.rate_null);
    }

    // min_delay
    //
    {
      double& v =
        o.min_delay;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_delay_value,
        i.min_delay_null);
    }

    // max_delay
    //
    {
      double& v =
        o.max_delay;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_delay_value,
        i.max_delay_null);
    }
  }

  void access::object_traits< ::pio::Lane_Use >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Lane_Use >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Lane_Use >::persist_statement[] =
  "INSERT INTO \"LANE_USE\" ("
  "\"auto_id\","
  "\"LINK\","
  "\"DIR\","
  "\"LANES\","
  "\"USE\","
  "\"TYPE\","
  "\"MIN_TYPE\","
  "\"MAX_TYPE\","
  "\"MIN_TRAV\","
  "\"MAX_TRAV\","
  "\"START\","
  "\"END\","
  "\"OFFSET\","
  "\"LENGTH\","
  "\"TOLL\","
  "\"RATE\","
  "\"MIN_DELAY\","
  "\"MAX_DELAY\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Lane_Use >::find_statement[] =
  "SELECT "
  "\"LANE_USE\".\"auto_id\","
  "\"LANE_USE\".\"LINK\","
  "\"LANE_USE\".\"DIR\","
  "\"LANE_USE\".\"LANES\","
  "\"LANE_USE\".\"USE\","
  "\"LANE_USE\".\"TYPE\","
  "\"LANE_USE\".\"MIN_TYPE\","
  "\"LANE_USE\".\"MAX_TYPE\","
  "\"LANE_USE\".\"MIN_TRAV\","
  "\"LANE_USE\".\"MAX_TRAV\","
  "\"LANE_USE\".\"START\","
  "\"LANE_USE\".\"END\","
  "\"LANE_USE\".\"OFFSET\","
  "\"LANE_USE\".\"LENGTH\","
  "\"LANE_USE\".\"TOLL\","
  "\"LANE_USE\".\"RATE\","
  "\"LANE_USE\".\"MIN_DELAY\","
  "\"LANE_USE\".\"MAX_DELAY\""
  " FROM \"LANE_USE\""
  " WHERE \"LANE_USE\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Lane_Use >::update_statement[] =
  "UPDATE \"LANE_USE\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"LANES\"=?,"
  "\"USE\"=?,"
  "\"TYPE\"=?,"
  "\"MIN_TYPE\"=?,"
  "\"MAX_TYPE\"=?,"
  "\"MIN_TRAV\"=?,"
  "\"MAX_TRAV\"=?,"
  "\"START\"=?,"
  "\"END\"=?,"
  "\"OFFSET\"=?,"
  "\"LENGTH\"=?,"
  "\"TOLL\"=?,"
  "\"RATE\"=?,"
  "\"MIN_DELAY\"=?,"
  "\"MAX_DELAY\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Lane_Use >::erase_statement[] =
  "DELETE FROM \"LANE_USE\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Lane_Use >::query_statement[] =
  "SELECT "
  "\"LANE_USE\".\"auto_id\","
  "\"LANE_USE\".\"LINK\","
  "\"LANE_USE\".\"DIR\","
  "\"LANE_USE\".\"LANES\","
  "\"LANE_USE\".\"USE\","
  "\"LANE_USE\".\"TYPE\","
  "\"LANE_USE\".\"MIN_TYPE\","
  "\"LANE_USE\".\"MAX_TYPE\","
  "\"LANE_USE\".\"MIN_TRAV\","
  "\"LANE_USE\".\"MAX_TRAV\","
  "\"LANE_USE\".\"START\","
  "\"LANE_USE\".\"END\","
  "\"LANE_USE\".\"OFFSET\","
  "\"LANE_USE\".\"LENGTH\","
  "\"LANE_USE\".\"TOLL\","
  "\"LANE_USE\".\"RATE\","
  "\"LANE_USE\".\"MIN_DELAY\","
  "\"LANE_USE\".\"MAX_DELAY\""
  " FROM \"LANE_USE\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"LANE_USE\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Lane_Use >::erase_query_statement[] =
  "DELETE FROM \"LANE_USE\""
  " ";

  const char access::object_traits< ::pio::Lane_Use >::table_name[] =
  "\"LANE_USE\"";

  void access::object_traits< ::pio::Lane_Use >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Lane_Use >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Lane_Use >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Lane_Use >::pointer_type
  access::object_traits< ::pio::Lane_Use >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Lane_Use >::object_type >
  access::object_traits< ::pio::Lane_Use >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Lane_Use >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Lane_Use >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"LANE_USE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"LANE_USE\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"LANES\" INTEGER NOT NULL,\n"
                      "  \"USE\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"MIN_TYPE\" INTEGER NOT NULL,\n"
                      "  \"MAX_TYPE\" INTEGER NOT NULL,\n"
                      "  \"MIN_TRAV\" INTEGER NOT NULL,\n"
                      "  \"MAX_TRAV\" INTEGER NOT NULL,\n"
                      "  \"START\" REAL,\n"
                      "  \"END\" REAL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  \"LENGTH\" REAL,\n"
                      "  \"TOLL\" INTEGER NOT NULL,\n"
                      "  \"RATE\" REAL,\n"
                      "  \"MIN_DELAY\" REAL,\n"
                      "  \"MAX_DELAY\" REAL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Lane_Use_ (
    "",
    &access::object_traits< ::pio::Lane_Use >::create_schema);

  // Connect
  //

  access::object_traits< ::pio::Connect >::id_type
  access::object_traits< ::pio::Connect >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Connect >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // to_link
    //
    t[3UL] = false;

    // lanes
    //
    if (t[4UL])
    {
      i.lanes_value.capacity (i.lanes_size);
      grew = true;
    }

    // to_lanes
    //
    if (t[5UL])
    {
      i.to_lanes_value.capacity (i.to_lanes_size);
      grew = true;
    }

    // type
    //
    if (t[6UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // penalty
    //
    t[7UL] = false;

    // speed
    //
    t[8UL] = false;

    // capacity
    //
    t[9UL] = false;

    // in_high
    //
    t[10UL] = false;

    // out_high
    //
    t[11UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Connect >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.lanes_value.data ();
    b[n].size = &i.lanes_size;
    b[n].capacity = i.lanes_value.capacity ();
    b[n].is_null = &i.lanes_null;
    n++;

    // to_lanes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.to_lanes_value.data ();
    b[n].size = &i.to_lanes_size;
    b[n].capacity = i.to_lanes_value.capacity ();
    b[n].is_null = &i.to_lanes_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // penalty
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.penalty_value;
    b[n].is_null = &i.penalty_null;
    n++;

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;

    // capacity
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.capacity_value;
    b[n].is_null = &i.capacity_null;
    n++;

    // in_high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.in_high_value;
    b[n].is_null = &i.in_high_null;
    n++;

    // out_high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.out_high_value;
    b[n].is_null = &i.out_high_null;
    n++;
  }

  void access::object_traits< ::pio::Connect >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Connect >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // lanes
    //
    {
      ::std::string const& v =
        o.lanes;

      bool is_null (false);
      std::size_t cap (i.lanes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.lanes_value,
        i.lanes_size,
        is_null,
        v);
      i.lanes_null = is_null;
      grew = grew || (cap != i.lanes_value.capacity ());
    }

    // to_lanes
    //
    {
      ::std::string const& v =
        o.to_lanes;

      bool is_null (false);
      std::size_t cap (i.to_lanes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.to_lanes_value,
        i.to_lanes_size,
        is_null,
        v);
      i.to_lanes_null = is_null;
      grew = grew || (cap != i.to_lanes_value.capacity ());
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // penalty
    //
    {
      int const& v =
        o.penalty;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.penalty_value,
        is_null,
        v);
      i.penalty_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    // capacity
    //
    {
      int const& v =
        o.capacity;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.capacity_value,
        is_null,
        v);
      i.capacity_null = is_null;
    }

    // in_high
    //
    {
      int const& v =
        o.in_high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.in_high_value,
        is_null,
        v);
      i.in_high_null = is_null;
    }

    // out_high
    //
    {
      int const& v =
        o.out_high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.out_high_value,
        is_null,
        v);
      i.out_high_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Connect >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // lanes
    //
    {
      ::std::string& v =
        o.lanes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.lanes_value,
        i.lanes_size,
        i.lanes_null);
    }

    // to_lanes
    //
    {
      ::std::string& v =
        o.to_lanes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.to_lanes_value,
        i.to_lanes_size,
        i.to_lanes_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // penalty
    //
    {
      int& v =
        o.penalty;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.penalty_value,
        i.penalty_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }

    // capacity
    //
    {
      int& v =
        o.capacity;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.capacity_value,
        i.capacity_null);
    }

    // in_high
    //
    {
      int& v =
        o.in_high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.in_high_value,
        i.in_high_null);
    }

    // out_high
    //
    {
      int& v =
        o.out_high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.out_high_value,
        i.out_high_null);
    }
  }

  void access::object_traits< ::pio::Connect >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Connect >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Connect >::persist_statement[] =
  "INSERT INTO \"CONNECT\" ("
  "\"auto_id\","
  "\"LINK\","
  "\"DIR\","
  "\"TO_LINK\","
  "\"LANES\","
  "\"TO_LANES\","
  "\"TYPE\","
  "\"PENALTY\","
  "\"SPEED\","
  "\"CAPACITY\","
  "\"IN_HIGH\","
  "\"OUT_HIGH\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Connect >::find_statement[] =
  "SELECT "
  "\"CONNECT\".\"auto_id\","
  "\"CONNECT\".\"LINK\","
  "\"CONNECT\".\"DIR\","
  "\"CONNECT\".\"TO_LINK\","
  "\"CONNECT\".\"LANES\","
  "\"CONNECT\".\"TO_LANES\","
  "\"CONNECT\".\"TYPE\","
  "\"CONNECT\".\"PENALTY\","
  "\"CONNECT\".\"SPEED\","
  "\"CONNECT\".\"CAPACITY\","
  "\"CONNECT\".\"IN_HIGH\","
  "\"CONNECT\".\"OUT_HIGH\""
  " FROM \"CONNECT\""
  " WHERE \"CONNECT\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Connect >::update_statement[] =
  "UPDATE \"CONNECT\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"TO_LINK\"=?,"
  "\"LANES\"=?,"
  "\"TO_LANES\"=?,"
  "\"TYPE\"=?,"
  "\"PENALTY\"=?,"
  "\"SPEED\"=?,"
  "\"CAPACITY\"=?,"
  "\"IN_HIGH\"=?,"
  "\"OUT_HIGH\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Connect >::erase_statement[] =
  "DELETE FROM \"CONNECT\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Connect >::query_statement[] =
  "SELECT "
  "\"CONNECT\".\"auto_id\","
  "\"CONNECT\".\"LINK\","
  "\"CONNECT\".\"DIR\","
  "\"CONNECT\".\"TO_LINK\","
  "\"CONNECT\".\"LANES\","
  "\"CONNECT\".\"TO_LANES\","
  "\"CONNECT\".\"TYPE\","
  "\"CONNECT\".\"PENALTY\","
  "\"CONNECT\".\"SPEED\","
  "\"CONNECT\".\"CAPACITY\","
  "\"CONNECT\".\"IN_HIGH\","
  "\"CONNECT\".\"OUT_HIGH\""
  " FROM \"CONNECT\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"CONNECT\".\"LINK\""
  " LEFT JOIN \"LINK\" AS \"TO_LINK\" ON \"TO_LINK\".\"LINK\"=\"CONNECT\".\"TO_LINK\""
  " ";

  const char access::object_traits< ::pio::Connect >::erase_query_statement[] =
  "DELETE FROM \"CONNECT\""
  " ";

  const char access::object_traits< ::pio::Connect >::table_name[] =
  "\"CONNECT\"";

  void access::object_traits< ::pio::Connect >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Connect >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Connect >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Connect >::pointer_type
  access::object_traits< ::pio::Connect >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Connect >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Connect >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Connect >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Connect >::object_type >
  access::object_traits< ::pio::Connect >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Connect >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Connect >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"CONNECT\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"CONNECT\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"TO_LINK\" INTEGER,\n"
                      "  \"LANES\" TEXT NOT NULL,\n"
                      "  \"TO_LANES\" TEXT NOT NULL,\n"
                      "  \"TYPE\" TEXT NOT NULL,\n"
                      "  \"PENALTY\" INTEGER NOT NULL,\n"
                      "  \"SPEED\" REAL,\n"
                      "  \"CAPACITY\" INTEGER NOT NULL,\n"
                      "  \"IN_HIGH\" INTEGER NOT NULL,\n"
                      "  \"OUT_HIGH\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"TO_LINK_fk\"\n"
                      "    FOREIGN KEY (\"TO_LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Connect_ (
    "",
    &access::object_traits< ::pio::Connect >::create_schema);

  // Turn_Pen
  //

  access::object_traits< ::pio::Turn_Pen >::id_type
  access::object_traits< ::pio::Turn_Pen >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // to_link
    //
    t[3UL] = false;

    // start
    //
    t[4UL] = false;

    // end
    //
    t[5UL] = false;

    // use
    //
    t[6UL] = false;

    // min_type
    //
    t[7UL] = false;

    // max_type
    //
    t[8UL] = false;

    // penalty
    //
    t[9UL] = false;

    // in_node
    //
    t[10UL] = false;

    // out_node
    //
    t[11UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Turn_Pen >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // min_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_type_value;
    b[n].is_null = &i.min_type_null;
    n++;

    // max_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_type_value;
    b[n].is_null = &i.max_type_null;
    n++;

    // penalty
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.penalty_value;
    b[n].is_null = &i.penalty_null;
    n++;

    // in_node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.in_node_value;
    b[n].is_null = &i.in_node_null;
    n++;

    // out_node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.out_node_value;
    b[n].is_null = &i.out_node_null;
    n++;
  }

  void access::object_traits< ::pio::Turn_Pen >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // min_type
    //
    {
      int const& v =
        o.min_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_type_value,
        is_null,
        v);
      i.min_type_null = is_null;
    }

    // max_type
    //
    {
      int const& v =
        o.max_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_type_value,
        is_null,
        v);
      i.max_type_null = is_null;
    }

    // penalty
    //
    {
      int const& v =
        o.penalty;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.penalty_value,
        is_null,
        v);
      i.penalty_null = is_null;
    }

    // in_node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.in_node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.in_node_value,
          is_null,
          id);
        i.in_node_null = is_null;
      }
      else
        i.in_node_null = true;
    }

    // out_node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.out_node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.out_node_value,
          is_null,
          id);
        i.out_node_null = is_null;
      }
      else
        i.out_node_null = true;
    }

    return grew;
  }

  void access::object_traits< ::pio::Turn_Pen >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // min_type
    //
    {
      int& v =
        o.min_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_type_value,
        i.min_type_null);
    }

    // max_type
    //
    {
      int& v =
        o.max_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_type_value,
        i.max_type_null);
    }

    // penalty
    //
    {
      int& v =
        o.penalty;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.penalty_value,
        i.penalty_null);
    }

    // in_node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.in_node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.in_node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.in_node_value,
          i.in_node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // out_node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.out_node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.out_node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.out_node_value,
          i.out_node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits< ::pio::Turn_Pen >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Turn_Pen >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Turn_Pen >::persist_statement[] =
  "INSERT INTO \"TURN_PEN\" ("
  "\"auto_id\","
  "\"LINK\","
  "\"DIR\","
  "\"TO_LINK\","
  "\"START\","
  "\"END\","
  "\"USE\","
  "\"MIN_TYPE\","
  "\"MAX_TYPE\","
  "\"PENALTY\","
  "\"IN_NODE\","
  "\"OUT_NODE\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Turn_Pen >::find_statement[] =
  "SELECT "
  "\"TURN_PEN\".\"auto_id\","
  "\"TURN_PEN\".\"LINK\","
  "\"TURN_PEN\".\"DIR\","
  "\"TURN_PEN\".\"TO_LINK\","
  "\"TURN_PEN\".\"START\","
  "\"TURN_PEN\".\"END\","
  "\"TURN_PEN\".\"USE\","
  "\"TURN_PEN\".\"MIN_TYPE\","
  "\"TURN_PEN\".\"MAX_TYPE\","
  "\"TURN_PEN\".\"PENALTY\","
  "\"TURN_PEN\".\"IN_NODE\","
  "\"TURN_PEN\".\"OUT_NODE\""
  " FROM \"TURN_PEN\""
  " WHERE \"TURN_PEN\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Turn_Pen >::update_statement[] =
  "UPDATE \"TURN_PEN\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"TO_LINK\"=?,"
  "\"START\"=?,"
  "\"END\"=?,"
  "\"USE\"=?,"
  "\"MIN_TYPE\"=?,"
  "\"MAX_TYPE\"=?,"
  "\"PENALTY\"=?,"
  "\"IN_NODE\"=?,"
  "\"OUT_NODE\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Turn_Pen >::erase_statement[] =
  "DELETE FROM \"TURN_PEN\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Turn_Pen >::query_statement[] =
  "SELECT "
  "\"TURN_PEN\".\"auto_id\","
  "\"TURN_PEN\".\"LINK\","
  "\"TURN_PEN\".\"DIR\","
  "\"TURN_PEN\".\"TO_LINK\","
  "\"TURN_PEN\".\"START\","
  "\"TURN_PEN\".\"END\","
  "\"TURN_PEN\".\"USE\","
  "\"TURN_PEN\".\"MIN_TYPE\","
  "\"TURN_PEN\".\"MAX_TYPE\","
  "\"TURN_PEN\".\"PENALTY\","
  "\"TURN_PEN\".\"IN_NODE\","
  "\"TURN_PEN\".\"OUT_NODE\""
  " FROM \"TURN_PEN\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"TURN_PEN\".\"LINK\""
  " LEFT JOIN \"LINK\" AS \"TO_LINK\" ON \"TO_LINK\".\"LINK\"=\"TURN_PEN\".\"TO_LINK\""
  " LEFT JOIN \"NODE\" AS \"IN_NODE\" ON \"IN_NODE\".\"NODE\"=\"TURN_PEN\".\"IN_NODE\""
  " LEFT JOIN \"NODE\" AS \"OUT_NODE\" ON \"OUT_NODE\".\"NODE\"=\"TURN_PEN\".\"OUT_NODE\""
  " ";

  const char access::object_traits< ::pio::Turn_Pen >::erase_query_statement[] =
  "DELETE FROM \"TURN_PEN\""
  " ";

  const char access::object_traits< ::pio::Turn_Pen >::table_name[] =
  "\"TURN_PEN\"";

  void access::object_traits< ::pio::Turn_Pen >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Turn_Pen >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Turn_Pen >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Turn_Pen >::pointer_type
  access::object_traits< ::pio::Turn_Pen >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Turn_Pen >::object_type >
  access::object_traits< ::pio::Turn_Pen >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Turn_Pen >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"TURN_PEN\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"TURN_PEN\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"TO_LINK\" INTEGER,\n"
                      "  \"START\" REAL,\n"
                      "  \"END\" REAL,\n"
                      "  \"USE\" INTEGER NOT NULL,\n"
                      "  \"MIN_TYPE\" INTEGER NOT NULL,\n"
                      "  \"MAX_TYPE\" INTEGER NOT NULL,\n"
                      "  \"PENALTY\" INTEGER NOT NULL,\n"
                      "  \"IN_NODE\" INTEGER,\n"
                      "  \"OUT_NODE\" INTEGER,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"TO_LINK_fk\"\n"
                      "    FOREIGN KEY (\"TO_LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"IN_NODE_fk\"\n"
                      "    FOREIGN KEY (\"IN_NODE\")\n"
                      "    REFERENCES \"NODE\" (\"NODE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"OUT_NODE_fk\"\n"
                      "    FOREIGN KEY (\"OUT_NODE\")\n"
                      "    REFERENCES \"NODE\" (\"NODE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Turn_Pen_ (
    "",
    &access::object_traits< ::pio::Turn_Pen >::create_schema);

  // Parking
  //

  access::object_traits< ::pio::Parking >::id_type
  access::object_traits< ::pio::Parking >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.parking_value,
        i.parking_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Parking >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // parking
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // type
    //
    t[4UL] = false;

    // use
    //
    t[5UL] = false;

    // start
    //
    t[6UL] = false;

    // end
    //
    t[7UL] = false;

    // space
    //
    t[8UL] = false;

    // time_in
    //
    t[9UL] = false;

    // time_out
    //
    t[10UL] = false;

    // hourly
    //
    t[11UL] = false;

    // daily
    //
    t[12UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Parking >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // parking
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.parking_value;
      b[n].is_null = &i.parking_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // space
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.space_value;
    b[n].is_null = &i.space_null;
    n++;

    // time_in
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_in_value;
    b[n].is_null = &i.time_in_null;
    n++;

    // time_out
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_out_value;
    b[n].is_null = &i.time_out_null;
    n++;

    // hourly
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hourly_value;
    b[n].is_null = &i.hourly_null;
    n++;

    // daily
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.daily_value;
    b[n].is_null = &i.daily_null;
    n++;
  }

  void access::object_traits< ::pio::Parking >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Parking >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // parking
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.parking;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.parking_value,
        is_null,
        v);
      i.parking_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // space
    //
    {
      int const& v =
        o.space;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.space_value,
        is_null,
        v);
      i.space_null = is_null;
    }

    // time_in
    //
    {
      double const& v =
        o.time_in;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_in_value,
        is_null,
        v);
      i.time_in_null = is_null;
    }

    // time_out
    //
    {
      double const& v =
        o.time_out;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_out_value,
        is_null,
        v);
      i.time_out_null = is_null;
    }

    // hourly
    //
    {
      int const& v =
        o.hourly;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hourly_value,
        is_null,
        v);
      i.hourly_null = is_null;
    }

    // daily
    //
    {
      int const& v =
        o.daily;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.daily_value,
        is_null,
        v);
      i.daily_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Parking >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // parking
    //
    {
      int& v =
        o.parking;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.parking_value,
        i.parking_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // space
    //
    {
      int& v =
        o.space;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.space_value,
        i.space_null);
    }

    // time_in
    //
    {
      double& v =
        o.time_in;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_in_value,
        i.time_in_null);
    }

    // time_out
    //
    {
      double& v =
        o.time_out;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_out_value,
        i.time_out_null);
    }

    // hourly
    //
    {
      int& v =
        o.hourly;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hourly_value,
        i.hourly_null);
    }

    // daily
    //
    {
      int& v =
        o.daily;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.daily_value,
        i.daily_null);
    }
  }

  void access::object_traits< ::pio::Parking >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Parking >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Parking >::persist_statement[] =
  "INSERT INTO \"PARKING\" ("
  "\"PARKING\","
  "\"LINK\","
  "\"DIR\","
  "\"OFFSET\","
  "\"TYPE\","
  "\"USE\","
  "\"START\","
  "\"END\","
  "\"SPACE\","
  "\"TIME_IN\","
  "\"TIME_OUT\","
  "\"HOURLY\","
  "\"DAILY\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Parking >::find_statement[] =
  "SELECT "
  "\"PARKING\".\"PARKING\","
  "\"PARKING\".\"LINK\","
  "\"PARKING\".\"DIR\","
  "\"PARKING\".\"OFFSET\","
  "\"PARKING\".\"TYPE\","
  "\"PARKING\".\"USE\","
  "\"PARKING\".\"START\","
  "\"PARKING\".\"END\","
  "\"PARKING\".\"SPACE\","
  "\"PARKING\".\"TIME_IN\","
  "\"PARKING\".\"TIME_OUT\","
  "\"PARKING\".\"HOURLY\","
  "\"PARKING\".\"DAILY\""
  " FROM \"PARKING\""
  " WHERE \"PARKING\".\"PARKING\"=?";

  const char access::object_traits< ::pio::Parking >::update_statement[] =
  "UPDATE \"PARKING\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"OFFSET\"=?,"
  "\"TYPE\"=?,"
  "\"USE\"=?,"
  "\"START\"=?,"
  "\"END\"=?,"
  "\"SPACE\"=?,"
  "\"TIME_IN\"=?,"
  "\"TIME_OUT\"=?,"
  "\"HOURLY\"=?,"
  "\"DAILY\"=?"
  " WHERE \"PARKING\"=?";

  const char access::object_traits< ::pio::Parking >::erase_statement[] =
  "DELETE FROM \"PARKING\""
  " WHERE \"PARKING\"=?";

  const char access::object_traits< ::pio::Parking >::query_statement[] =
  "SELECT "
  "\"PARKING\".\"PARKING\","
  "\"PARKING\".\"LINK\","
  "\"PARKING\".\"DIR\","
  "\"PARKING\".\"OFFSET\","
  "\"PARKING\".\"TYPE\","
  "\"PARKING\".\"USE\","
  "\"PARKING\".\"START\","
  "\"PARKING\".\"END\","
  "\"PARKING\".\"SPACE\","
  "\"PARKING\".\"TIME_IN\","
  "\"PARKING\".\"TIME_OUT\","
  "\"PARKING\".\"HOURLY\","
  "\"PARKING\".\"DAILY\""
  " FROM \"PARKING\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"PARKING\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Parking >::erase_query_statement[] =
  "DELETE FROM \"PARKING\""
  " ";

  const char access::object_traits< ::pio::Parking >::table_name[] =
  "\"PARKING\"";

  void access::object_traits< ::pio::Parking >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Parking >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.parking);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Parking >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Parking >::pointer_type
  access::object_traits< ::pio::Parking >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Parking >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Parking >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.parking);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Parking >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Parking >::object_type >
  access::object_traits< ::pio::Parking >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Parking >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Parking >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"PARKING\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"PARKING\" (\n"
                      "  \"PARKING\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"USE\" INTEGER NOT NULL,\n"
                      "  \"START\" REAL,\n"
                      "  \"END\" REAL,\n"
                      "  \"SPACE\" INTEGER NOT NULL,\n"
                      "  \"TIME_IN\" REAL,\n"
                      "  \"TIME_OUT\" REAL,\n"
                      "  \"HOURLY\" INTEGER NOT NULL,\n"
                      "  \"DAILY\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"PARKING_PARKING_i\"\n"
                      "  ON \"PARKING\" (\"PARKING\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Parking_ (
    "",
    &access::object_traits< ::pio::Parking >::create_schema);

  // Location
  //

  access::object_traits< ::pio::Location >::id_type
  access::object_traits< ::pio::Location >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.location_value,
        i.location_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Location >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // location
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // setback
    //
    t[4UL] = false;

    // zone
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Location >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // location
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.location_value;
      b[n].is_null = &i.location_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // setback
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_value;
    b[n].is_null = &i.setback_null;
    n++;

    // zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.zone_value;
    b[n].is_null = &i.zone_null;
    n++;
  }

  void access::object_traits< ::pio::Location >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Location >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // location
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.location;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.location_value,
        is_null,
        v);
      i.location_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // setback
    //
    {
      double const& v =
        o.setback;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_value,
        is_null,
        v);
      i.setback_null = is_null;
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone > const& v =
        o.zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.zone_value,
          is_null,
          id);
        i.zone_null = is_null;
      }
      else
        i.zone_null = true;
    }

    return grew;
  }

  void access::object_traits< ::pio::Location >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // location
    //
    {
      int& v =
        o.location;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.location_value,
        i.location_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // setback
    //
    {
      double& v =
        o.setback;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_value,
        i.setback_null);
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone >& v =
        o.zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      if (i.zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.zone_value,
          i.zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits< ::pio::Location >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Location >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Location >::persist_statement[] =
  "INSERT INTO \"LOCATION\" ("
  "\"LOCATION\","
  "\"LINK\","
  "\"DIR\","
  "\"OFFSET\","
  "\"SETBACK\","
  "\"ZONE\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Location >::find_statement[] =
  "SELECT "
  "\"LOCATION\".\"LOCATION\","
  "\"LOCATION\".\"LINK\","
  "\"LOCATION\".\"DIR\","
  "\"LOCATION\".\"OFFSET\","
  "\"LOCATION\".\"SETBACK\","
  "\"LOCATION\".\"ZONE\""
  " FROM \"LOCATION\""
  " WHERE \"LOCATION\".\"LOCATION\"=?";

  const char access::object_traits< ::pio::Location >::update_statement[] =
  "UPDATE \"LOCATION\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"OFFSET\"=?,"
  "\"SETBACK\"=?,"
  "\"ZONE\"=?"
  " WHERE \"LOCATION\"=?";

  const char access::object_traits< ::pio::Location >::erase_statement[] =
  "DELETE FROM \"LOCATION\""
  " WHERE \"LOCATION\"=?";

  const char access::object_traits< ::pio::Location >::query_statement[] =
  "SELECT "
  "\"LOCATION\".\"LOCATION\","
  "\"LOCATION\".\"LINK\","
  "\"LOCATION\".\"DIR\","
  "\"LOCATION\".\"OFFSET\","
  "\"LOCATION\".\"SETBACK\","
  "\"LOCATION\".\"ZONE\""
  " FROM \"LOCATION\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"LOCATION\".\"LINK\""
  " LEFT JOIN \"ZONE\" AS \"ZONE\" ON \"ZONE\".\"ZONE\"=\"LOCATION\".\"ZONE\""
  " ";

  const char access::object_traits< ::pio::Location >::erase_query_statement[] =
  "DELETE FROM \"LOCATION\""
  " ";

  const char access::object_traits< ::pio::Location >::table_name[] =
  "\"LOCATION\"";

  void access::object_traits< ::pio::Location >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Location >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.location);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Location >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Location >::pointer_type
  access::object_traits< ::pio::Location >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Location >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Location >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.location);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Location >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Location >::object_type >
  access::object_traits< ::pio::Location >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Location >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Location >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"LOCATION\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"LOCATION\" (\n"
                      "  \"LOCATION\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  \"SETBACK\" REAL,\n"
                      "  \"ZONE\" INTEGER,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"ZONE_fk\"\n"
                      "    FOREIGN KEY (\"ZONE\")\n"
                      "    REFERENCES \"ZONE\" (\"ZONE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"LOCATION_LOCATION_i\"\n"
                      "  ON \"LOCATION\" (\"LOCATION\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Location_ (
    "",
    &access::object_traits< ::pio::Location >::create_schema);

  // Access
  //

  access::object_traits< ::pio::Access >::id_type
  access::object_traits< ::pio::Access >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Access >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // from_id
    //
    t[2UL] = false;

    // from_type
    //
    t[3UL] = false;

    // to_id
    //
    t[4UL] = false;

    // to_type
    //
    t[5UL] = false;

    // dir
    //
    t[6UL] = false;

    // time
    //
    t[7UL] = false;

    // cost
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Access >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // from_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_id_value;
    b[n].is_null = &i.from_id_null;
    n++;

    // from_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_type_value;
    b[n].is_null = &i.from_type_null;
    n++;

    // to_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_id_value;
    b[n].is_null = &i.to_id_null;
    n++;

    // to_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_type_value;
    b[n].is_null = &i.to_type_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // cost
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cost_value;
    b[n].is_null = &i.cost_null;
    n++;
  }

  void access::object_traits< ::pio::Access >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Access >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // from_id
    //
    {
      int const& v =
        o.from_id;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_id_value,
        is_null,
        v);
      i.from_id_null = is_null;
    }

    // from_type
    //
    {
      int const& v =
        o.from_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_type_value,
        is_null,
        v);
      i.from_type_null = is_null;
    }

    // to_id
    //
    {
      int const& v =
        o.to_id;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_id_value,
        is_null,
        v);
      i.to_id_null = is_null;
    }

    // to_type
    //
    {
      int const& v =
        o.to_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_type_value,
        is_null,
        v);
      i.to_type_null = is_null;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // cost
    //
    {
      int const& v =
        o.cost;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cost_value,
        is_null,
        v);
      i.cost_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Access >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // from_id
    //
    {
      int& v =
        o.from_id;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_id_value,
        i.from_id_null);
    }

    // from_type
    //
    {
      int& v =
        o.from_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_type_value,
        i.from_type_null);
    }

    // to_id
    //
    {
      int& v =
        o.to_id;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_id_value,
        i.to_id_null);
    }

    // to_type
    //
    {
      int& v =
        o.to_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_type_value,
        i.to_type_null);
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // cost
    //
    {
      int& v =
        o.cost;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cost_value,
        i.cost_null);
    }
  }

  void access::object_traits< ::pio::Access >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Access >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Access >::persist_statement[] =
  "INSERT INTO \"ACCESS\" ("
  "\"auto_id\","
  "\"LINK\","
  "\"FROM_ID\","
  "\"FROM_TYPE\","
  "\"TO_ID\","
  "\"TO_TYPE\","
  "\"DIR\","
  "\"TIME\","
  "\"COST\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Access >::find_statement[] =
  "SELECT "
  "\"ACCESS\".\"auto_id\","
  "\"ACCESS\".\"LINK\","
  "\"ACCESS\".\"FROM_ID\","
  "\"ACCESS\".\"FROM_TYPE\","
  "\"ACCESS\".\"TO_ID\","
  "\"ACCESS\".\"TO_TYPE\","
  "\"ACCESS\".\"DIR\","
  "\"ACCESS\".\"TIME\","
  "\"ACCESS\".\"COST\""
  " FROM \"ACCESS\""
  " WHERE \"ACCESS\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Access >::update_statement[] =
  "UPDATE \"ACCESS\" SET "
  "\"LINK\"=?,"
  "\"FROM_ID\"=?,"
  "\"FROM_TYPE\"=?,"
  "\"TO_ID\"=?,"
  "\"TO_TYPE\"=?,"
  "\"DIR\"=?,"
  "\"TIME\"=?,"
  "\"COST\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Access >::erase_statement[] =
  "DELETE FROM \"ACCESS\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Access >::query_statement[] =
  "SELECT "
  "\"ACCESS\".\"auto_id\","
  "\"ACCESS\".\"LINK\","
  "\"ACCESS\".\"FROM_ID\","
  "\"ACCESS\".\"FROM_TYPE\","
  "\"ACCESS\".\"TO_ID\","
  "\"ACCESS\".\"TO_TYPE\","
  "\"ACCESS\".\"DIR\","
  "\"ACCESS\".\"TIME\","
  "\"ACCESS\".\"COST\""
  " FROM \"ACCESS\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"ACCESS\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Access >::erase_query_statement[] =
  "DELETE FROM \"ACCESS\""
  " ";

  const char access::object_traits< ::pio::Access >::table_name[] =
  "\"ACCESS\"";

  void access::object_traits< ::pio::Access >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Access >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Access >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Access >::pointer_type
  access::object_traits< ::pio::Access >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Access >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Access >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Access >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Access >::object_type >
  access::object_traits< ::pio::Access >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Access >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Access >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"ACCESS\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"ACCESS\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"FROM_ID\" INTEGER NOT NULL,\n"
                      "  \"FROM_TYPE\" INTEGER NOT NULL,\n"
                      "  \"TO_ID\" INTEGER NOT NULL,\n"
                      "  \"TO_TYPE\" INTEGER NOT NULL,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"TIME\" REAL,\n"
                      "  \"COST\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Access_ (
    "",
    &access::object_traits< ::pio::Access >::create_schema);

  // Sign
  //

  access::object_traits< ::pio::Sign >::id_type
  access::object_traits< ::pio::Sign >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Sign >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // sign
    //
    if (t[3UL])
    {
      i.sign_value.capacity (i.sign_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits< ::pio::Sign >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // sign
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.sign_value.data ();
    b[n].size = &i.sign_size;
    b[n].capacity = i.sign_value.capacity ();
    b[n].is_null = &i.sign_null;
    n++;
  }

  void access::object_traits< ::pio::Sign >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Sign >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // sign
    //
    {
      ::std::string const& v =
        o.sign;

      bool is_null (false);
      std::size_t cap (i.sign_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.sign_value,
        i.sign_size,
        is_null,
        v);
      i.sign_null = is_null;
      grew = grew || (cap != i.sign_value.capacity ());
    }

    return grew;
  }

  void access::object_traits< ::pio::Sign >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // sign
    //
    {
      ::std::string& v =
        o.sign;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.sign_value,
        i.sign_size,
        i.sign_null);
    }
  }

  void access::object_traits< ::pio::Sign >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Sign >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Sign >::persist_statement[] =
  "INSERT INTO \"SIGN\" ("
  "\"auto_id\","
  "\"LINK\","
  "\"DIR\","
  "\"SIGN\")"
  " VALUES (?,?,?,?)";

  const char access::object_traits< ::pio::Sign >::find_statement[] =
  "SELECT "
  "\"SIGN\".\"auto_id\","
  "\"SIGN\".\"LINK\","
  "\"SIGN\".\"DIR\","
  "\"SIGN\".\"SIGN\""
  " FROM \"SIGN\""
  " WHERE \"SIGN\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Sign >::update_statement[] =
  "UPDATE \"SIGN\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"SIGN\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Sign >::erase_statement[] =
  "DELETE FROM \"SIGN\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Sign >::query_statement[] =
  "SELECT "
  "\"SIGN\".\"auto_id\","
  "\"SIGN\".\"LINK\","
  "\"SIGN\".\"DIR\","
  "\"SIGN\".\"SIGN\""
  " FROM \"SIGN\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"SIGN\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Sign >::erase_query_statement[] =
  "DELETE FROM \"SIGN\""
  " ";

  const char access::object_traits< ::pio::Sign >::table_name[] =
  "\"SIGN\"";

  void access::object_traits< ::pio::Sign >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Sign >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Sign >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Sign >::pointer_type
  access::object_traits< ::pio::Sign >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Sign >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Sign >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Sign >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Sign >::object_type >
  access::object_traits< ::pio::Sign >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Sign >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Sign >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"SIGN\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"SIGN\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"SIGN\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Sign_ (
    "",
    &access::object_traits< ::pio::Sign >::create_schema);

  // Signal
  //

  // nested_records
  //

  const char access::object_traits< ::pio::Signal >::nested_records_traits::
  select_all_statement[] =
  "SELECT "
  "\"SIGNAL_nested_records\".\"index\","
  "\"SIGNAL_nested_records\".\"value_start\","
  "\"SIGNAL_nested_records\".\"value_end\","
  "\"SIGNAL_nested_records\".\"value_timing\","
  "\"SIGNAL_nested_records\".\"value_phasing\","
  "\"SIGNAL_nested_records\".\"value_notes\""
  " FROM \"SIGNAL_nested_records\""
  " WHERE \"SIGNAL_nested_records\".\"object_id\"=?"
  " ORDER BY \"SIGNAL_nested_records\".\"index\"";

  const char access::object_traits< ::pio::Signal >::nested_records_traits::
  insert_one_statement[] =
  "INSERT INTO \"SIGNAL_nested_records\" ("
  "\"object_id\","
  "\"index\","
  "\"value_start\","
  "\"value_end\","
  "\"value_timing\","
  "\"value_phasing\","
  "\"value_notes\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Signal >::nested_records_traits::
  delete_all_statement[] =
  "DELETE FROM \"SIGNAL_nested_records\""
  " WHERE \"object_id\"=?";

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        cond_image_type& c)
  {
    ODB_POTENTIALLY_UNUSED (c);

    std::size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type >::bind (b + n, d.value_value, sk);
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  grow (data_image_type& i, bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    if (composite_value_traits< value_type >::grow (
          i.value_value, t + 1UL))
    {
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  init (data_image_type& i, index_type j, const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  init (index_type& j, value_type& v, const data_image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  insert_one (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    binding& b (sts.data_image_binding ());
    data_image_type& di (sts.data_image ());

    init (di, i, v);

    if (di.version != sts.data_image_version ())
    {
      bind (b.bind, 0, sts.id_binding ().count, di);
      sts.data_image_version (di.version);
      b.version++;
      sts.select_image_binding ().version++;
    }

    if (!sts.insert_one_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits< ::pio::Signal >::nested_records_traits::
  load_all (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());
    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_all_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (di.version != sts.data_image_version ())
      {
        binding& b (sts.data_image_binding ());
        bind (b.bind, 0, sts.id_binding ().count, di);
        sts.data_image_version (di.version);
        b.version++;
        sts.select_image_binding ().version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  delete_all (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_all_statement ().execute ();
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  persist (const container_type& c,
           const sqlite::binding& id,
           statements_type& sts)
  {
    using namespace sqlite;

    binding& b (sts.data_image_binding ());
    if (id.version != sts.data_id_binding_version () || b.version == 0)
    {
      bind (b.bind, id.bind, id.count, sts.data_image ());
      sts.data_id_binding_version (id.version);
      b.version++;
      sts.select_image_binding ().version++;
    }

    sts.id_binding (id);
    functions_type& fs (sts.functions ());
    fs.ordered (true);
    container_traits_type::persist (c, fs);
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  load (container_type& c,
        const sqlite::binding& id,
        statements_type& sts)
  {
    using namespace sqlite;

    binding& db (sts.data_image_binding ());
    if (id.version != sts.data_id_binding_version () || db.version == 0)
    {
      bind (db.bind, id.bind, id.count, sts.data_image ());
      sts.data_id_binding_version (id.version);
      db.version++;
      sts.select_image_binding ().version++;
    }

    binding& cb (sts.cond_image_binding ());
    if (id.version != sts.cond_id_binding_version () || cb.version == 0)
    {
      bind (cb.bind, id.bind, id.count, sts.cond_image ());
      sts.cond_id_binding_version (id.version);
      cb.version++;
    }

    select_statement& st (sts.select_all_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (di.version != sts.data_image_version ())
      {
        bind (db.bind, 0, id.count, sts.data_image ());
        sts.data_image_version (di.version);
        db.version++;
        sts.select_image_binding ().version++;
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    sts.id_binding (id);
    functions_type& fs (sts.functions ());
    fs.ordered (true);
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  update (const container_type& c,
          const sqlite::binding& id,
          statements_type& sts)
  {
    using namespace sqlite;

    binding& db (sts.data_image_binding ());
    if (id.version != sts.data_id_binding_version () || db.version == 0)
    {
      bind (db.bind, id.bind, id.count, sts.data_image ());
      sts.data_id_binding_version (id.version);
      db.version++;
      sts.select_image_binding ().version++;
    }

    binding& cb (sts.cond_image_binding ());
    if (id.version != sts.cond_id_binding_version () || cb.version == 0)
    {
      bind (cb.bind, id.bind, id.count, sts.cond_image ());
      sts.cond_id_binding_version (id.version);
      cb.version++;
    }

    sts.id_binding (id);
    functions_type& fs (sts.functions ());
    fs.ordered (true);
    container_traits_type::update (c, fs);
  }

  void access::object_traits< ::pio::Signal >::nested_records_traits::
  erase (const sqlite::binding& id, statements_type& sts)
  {
    using namespace sqlite;

    binding& b (sts.cond_image_binding ());
    if (id.version != sts.cond_id_binding_version () || b.version == 0)
    {
      bind (b.bind, id.bind, id.count, sts.cond_image ());
      sts.cond_id_binding_version (id.version);
      b.version++;
    }

    sts.id_binding (id);
    functions_type& fs (sts.functions ());
    fs.ordered (true);
    container_traits_type::erase (fs);
  }

  access::object_traits< ::pio::Signal >::id_type
  access::object_traits< ::pio::Signal >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.signal_value,
        i.signal_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Signal >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // signal
    //
    t[0UL] = false;

    // group
    //
    t[1UL] = false;

    // times
    //
    t[2UL] = false;

    // type
    //
    if (t[3UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // offset
    //
    t[4UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Signal >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // signal
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.signal_value;
      b[n].is_null = &i.signal_null;
      n++;
    }

    // group
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.group_value;
    b[n].is_null = &i.group_null;
    n++;

    // times
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.times_value;
    b[n].is_null = &i.times_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;
  }

  void access::object_traits< ::pio::Signal >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Signal >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // signal
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.signal;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.signal_value,
        is_null,
        v);
      i.signal_null = is_null;
    }

    // group
    //
    {
      int const& v =
        o.group;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.group_value,
        is_null,
        v);
      i.group_null = is_null;
    }

    // times
    //
    {
      int const& v =
        o.times;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.times_value,
        is_null,
        v);
      i.times_null = is_null;
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // offset
    //
    {
      int const& v =
        o.offset;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Signal >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // signal
    //
    {
      int& v =
        o.signal;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.signal_value,
        i.signal_null);
    }

    // group
    //
    {
      int& v =
        o.group;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.group_value,
        i.group_null);
    }

    // times
    //
    {
      int& v =
        o.times;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.times_value,
        i.times_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // offset
    //
    {
      int& v =
        o.offset;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }
  }

  void access::object_traits< ::pio::Signal >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Signal >::container_statement_cache_type
  {
    sqlite::container_statements_impl< nested_records_traits > nested_records;

    container_statement_cache_type (sqlite::connection& c)
    : nested_records (c)
    {
    }
  };

  const char access::object_traits< ::pio::Signal >::persist_statement[] =
  "INSERT INTO \"SIGNAL\" ("
  "\"SIGNAL\","
  "\"GROUP\","
  "\"TIMES\","
  "\"TYPE\","
  "\"OFFSET\")"
  " VALUES (?,?,?,?,?)";

  const char access::object_traits< ::pio::Signal >::find_statement[] =
  "SELECT "
  "\"SIGNAL\".\"SIGNAL\","
  "\"SIGNAL\".\"GROUP\","
  "\"SIGNAL\".\"TIMES\","
  "\"SIGNAL\".\"TYPE\","
  "\"SIGNAL\".\"OFFSET\""
  " FROM \"SIGNAL\""
  " WHERE \"SIGNAL\".\"SIGNAL\"=?";

  const char access::object_traits< ::pio::Signal >::update_statement[] =
  "UPDATE \"SIGNAL\" SET "
  "\"GROUP\"=?,"
  "\"TIMES\"=?,"
  "\"TYPE\"=?,"
  "\"OFFSET\"=?"
  " WHERE \"SIGNAL\"=?";

  const char access::object_traits< ::pio::Signal >::erase_statement[] =
  "DELETE FROM \"SIGNAL\""
  " WHERE \"SIGNAL\"=?";

  const char access::object_traits< ::pio::Signal >::query_statement[] =
  "SELECT "
  "\"SIGNAL\".\"SIGNAL\","
  "\"SIGNAL\".\"GROUP\","
  "\"SIGNAL\".\"TIMES\","
  "\"SIGNAL\".\"TYPE\","
  "\"SIGNAL\".\"OFFSET\""
  " FROM \"SIGNAL\""
  " ";

  const char access::object_traits< ::pio::Signal >::erase_query_statement[] =
  "DELETE FROM \"SIGNAL\""
  " ";

  const char access::object_traits< ::pio::Signal >::table_name[] =
  "\"SIGNAL\"";

  void access::object_traits< ::pio::Signal >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    id_image_type& i (sts.id_image ());
    init (i, obj.signal);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    {
      ::std::vector< ::pio::signal_time > const& v =
        obj.nested_records;

      nested_records_traits::persist (
        v,
        idb,
        sts.container_statment_cache ().nested_records);
    }

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Signal >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.signal);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    // nested_records
    //
    {
      ::std::vector< ::pio::signal_time > const& v =
        obj.nested_records;

      nested_records_traits::update (
        v,
        idb,
        sts.container_statment_cache ().nested_records);
    }

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Signal >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    nested_records_traits::erase (
      idb,
      sts.container_statment_cache ().nested_records);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Signal >::pointer_type
  access::object_traits< ::pio::Signal >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Signal >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Signal >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.signal);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Signal >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits< ::pio::Signal >::
  load_ (statements_type& sts, object_type& obj)
  {
    sqlite::binding& idb (sts.id_image_binding ());

    // nested_records
    //
    {
      ::std::vector< ::pio::signal_time >& v =
        obj.nested_records;

      nested_records_traits::load (
        v,
        idb,
        sts.container_statment_cache ().nested_records);
    }
  }

  result< access::object_traits< ::pio::Signal >::object_type >
  access::object_traits< ::pio::Signal >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Signal >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Signal >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"SIGNAL_nested_records\"");
          db.execute ("DROP TABLE IF EXISTS \"SIGNAL\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"SIGNAL\" (\n"
                      "  \"SIGNAL\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"GROUP\" INTEGER NOT NULL,\n"
                      "  \"TIMES\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" TEXT NOT NULL,\n"
                      "  \"OFFSET\" INTEGER NOT NULL)");
          db.execute ("CREATE INDEX \"SIGNAL_SIGNAL_i\"\n"
                      "  ON \"SIGNAL\" (\"SIGNAL\")");
          db.execute ("CREATE TABLE \"SIGNAL_nested_records\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value_start\" REAL,\n"
                      "  \"value_end\" REAL,\n"
                      "  \"value_timing\" INTEGER NOT NULL,\n"
                      "  \"value_phasing\" INTEGER NOT NULL,\n"
                      "  \"value_notes\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"SIGNAL\" (\"SIGNAL\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"SIGNAL_nested_records_object_id_i\"\n"
                      "  ON \"SIGNAL_nested_records\" (\"object_id\")");
          db.execute ("CREATE INDEX \"SIGNAL_nested_records_index_i\"\n"
                      "  ON \"SIGNAL_nested_records\" (\"index\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Signal_ (
    "",
    &access::object_traits< ::pio::Signal >::create_schema);

  // Timing
  //

  access::object_traits< ::pio::Timing >::id_type
  access::object_traits< ::pio::Timing >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Timing >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // signal
    //
    t[1UL] = false;

    // timing
    //
    t[2UL] = false;

    // type
    //
    t[3UL] = false;

    // cycle
    //
    t[4UL] = false;

    // offset
    //
    t[5UL] = false;

    // phases
    //
    t[6UL] = false;

    // phase
    //
    t[7UL] = false;

    // barrier
    //
    t[8UL] = false;

    // ring
    //
    t[9UL] = false;

    // position
    //
    t[10UL] = false;

    // minimum
    //
    t[11UL] = false;

    // maximum
    //
    t[12UL] = false;

    // extend
    //
    t[13UL] = false;

    // yellow
    //
    t[14UL] = false;

    // red
    //
    t[15UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Timing >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // signal
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signal_value;
    b[n].is_null = &i.signal_null;
    n++;

    // timing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timing_value;
    b[n].is_null = &i.timing_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // cycle
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cycle_value;
    b[n].is_null = &i.cycle_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // phases
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phases_value;
    b[n].is_null = &i.phases_null;
    n++;

    // phase
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phase_value;
    b[n].is_null = &i.phase_null;
    n++;

    // barrier
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.barrier_value;
    b[n].is_null = &i.barrier_null;
    n++;

    // ring
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.ring_value;
    b[n].is_null = &i.ring_null;
    n++;

    // position
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.position_value;
    b[n].is_null = &i.position_null;
    n++;

    // minimum
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.minimum_value;
    b[n].is_null = &i.minimum_null;
    n++;

    // maximum
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.maximum_value;
    b[n].is_null = &i.maximum_null;
    n++;

    // extend
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.extend_value;
    b[n].is_null = &i.extend_null;
    n++;

    // yellow
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.yellow_value;
    b[n].is_null = &i.yellow_null;
    n++;

    // red
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.red_value;
    b[n].is_null = &i.red_null;
    n++;
  }

  void access::object_traits< ::pio::Timing >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Timing >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::pio::Signal > const& v =
        o.signal;

      typedef object_traits< ::pio::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Signal > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.signal_value,
          is_null,
          id);
        i.signal_null = is_null;
      }
      else
        i.signal_null = true;
    }

    // timing
    //
    {
      int const& v =
        o.timing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.timing_value,
        is_null,
        v);
      i.timing_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // cycle
    //
    {
      int const& v =
        o.cycle;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cycle_value,
        is_null,
        v);
      i.cycle_null = is_null;
    }

    // offset
    //
    {
      int const& v =
        o.offset;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // phases
    //
    {
      int const& v =
        o.phases;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phases_value,
        is_null,
        v);
      i.phases_null = is_null;
    }

    // phase
    //
    {
      int const& v =
        o.phase;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phase_value,
        is_null,
        v);
      i.phase_null = is_null;
    }

    // barrier
    //
    {
      int const& v =
        o.barrier;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.barrier_value,
        is_null,
        v);
      i.barrier_null = is_null;
    }

    // ring
    //
    {
      int const& v =
        o.ring;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.ring_value,
        is_null,
        v);
      i.ring_null = is_null;
    }

    // position
    //
    {
      int const& v =
        o.position;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.position_value,
        is_null,
        v);
      i.position_null = is_null;
    }

    // minimum
    //
    {
      int const& v =
        o.minimum;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.minimum_value,
        is_null,
        v);
      i.minimum_null = is_null;
    }

    // maximum
    //
    {
      int const& v =
        o.maximum;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.maximum_value,
        is_null,
        v);
      i.maximum_null = is_null;
    }

    // extend
    //
    {
      int const& v =
        o.extend;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.extend_value,
        is_null,
        v);
      i.extend_null = is_null;
    }

    // yellow
    //
    {
      int const& v =
        o.yellow;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.yellow_value,
        is_null,
        v);
      i.yellow_null = is_null;
    }

    // red
    //
    {
      int const& v =
        o.red;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.red_value,
        is_null,
        v);
      i.red_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Timing >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::pio::Signal >& v =
        o.signal;

      typedef object_traits< ::pio::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Signal > > ptr_traits;

      if (i.signal_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.signal_value,
          i.signal_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // timing
    //
    {
      int& v =
        o.timing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.timing_value,
        i.timing_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // cycle
    //
    {
      int& v =
        o.cycle;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cycle_value,
        i.cycle_null);
    }

    // offset
    //
    {
      int& v =
        o.offset;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // phases
    //
    {
      int& v =
        o.phases;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phases_value,
        i.phases_null);
    }

    // phase
    //
    {
      int& v =
        o.phase;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phase_value,
        i.phase_null);
    }

    // barrier
    //
    {
      int& v =
        o.barrier;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.barrier_value,
        i.barrier_null);
    }

    // ring
    //
    {
      int& v =
        o.ring;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.ring_value,
        i.ring_null);
    }

    // position
    //
    {
      int& v =
        o.position;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.position_value,
        i.position_null);
    }

    // minimum
    //
    {
      int& v =
        o.minimum;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.minimum_value,
        i.minimum_null);
    }

    // maximum
    //
    {
      int& v =
        o.maximum;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.maximum_value,
        i.maximum_null);
    }

    // extend
    //
    {
      int& v =
        o.extend;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.extend_value,
        i.extend_null);
    }

    // yellow
    //
    {
      int& v =
        o.yellow;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.yellow_value,
        i.yellow_null);
    }

    // red
    //
    {
      int& v =
        o.red;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.red_value,
        i.red_null);
    }
  }

  void access::object_traits< ::pio::Timing >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Timing >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Timing >::persist_statement[] =
  "INSERT INTO \"TIMING\" ("
  "\"auto_id\","
  "\"SIGNAL\","
  "\"TIMING\","
  "\"TYPE\","
  "\"CYCLE\","
  "\"OFFSET\","
  "\"PHASES\","
  "\"PHASE\","
  "\"BARRIER\","
  "\"RING\","
  "\"POSITION\","
  "\"MINIMUM\","
  "\"MAXIMUM\","
  "\"EXTEND\","
  "\"YELLOW\","
  "\"RED\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Timing >::find_statement[] =
  "SELECT "
  "\"TIMING\".\"auto_id\","
  "\"TIMING\".\"SIGNAL\","
  "\"TIMING\".\"TIMING\","
  "\"TIMING\".\"TYPE\","
  "\"TIMING\".\"CYCLE\","
  "\"TIMING\".\"OFFSET\","
  "\"TIMING\".\"PHASES\","
  "\"TIMING\".\"PHASE\","
  "\"TIMING\".\"BARRIER\","
  "\"TIMING\".\"RING\","
  "\"TIMING\".\"POSITION\","
  "\"TIMING\".\"MINIMUM\","
  "\"TIMING\".\"MAXIMUM\","
  "\"TIMING\".\"EXTEND\","
  "\"TIMING\".\"YELLOW\","
  "\"TIMING\".\"RED\""
  " FROM \"TIMING\""
  " WHERE \"TIMING\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Timing >::update_statement[] =
  "UPDATE \"TIMING\" SET "
  "\"SIGNAL\"=?,"
  "\"TIMING\"=?,"
  "\"TYPE\"=?,"
  "\"CYCLE\"=?,"
  "\"OFFSET\"=?,"
  "\"PHASES\"=?,"
  "\"PHASE\"=?,"
  "\"BARRIER\"=?,"
  "\"RING\"=?,"
  "\"POSITION\"=?,"
  "\"MINIMUM\"=?,"
  "\"MAXIMUM\"=?,"
  "\"EXTEND\"=?,"
  "\"YELLOW\"=?,"
  "\"RED\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Timing >::erase_statement[] =
  "DELETE FROM \"TIMING\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Timing >::query_statement[] =
  "SELECT "
  "\"TIMING\".\"auto_id\","
  "\"TIMING\".\"SIGNAL\","
  "\"TIMING\".\"TIMING\","
  "\"TIMING\".\"TYPE\","
  "\"TIMING\".\"CYCLE\","
  "\"TIMING\".\"OFFSET\","
  "\"TIMING\".\"PHASES\","
  "\"TIMING\".\"PHASE\","
  "\"TIMING\".\"BARRIER\","
  "\"TIMING\".\"RING\","
  "\"TIMING\".\"POSITION\","
  "\"TIMING\".\"MINIMUM\","
  "\"TIMING\".\"MAXIMUM\","
  "\"TIMING\".\"EXTEND\","
  "\"TIMING\".\"YELLOW\","
  "\"TIMING\".\"RED\""
  " FROM \"TIMING\""
  " LEFT JOIN \"SIGNAL\" AS \"SIGNAL\" ON \"SIGNAL\".\"SIGNAL\"=\"TIMING\".\"SIGNAL\""
  " ";

  const char access::object_traits< ::pio::Timing >::erase_query_statement[] =
  "DELETE FROM \"TIMING\""
  " ";

  const char access::object_traits< ::pio::Timing >::table_name[] =
  "\"TIMING\"";

  void access::object_traits< ::pio::Timing >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Timing >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Timing >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Timing >::pointer_type
  access::object_traits< ::pio::Timing >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Timing >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Timing >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Timing >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Timing >::object_type >
  access::object_traits< ::pio::Timing >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Timing >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Timing >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"TIMING\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"TIMING\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"SIGNAL\" INTEGER,\n"
                      "  \"TIMING\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"CYCLE\" INTEGER NOT NULL,\n"
                      "  \"OFFSET\" INTEGER NOT NULL,\n"
                      "  \"PHASES\" INTEGER NOT NULL,\n"
                      "  \"PHASE\" INTEGER NOT NULL,\n"
                      "  \"BARRIER\" INTEGER NOT NULL,\n"
                      "  \"RING\" INTEGER NOT NULL,\n"
                      "  \"POSITION\" INTEGER NOT NULL,\n"
                      "  \"MINIMUM\" INTEGER NOT NULL,\n"
                      "  \"MAXIMUM\" INTEGER NOT NULL,\n"
                      "  \"EXTEND\" INTEGER NOT NULL,\n"
                      "  \"YELLOW\" INTEGER NOT NULL,\n"
                      "  \"RED\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"SIGNAL_fk\"\n"
                      "    FOREIGN KEY (\"SIGNAL\")\n"
                      "    REFERENCES \"SIGNAL\" (\"SIGNAL\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Timing_ (
    "",
    &access::object_traits< ::pio::Timing >::create_schema);

  // Phasing
  //

  access::object_traits< ::pio::Phasing >::id_type
  access::object_traits< ::pio::Phasing >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Phasing >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // signal
    //
    t[1UL] = false;

    // phasing
    //
    t[2UL] = false;

    // phase
    //
    t[3UL] = false;

    // detectors
    //
    if (t[4UL])
    {
      i.detectors_value.capacity (i.detectors_size);
      grew = true;
    }

    // movements
    //
    t[5UL] = false;

    // movement
    //
    if (t[6UL])
    {
      i.movement_value.capacity (i.movement_size);
      grew = true;
    }

    // link
    //
    t[7UL] = false;

    // dir
    //
    t[8UL] = false;

    // to_link
    //
    t[9UL] = false;

    // protect
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Phasing >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // signal
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signal_value;
    b[n].is_null = &i.signal_null;
    n++;

    // phasing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phasing_value;
    b[n].is_null = &i.phasing_null;
    n++;

    // phase
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phase_value;
    b[n].is_null = &i.phase_null;
    n++;

    // detectors
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.detectors_value.data ();
    b[n].size = &i.detectors_size;
    b[n].capacity = i.detectors_value.capacity ();
    b[n].is_null = &i.detectors_null;
    n++;

    // movements
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.movements_value;
    b[n].is_null = &i.movements_null;
    n++;

    // movement
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.movement_value.data ();
    b[n].size = &i.movement_size;
    b[n].capacity = i.movement_value.capacity ();
    b[n].is_null = &i.movement_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // protect
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.protect_value;
    b[n].is_null = &i.protect_null;
    n++;
  }

  void access::object_traits< ::pio::Phasing >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Phasing >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::pio::Signal > const& v =
        o.signal;

      typedef object_traits< ::pio::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Signal > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.signal_value,
          is_null,
          id);
        i.signal_null = is_null;
      }
      else
        i.signal_null = true;
    }

    // phasing
    //
    {
      int const& v =
        o.phasing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phasing_value,
        is_null,
        v);
      i.phasing_null = is_null;
    }

    // phase
    //
    {
      int const& v =
        o.phase;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phase_value,
        is_null,
        v);
      i.phase_null = is_null;
    }

    // detectors
    //
    {
      ::std::string const& v =
        o.detectors;

      bool is_null (false);
      std::size_t cap (i.detectors_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.detectors_value,
        i.detectors_size,
        is_null,
        v);
      i.detectors_null = is_null;
      grew = grew || (cap != i.detectors_value.capacity ());
    }

    // movements
    //
    {
      int const& v =
        o.movements;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.movements_value,
        is_null,
        v);
      i.movements_null = is_null;
    }

    // movement
    //
    {
      ::std::string const& v =
        o.movement;

      bool is_null (false);
      std::size_t cap (i.movement_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.movement_value,
        i.movement_size,
        is_null,
        v);
      i.movement_null = is_null;
      grew = grew || (cap != i.movement_value.capacity ());
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // protect
    //
    {
      int const& v =
        o.protect;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.protect_value,
        is_null,
        v);
      i.protect_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Phasing >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::pio::Signal >& v =
        o.signal;

      typedef object_traits< ::pio::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Signal > > ptr_traits;

      if (i.signal_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.signal_value,
          i.signal_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // phasing
    //
    {
      int& v =
        o.phasing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phasing_value,
        i.phasing_null);
    }

    // phase
    //
    {
      int& v =
        o.phase;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phase_value,
        i.phase_null);
    }

    // detectors
    //
    {
      ::std::string& v =
        o.detectors;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.detectors_value,
        i.detectors_size,
        i.detectors_null);
    }

    // movements
    //
    {
      int& v =
        o.movements;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.movements_value,
        i.movements_null);
    }

    // movement
    //
    {
      ::std::string& v =
        o.movement;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.movement_value,
        i.movement_size,
        i.movement_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // protect
    //
    {
      int& v =
        o.protect;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.protect_value,
        i.protect_null);
    }
  }

  void access::object_traits< ::pio::Phasing >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Phasing >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Phasing >::persist_statement[] =
  "INSERT INTO \"PHASING\" ("
  "\"auto_id\","
  "\"SIGNAL\","
  "\"PHASING\","
  "\"PHASE\","
  "\"DETECTORS\","
  "\"MOVEMENTS\","
  "\"MOVEMENT\","
  "\"LINK\","
  "\"DIR\","
  "\"TO_LINK\","
  "\"PROTECT\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Phasing >::find_statement[] =
  "SELECT "
  "\"PHASING\".\"auto_id\","
  "\"PHASING\".\"SIGNAL\","
  "\"PHASING\".\"PHASING\","
  "\"PHASING\".\"PHASE\","
  "\"PHASING\".\"DETECTORS\","
  "\"PHASING\".\"MOVEMENTS\","
  "\"PHASING\".\"MOVEMENT\","
  "\"PHASING\".\"LINK\","
  "\"PHASING\".\"DIR\","
  "\"PHASING\".\"TO_LINK\","
  "\"PHASING\".\"PROTECT\""
  " FROM \"PHASING\""
  " WHERE \"PHASING\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Phasing >::update_statement[] =
  "UPDATE \"PHASING\" SET "
  "\"SIGNAL\"=?,"
  "\"PHASING\"=?,"
  "\"PHASE\"=?,"
  "\"DETECTORS\"=?,"
  "\"MOVEMENTS\"=?,"
  "\"MOVEMENT\"=?,"
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"TO_LINK\"=?,"
  "\"PROTECT\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Phasing >::erase_statement[] =
  "DELETE FROM \"PHASING\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Phasing >::query_statement[] =
  "SELECT "
  "\"PHASING\".\"auto_id\","
  "\"PHASING\".\"SIGNAL\","
  "\"PHASING\".\"PHASING\","
  "\"PHASING\".\"PHASE\","
  "\"PHASING\".\"DETECTORS\","
  "\"PHASING\".\"MOVEMENTS\","
  "\"PHASING\".\"MOVEMENT\","
  "\"PHASING\".\"LINK\","
  "\"PHASING\".\"DIR\","
  "\"PHASING\".\"TO_LINK\","
  "\"PHASING\".\"PROTECT\""
  " FROM \"PHASING\""
  " LEFT JOIN \"SIGNAL\" AS \"SIGNAL\" ON \"SIGNAL\".\"SIGNAL\"=\"PHASING\".\"SIGNAL\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"PHASING\".\"LINK\""
  " LEFT JOIN \"LINK\" AS \"TO_LINK\" ON \"TO_LINK\".\"LINK\"=\"PHASING\".\"TO_LINK\""
  " ";

  const char access::object_traits< ::pio::Phasing >::erase_query_statement[] =
  "DELETE FROM \"PHASING\""
  " ";

  const char access::object_traits< ::pio::Phasing >::table_name[] =
  "\"PHASING\"";

  void access::object_traits< ::pio::Phasing >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Phasing >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Phasing >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Phasing >::pointer_type
  access::object_traits< ::pio::Phasing >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Phasing >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Phasing >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Phasing >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Phasing >::object_type >
  access::object_traits< ::pio::Phasing >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Phasing >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Phasing >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"PHASING\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"PHASING\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"SIGNAL\" INTEGER,\n"
                      "  \"PHASING\" INTEGER NOT NULL,\n"
                      "  \"PHASE\" INTEGER NOT NULL,\n"
                      "  \"DETECTORS\" TEXT NOT NULL,\n"
                      "  \"MOVEMENTS\" INTEGER NOT NULL,\n"
                      "  \"MOVEMENT\" TEXT NOT NULL,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"TO_LINK\" INTEGER,\n"
                      "  \"PROTECT\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"SIGNAL_fk\"\n"
                      "    FOREIGN KEY (\"SIGNAL\")\n"
                      "    REFERENCES \"SIGNAL\" (\"SIGNAL\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"TO_LINK_fk\"\n"
                      "    FOREIGN KEY (\"TO_LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Phasing_ (
    "",
    &access::object_traits< ::pio::Phasing >::create_schema);

  // Detector
  //

  access::object_traits< ::pio::Detector >::id_type
  access::object_traits< ::pio::Detector >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.detector_value,
        i.detector_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Detector >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // detector
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // length
    //
    t[4UL] = false;

    // lanes
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // use
    //
    t[7UL] = false;

    // low
    //
    t[8UL] = false;

    // high
    //
    t[9UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Detector >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // detector
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.detector_value;
      b[n].is_null = &i.detector_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // low
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.low_value;
    b[n].is_null = &i.low_null;
    n++;

    // high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.high_value;
    b[n].is_null = &i.high_null;
    n++;
  }

  void access::object_traits< ::pio::Detector >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Detector >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // detector
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.detector;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.detector_value,
        is_null,
        v);
      i.detector_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // low
    //
    {
      int const& v =
        o.low;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.low_value,
        is_null,
        v);
      i.low_null = is_null;
    }

    // high
    //
    {
      int const& v =
        o.high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.high_value,
        is_null,
        v);
      i.high_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Detector >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // detector
    //
    {
      int& v =
        o.detector;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.detector_value,
        i.detector_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // low
    //
    {
      int& v =
        o.low;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.low_value,
        i.low_null);
    }

    // high
    //
    {
      int& v =
        o.high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.high_value,
        i.high_null);
    }
  }

  void access::object_traits< ::pio::Detector >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Detector >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Detector >::persist_statement[] =
  "INSERT INTO \"DETECTOR\" ("
  "\"DETECTOR\","
  "\"LINK\","
  "\"DIR\","
  "\"OFFSET\","
  "\"LENGTH\","
  "\"LANES\","
  "\"TYPE\","
  "\"USE\","
  "\"LOW\","
  "\"HIGH\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Detector >::find_statement[] =
  "SELECT "
  "\"DETECTOR\".\"DETECTOR\","
  "\"DETECTOR\".\"LINK\","
  "\"DETECTOR\".\"DIR\","
  "\"DETECTOR\".\"OFFSET\","
  "\"DETECTOR\".\"LENGTH\","
  "\"DETECTOR\".\"LANES\","
  "\"DETECTOR\".\"TYPE\","
  "\"DETECTOR\".\"USE\","
  "\"DETECTOR\".\"LOW\","
  "\"DETECTOR\".\"HIGH\""
  " FROM \"DETECTOR\""
  " WHERE \"DETECTOR\".\"DETECTOR\"=?";

  const char access::object_traits< ::pio::Detector >::update_statement[] =
  "UPDATE \"DETECTOR\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"OFFSET\"=?,"
  "\"LENGTH\"=?,"
  "\"LANES\"=?,"
  "\"TYPE\"=?,"
  "\"USE\"=?,"
  "\"LOW\"=?,"
  "\"HIGH\"=?"
  " WHERE \"DETECTOR\"=?";

  const char access::object_traits< ::pio::Detector >::erase_statement[] =
  "DELETE FROM \"DETECTOR\""
  " WHERE \"DETECTOR\"=?";

  const char access::object_traits< ::pio::Detector >::query_statement[] =
  "SELECT "
  "\"DETECTOR\".\"DETECTOR\","
  "\"DETECTOR\".\"LINK\","
  "\"DETECTOR\".\"DIR\","
  "\"DETECTOR\".\"OFFSET\","
  "\"DETECTOR\".\"LENGTH\","
  "\"DETECTOR\".\"LANES\","
  "\"DETECTOR\".\"TYPE\","
  "\"DETECTOR\".\"USE\","
  "\"DETECTOR\".\"LOW\","
  "\"DETECTOR\".\"HIGH\""
  " FROM \"DETECTOR\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"DETECTOR\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Detector >::erase_query_statement[] =
  "DELETE FROM \"DETECTOR\""
  " ";

  const char access::object_traits< ::pio::Detector >::table_name[] =
  "\"DETECTOR\"";

  void access::object_traits< ::pio::Detector >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Detector >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.detector);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Detector >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Detector >::pointer_type
  access::object_traits< ::pio::Detector >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Detector >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Detector >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.detector);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Detector >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Detector >::object_type >
  access::object_traits< ::pio::Detector >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Detector >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Detector >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"DETECTOR\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"DETECTOR\" (\n"
                      "  \"DETECTOR\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  \"LENGTH\" REAL,\n"
                      "  \"LANES\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"USE\" INTEGER NOT NULL,\n"
                      "  \"LOW\" INTEGER NOT NULL,\n"
                      "  \"HIGH\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"DETECTOR_DETECTOR_i\"\n"
                      "  ON \"DETECTOR\" (\"DETECTOR\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Detector_ (
    "",
    &access::object_traits< ::pio::Detector >::create_schema);

  // Stop
  //

  access::object_traits< ::pio::Stop >::id_type
  access::object_traits< ::pio::Stop >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.stop_value,
        i.stop_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Stop >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // stop
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // link
    //
    t[2UL] = false;

    // dir
    //
    t[3UL] = false;

    // offset
    //
    t[4UL] = false;

    // use
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // space
    //
    t[7UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Stop >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // stop
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.stop_value;
      b[n].is_null = &i.stop_null;
      n++;
    }

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // space
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.space_value;
    b[n].is_null = &i.space_null;
    n++;
  }

  void access::object_traits< ::pio::Stop >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Stop >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // stop
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.stop;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.stop_value,
        is_null,
        v);
      i.stop_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // space
    //
    {
      int const& v =
        o.space;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.space_value,
        is_null,
        v);
      i.space_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Stop >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // stop
    //
    {
      int& v =
        o.stop;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.stop_value,
        i.stop_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // space
    //
    {
      int& v =
        o.space;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.space_value,
        i.space_null);
    }
  }

  void access::object_traits< ::pio::Stop >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Stop >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Stop >::persist_statement[] =
  "INSERT INTO \"STOP\" ("
  "\"STOP\","
  "\"NAME\","
  "\"LINK\","
  "\"DIR\","
  "\"OFFSET\","
  "\"USE\","
  "\"TYPE\","
  "\"SPACE\")"
  " VALUES (?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Stop >::find_statement[] =
  "SELECT "
  "\"STOP\".\"STOP\","
  "\"STOP\".\"NAME\","
  "\"STOP\".\"LINK\","
  "\"STOP\".\"DIR\","
  "\"STOP\".\"OFFSET\","
  "\"STOP\".\"USE\","
  "\"STOP\".\"TYPE\","
  "\"STOP\".\"SPACE\""
  " FROM \"STOP\""
  " WHERE \"STOP\".\"STOP\"=?";

  const char access::object_traits< ::pio::Stop >::update_statement[] =
  "UPDATE \"STOP\" SET "
  "\"NAME\"=?,"
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"OFFSET\"=?,"
  "\"USE\"=?,"
  "\"TYPE\"=?,"
  "\"SPACE\"=?"
  " WHERE \"STOP\"=?";

  const char access::object_traits< ::pio::Stop >::erase_statement[] =
  "DELETE FROM \"STOP\""
  " WHERE \"STOP\"=?";

  const char access::object_traits< ::pio::Stop >::query_statement[] =
  "SELECT "
  "\"STOP\".\"STOP\","
  "\"STOP\".\"NAME\","
  "\"STOP\".\"LINK\","
  "\"STOP\".\"DIR\","
  "\"STOP\".\"OFFSET\","
  "\"STOP\".\"USE\","
  "\"STOP\".\"TYPE\","
  "\"STOP\".\"SPACE\""
  " FROM \"STOP\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"STOP\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Stop >::erase_query_statement[] =
  "DELETE FROM \"STOP\""
  " ";

  const char access::object_traits< ::pio::Stop >::table_name[] =
  "\"STOP\"";

  void access::object_traits< ::pio::Stop >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Stop >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.stop);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Stop >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Stop >::pointer_type
  access::object_traits< ::pio::Stop >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Stop >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Stop >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.stop);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Stop >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Stop >::object_type >
  access::object_traits< ::pio::Stop >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Stop >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Stop >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"STOP\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"STOP\" (\n"
                      "  \"STOP\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"NAME\" TEXT NOT NULL,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  \"USE\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"SPACE\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"STOP_STOP_i\"\n"
                      "  ON \"STOP\" (\"STOP\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Stop_ (
    "",
    &access::object_traits< ::pio::Stop >::create_schema);

  // Fare
  //

  access::object_traits< ::pio::Fare >::id_type
  access::object_traits< ::pio::Fare >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.fare_value,
        i.fare_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Fare >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // from_zone
    //
    t[0UL] = false;

    // to_zone
    //
    t[1UL] = false;

    // from_mode
    //
    t[2UL] = false;

    // to_mode
    //
    t[3UL] = false;

    // period
    //
    t[4UL] = false;

    // type
    //
    t[5UL] = false;

    // fare
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Fare >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // from_zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_zone_value;
    b[n].is_null = &i.from_zone_null;
    n++;

    // to_zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_zone_value;
    b[n].is_null = &i.to_zone_null;
    n++;

    // from_mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_mode_value;
    b[n].is_null = &i.from_mode_null;
    n++;

    // to_mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_mode_value;
    b[n].is_null = &i.to_mode_null;
    n++;

    // period
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.period_value;
    b[n].is_null = &i.period_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // fare
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.fare_value;
      b[n].is_null = &i.fare_null;
      n++;
    }
  }

  void access::object_traits< ::pio::Fare >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Fare >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // from_zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone > const& v =
        o.from_zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.from_zone_value,
          is_null,
          id);
        i.from_zone_null = is_null;
      }
      else
        i.from_zone_null = true;
    }

    // to_zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone > const& v =
        o.to_zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_zone_value,
          is_null,
          id);
        i.to_zone_null = is_null;
      }
      else
        i.to_zone_null = true;
    }

    // from_mode
    //
    {
      int const& v =
        o.from_mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_mode_value,
        is_null,
        v);
      i.from_mode_null = is_null;
    }

    // to_mode
    //
    {
      int const& v =
        o.to_mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_mode_value,
        is_null,
        v);
      i.to_mode_null = is_null;
    }

    // period
    //
    {
      int const& v =
        o.period;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.period_value,
        is_null,
        v);
      i.period_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // fare
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.fare;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.fare_value,
        is_null,
        v);
      i.fare_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Fare >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // from_zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone >& v =
        o.from_zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      if (i.from_zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.from_zone_value,
          i.from_zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // to_zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone >& v =
        o.to_zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      if (i.to_zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_zone_value,
          i.to_zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // from_mode
    //
    {
      int& v =
        o.from_mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_mode_value,
        i.from_mode_null);
    }

    // to_mode
    //
    {
      int& v =
        o.to_mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_mode_value,
        i.to_mode_null);
    }

    // period
    //
    {
      int& v =
        o.period;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.period_value,
        i.period_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // fare
    //
    {
      int& v =
        o.fare;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.fare_value,
        i.fare_null);
    }
  }

  void access::object_traits< ::pio::Fare >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Fare >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Fare >::persist_statement[] =
  "INSERT INTO \"FARE\" ("
  "\"FROM_ZONE\","
  "\"TO_ZONE\","
  "\"FROM_MODE\","
  "\"TO_MODE\","
  "\"PERIOD\","
  "\"TYPE\","
  "\"FARE\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Fare >::find_statement[] =
  "SELECT "
  "\"FARE\".\"FROM_ZONE\","
  "\"FARE\".\"TO_ZONE\","
  "\"FARE\".\"FROM_MODE\","
  "\"FARE\".\"TO_MODE\","
  "\"FARE\".\"PERIOD\","
  "\"FARE\".\"TYPE\","
  "\"FARE\".\"FARE\""
  " FROM \"FARE\""
  " WHERE \"FARE\".\"FARE\"=?";

  const char access::object_traits< ::pio::Fare >::update_statement[] =
  "UPDATE \"FARE\" SET "
  "\"FROM_ZONE\"=?,"
  "\"TO_ZONE\"=?,"
  "\"FROM_MODE\"=?,"
  "\"TO_MODE\"=?,"
  "\"PERIOD\"=?,"
  "\"TYPE\"=?"
  " WHERE \"FARE\"=?";

  const char access::object_traits< ::pio::Fare >::erase_statement[] =
  "DELETE FROM \"FARE\""
  " WHERE \"FARE\"=?";

  const char access::object_traits< ::pio::Fare >::query_statement[] =
  "SELECT "
  "\"FARE\".\"FROM_ZONE\","
  "\"FARE\".\"TO_ZONE\","
  "\"FARE\".\"FROM_MODE\","
  "\"FARE\".\"TO_MODE\","
  "\"FARE\".\"PERIOD\","
  "\"FARE\".\"TYPE\","
  "\"FARE\".\"FARE\""
  " FROM \"FARE\""
  " LEFT JOIN \"ZONE\" AS \"FROM_ZONE\" ON \"FROM_ZONE\".\"ZONE\"=\"FARE\".\"FROM_ZONE\""
  " LEFT JOIN \"ZONE\" AS \"TO_ZONE\" ON \"TO_ZONE\".\"ZONE\"=\"FARE\".\"TO_ZONE\""
  " ";

  const char access::object_traits< ::pio::Fare >::erase_query_statement[] =
  "DELETE FROM \"FARE\""
  " ";

  const char access::object_traits< ::pio::Fare >::table_name[] =
  "\"FARE\"";

  void access::object_traits< ::pio::Fare >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Fare >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.fare);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Fare >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Fare >::pointer_type
  access::object_traits< ::pio::Fare >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Fare >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Fare >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.fare);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Fare >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Fare >::object_type >
  access::object_traits< ::pio::Fare >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Fare >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Fare >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"FARE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"FARE\" (\n"
                      "  \"FROM_ZONE\" INTEGER,\n"
                      "  \"TO_ZONE\" INTEGER,\n"
                      "  \"FROM_MODE\" INTEGER NOT NULL,\n"
                      "  \"TO_MODE\" INTEGER NOT NULL,\n"
                      "  \"PERIOD\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"FARE\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  CONSTRAINT \"FROM_ZONE_fk\"\n"
                      "    FOREIGN KEY (\"FROM_ZONE\")\n"
                      "    REFERENCES \"ZONE\" (\"ZONE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"TO_ZONE_fk\"\n"
                      "    FOREIGN KEY (\"TO_ZONE\")\n"
                      "    REFERENCES \"ZONE\" (\"ZONE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"FARE_FARE_i\"\n"
                      "  ON \"FARE\" (\"FARE\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Fare_ (
    "",
    &access::object_traits< ::pio::Fare >::create_schema);

  // Line
  //

  access::object_traits< ::pio::Line >::id_type
  access::object_traits< ::pio::Line >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Line >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // stops
    //
    t[2UL] = false;

    // mode
    //
    t[3UL] = false;

    // type
    //
    t[4UL] = false;

    // name
    //
    if (t[5UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // stop
    //
    t[6UL] = false;

    // zone
    //
    t[7UL] = false;

    // flag
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Line >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // stops
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stops_value;
    b[n].is_null = &i.stops_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;

    // zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.zone_value;
    b[n].is_null = &i.zone_null;
    n++;

    // flag
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.flag_value;
    b[n].is_null = &i.flag_null;
    n++;
  }

  void access::object_traits< ::pio::Line >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Line >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stops;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stops_value,
          is_null,
          id);
        i.stops_null = is_null;
      }
      else
        i.stops_null = true;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone > const& v =
        o.zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.zone_value,
          is_null,
          id);
        i.zone_null = is_null;
      }
      else
        i.zone_null = true;
    }

    // flag
    //
    {
      int const& v =
        o.flag;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.flag_value,
        is_null,
        v);
      i.flag_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Line >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stops;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stops_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stops_value,
          i.stops_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone >& v =
        o.zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      if (i.zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.zone_value,
          i.zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // flag
    //
    {
      int& v =
        o.flag;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.flag_value,
        i.flag_null);
    }
  }

  void access::object_traits< ::pio::Line >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Line >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Line >::persist_statement[] =
  "INSERT INTO \"LINE\" ("
  "\"auto_id\","
  "\"ROUTE\","
  "\"STOPS\","
  "\"MODE\","
  "\"TYPE\","
  "\"NAME\","
  "\"STOP\","
  "\"ZONE\","
  "\"FLAG\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Line >::find_statement[] =
  "SELECT "
  "\"LINE\".\"auto_id\","
  "\"LINE\".\"ROUTE\","
  "\"LINE\".\"STOPS\","
  "\"LINE\".\"MODE\","
  "\"LINE\".\"TYPE\","
  "\"LINE\".\"NAME\","
  "\"LINE\".\"STOP\","
  "\"LINE\".\"ZONE\","
  "\"LINE\".\"FLAG\""
  " FROM \"LINE\""
  " WHERE \"LINE\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Line >::update_statement[] =
  "UPDATE \"LINE\" SET "
  "\"ROUTE\"=?,"
  "\"STOPS\"=?,"
  "\"MODE\"=?,"
  "\"TYPE\"=?,"
  "\"NAME\"=?,"
  "\"STOP\"=?,"
  "\"ZONE\"=?,"
  "\"FLAG\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Line >::erase_statement[] =
  "DELETE FROM \"LINE\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Line >::query_statement[] =
  "SELECT "
  "\"LINE\".\"auto_id\","
  "\"LINE\".\"ROUTE\","
  "\"LINE\".\"STOPS\","
  "\"LINE\".\"MODE\","
  "\"LINE\".\"TYPE\","
  "\"LINE\".\"NAME\","
  "\"LINE\".\"STOP\","
  "\"LINE\".\"ZONE\","
  "\"LINE\".\"FLAG\""
  " FROM \"LINE\""
  " LEFT JOIN \"STOP\" AS \"STOPS\" ON \"STOPS\".\"STOP\"=\"LINE\".\"STOPS\""
  " LEFT JOIN \"STOP\" AS \"STOP\" ON \"STOP\".\"STOP\"=\"LINE\".\"STOP\""
  " LEFT JOIN \"ZONE\" AS \"ZONE\" ON \"ZONE\".\"ZONE\"=\"LINE\".\"ZONE\""
  " ";

  const char access::object_traits< ::pio::Line >::erase_query_statement[] =
  "DELETE FROM \"LINE\""
  " ";

  const char access::object_traits< ::pio::Line >::table_name[] =
  "\"LINE\"";

  void access::object_traits< ::pio::Line >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Line >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Line >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Line >::pointer_type
  access::object_traits< ::pio::Line >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Line >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Line >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Line >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Line >::object_type >
  access::object_traits< ::pio::Line >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Line >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Line >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"LINE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"LINE\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"ROUTE\" INTEGER NOT NULL,\n"
                      "  \"STOPS\" INTEGER,\n"
                      "  \"MODE\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"NAME\" TEXT NOT NULL,\n"
                      "  \"STOP\" INTEGER,\n"
                      "  \"ZONE\" INTEGER,\n"
                      "  \"FLAG\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"STOPS_fk\"\n"
                      "    FOREIGN KEY (\"STOPS\")\n"
                      "    REFERENCES \"STOP\" (\"STOP\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"STOP_fk\"\n"
                      "    FOREIGN KEY (\"STOP\")\n"
                      "    REFERENCES \"STOP\" (\"STOP\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"ZONE_fk\"\n"
                      "    FOREIGN KEY (\"ZONE\")\n"
                      "    REFERENCES \"ZONE\" (\"ZONE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Line_ (
    "",
    &access::object_traits< ::pio::Line >::create_schema);

  // Schedule
  //

  access::object_traits< ::pio::Schedule >::id_type
  access::object_traits< ::pio::Schedule >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Schedule >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // stops
    //
    t[2UL] = false;

    // stop
    //
    t[3UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Schedule >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // stops
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stops_value;
    b[n].is_null = &i.stops_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;
  }

  void access::object_traits< ::pio::Schedule >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Schedule >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stops;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stops_value,
          is_null,
          id);
        i.stops_null = is_null;
      }
      else
        i.stops_null = true;
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    return grew;
  }

  void access::object_traits< ::pio::Schedule >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stops;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stops_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stops_value,
          i.stops_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits< ::pio::Schedule >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Schedule >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Schedule >::persist_statement[] =
  "INSERT INTO \"SCHEDULE\" ("
  "\"auto_id\","
  "\"ROUTE\","
  "\"STOPS\","
  "\"STOP\")"
  " VALUES (?,?,?,?)";

  const char access::object_traits< ::pio::Schedule >::find_statement[] =
  "SELECT "
  "\"SCHEDULE\".\"auto_id\","
  "\"SCHEDULE\".\"ROUTE\","
  "\"SCHEDULE\".\"STOPS\","
  "\"SCHEDULE\".\"STOP\""
  " FROM \"SCHEDULE\""
  " WHERE \"SCHEDULE\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Schedule >::update_statement[] =
  "UPDATE \"SCHEDULE\" SET "
  "\"ROUTE\"=?,"
  "\"STOPS\"=?,"
  "\"STOP\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Schedule >::erase_statement[] =
  "DELETE FROM \"SCHEDULE\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Schedule >::query_statement[] =
  "SELECT "
  "\"SCHEDULE\".\"auto_id\","
  "\"SCHEDULE\".\"ROUTE\","
  "\"SCHEDULE\".\"STOPS\","
  "\"SCHEDULE\".\"STOP\""
  " FROM \"SCHEDULE\""
  " LEFT JOIN \"STOP\" AS \"STOPS\" ON \"STOPS\".\"STOP\"=\"SCHEDULE\".\"STOPS\""
  " LEFT JOIN \"STOP\" AS \"STOP\" ON \"STOP\".\"STOP\"=\"SCHEDULE\".\"STOP\""
  " ";

  const char access::object_traits< ::pio::Schedule >::erase_query_statement[] =
  "DELETE FROM \"SCHEDULE\""
  " ";

  const char access::object_traits< ::pio::Schedule >::table_name[] =
  "\"SCHEDULE\"";

  void access::object_traits< ::pio::Schedule >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Schedule >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Schedule >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Schedule >::pointer_type
  access::object_traits< ::pio::Schedule >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Schedule >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Schedule >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Schedule >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Schedule >::object_type >
  access::object_traits< ::pio::Schedule >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Schedule >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Schedule >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"SCHEDULE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"SCHEDULE\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"ROUTE\" INTEGER NOT NULL,\n"
                      "  \"STOPS\" INTEGER,\n"
                      "  \"STOP\" INTEGER,\n"
                      "  CONSTRAINT \"STOPS_fk\"\n"
                      "    FOREIGN KEY (\"STOPS\")\n"
                      "    REFERENCES \"STOP\" (\"STOP\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"STOP_fk\"\n"
                      "    FOREIGN KEY (\"STOP\")\n"
                      "    REFERENCES \"STOP\" (\"STOP\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Schedule_ (
    "",
    &access::object_traits< ::pio::Schedule >::create_schema);

  // Driver
  //

  access::object_traits< ::pio::Driver >::id_type
  access::object_traits< ::pio::Driver >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Driver >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // links
    //
    t[2UL] = false;

    // type
    //
    t[3UL] = false;

    // subtype
    //
    t[4UL] = false;

    // link
    //
    t[5UL] = false;

    // dir
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Driver >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // links
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.links_value;
    b[n].is_null = &i.links_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // subtype
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subtype_value;
    b[n].is_null = &i.subtype_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;
  }

  void access::object_traits< ::pio::Driver >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Driver >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // links
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.links;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.links_value,
          is_null,
          id);
        i.links_null = is_null;
      }
      else
        i.links_null = true;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // subtype
    //
    {
      int const& v =
        o.subtype;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subtype_value,
        is_null,
        v);
      i.subtype_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Driver >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // links
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.links;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.links_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.links_value,
          i.links_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // subtype
    //
    {
      int& v =
        o.subtype;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subtype_value,
        i.subtype_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }
  }

  void access::object_traits< ::pio::Driver >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Driver >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Driver >::persist_statement[] =
  "INSERT INTO \"DRIVER\" ("
  "\"auto_id\","
  "\"ROUTE\","
  "\"LINKS\","
  "\"TYPE\","
  "\"SUBTYPE\","
  "\"LINK\","
  "\"DIR\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Driver >::find_statement[] =
  "SELECT "
  "\"DRIVER\".\"auto_id\","
  "\"DRIVER\".\"ROUTE\","
  "\"DRIVER\".\"LINKS\","
  "\"DRIVER\".\"TYPE\","
  "\"DRIVER\".\"SUBTYPE\","
  "\"DRIVER\".\"LINK\","
  "\"DRIVER\".\"DIR\""
  " FROM \"DRIVER\""
  " WHERE \"DRIVER\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Driver >::update_statement[] =
  "UPDATE \"DRIVER\" SET "
  "\"ROUTE\"=?,"
  "\"LINKS\"=?,"
  "\"TYPE\"=?,"
  "\"SUBTYPE\"=?,"
  "\"LINK\"=?,"
  "\"DIR\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Driver >::erase_statement[] =
  "DELETE FROM \"DRIVER\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Driver >::query_statement[] =
  "SELECT "
  "\"DRIVER\".\"auto_id\","
  "\"DRIVER\".\"ROUTE\","
  "\"DRIVER\".\"LINKS\","
  "\"DRIVER\".\"TYPE\","
  "\"DRIVER\".\"SUBTYPE\","
  "\"DRIVER\".\"LINK\","
  "\"DRIVER\".\"DIR\""
  " FROM \"DRIVER\""
  " LEFT JOIN \"LINK\" AS \"LINKS\" ON \"LINKS\".\"LINK\"=\"DRIVER\".\"LINKS\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"DRIVER\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Driver >::erase_query_statement[] =
  "DELETE FROM \"DRIVER\""
  " ";

  const char access::object_traits< ::pio::Driver >::table_name[] =
  "\"DRIVER\"";

  void access::object_traits< ::pio::Driver >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Driver >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Driver >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Driver >::pointer_type
  access::object_traits< ::pio::Driver >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Driver >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Driver >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Driver >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Driver >::object_type >
  access::object_traits< ::pio::Driver >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Driver >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Driver >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"DRIVER\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"DRIVER\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"ROUTE\" INTEGER NOT NULL,\n"
                      "  \"LINKS\" INTEGER,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"SUBTYPE\" INTEGER NOT NULL,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINKS_fk\"\n"
                      "    FOREIGN KEY (\"LINKS\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Driver_ (
    "",
    &access::object_traits< ::pio::Driver >::create_schema);

  // Route_Nodes
  //

  access::object_traits< ::pio::Route_Nodes >::id_type
  access::object_traits< ::pio::Route_Nodes >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // mode
    //
    t[2UL] = false;

    // veh_type
    //
    t[3UL] = false;

    // nodes
    //
    t[4UL] = false;

    // name
    //
    if (t[5UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // node
    //
    t[6UL] = false;

    // type
    //
    t[7UL] = false;

    // dwell
    //
    t[8UL] = false;

    // time
    //
    t[9UL] = false;

    // speed
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Route_Nodes >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // veh_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.veh_type_value;
    b[n].is_null = &i.veh_type_null;
    n++;

    // nodes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.nodes_value;
    b[n].is_null = &i.nodes_null;
    n++;

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_value;
    b[n].is_null = &i.node_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.dwell_value;
    b[n].is_null = &i.dwell_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;
  }

  void access::object_traits< ::pio::Route_Nodes >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // veh_type
    //
    {
      ::std::tr1::shared_ptr< ::pio::Veh_Type > const& v =
        o.veh_type;

      typedef object_traits< ::pio::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Veh_Type > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.veh_type_value,
          is_null,
          id);
        i.veh_type_null = is_null;
      }
      else
        i.veh_type_null = true;
    }

    // nodes
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.nodes;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.nodes_value,
          is_null,
          id);
        i.nodes_null = is_null;
      }
      else
        i.nodes_null = true;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_value,
          is_null,
          id);
        i.node_null = is_null;
      }
      else
        i.node_null = true;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // dwell
    //
    {
      double const& v =
        o.dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.dwell_value,
        is_null,
        v);
      i.dwell_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Route_Nodes >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // veh_type
    //
    {
      ::std::tr1::shared_ptr< ::pio::Veh_Type >& v =
        o.veh_type;

      typedef object_traits< ::pio::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Veh_Type > > ptr_traits;

      if (i.veh_type_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.veh_type_value,
          i.veh_type_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // nodes
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.nodes;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.nodes_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.nodes_value,
          i.nodes_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_value,
          i.node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // dwell
    //
    {
      double& v =
        o.dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.dwell_value,
        i.dwell_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }
  }

  void access::object_traits< ::pio::Route_Nodes >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Route_Nodes >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Route_Nodes >::persist_statement[] =
  "INSERT INTO \"ROUTE_NODES\" ("
  "\"auto_id\","
  "\"ROUTE\","
  "\"MODE\","
  "\"VEH_TYPE\","
  "\"NODES\","
  "\"NAME\","
  "\"NODE\","
  "\"TYPE\","
  "\"DWELL\","
  "\"TIME\","
  "\"SPEED\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Route_Nodes >::find_statement[] =
  "SELECT "
  "\"ROUTE_NODES\".\"auto_id\","
  "\"ROUTE_NODES\".\"ROUTE\","
  "\"ROUTE_NODES\".\"MODE\","
  "\"ROUTE_NODES\".\"VEH_TYPE\","
  "\"ROUTE_NODES\".\"NODES\","
  "\"ROUTE_NODES\".\"NAME\","
  "\"ROUTE_NODES\".\"NODE\","
  "\"ROUTE_NODES\".\"TYPE\","
  "\"ROUTE_NODES\".\"DWELL\","
  "\"ROUTE_NODES\".\"TIME\","
  "\"ROUTE_NODES\".\"SPEED\""
  " FROM \"ROUTE_NODES\""
  " WHERE \"ROUTE_NODES\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Route_Nodes >::update_statement[] =
  "UPDATE \"ROUTE_NODES\" SET "
  "\"ROUTE\"=?,"
  "\"MODE\"=?,"
  "\"VEH_TYPE\"=?,"
  "\"NODES\"=?,"
  "\"NAME\"=?,"
  "\"NODE\"=?,"
  "\"TYPE\"=?,"
  "\"DWELL\"=?,"
  "\"TIME\"=?,"
  "\"SPEED\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Route_Nodes >::erase_statement[] =
  "DELETE FROM \"ROUTE_NODES\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Route_Nodes >::query_statement[] =
  "SELECT "
  "\"ROUTE_NODES\".\"auto_id\","
  "\"ROUTE_NODES\".\"ROUTE\","
  "\"ROUTE_NODES\".\"MODE\","
  "\"ROUTE_NODES\".\"VEH_TYPE\","
  "\"ROUTE_NODES\".\"NODES\","
  "\"ROUTE_NODES\".\"NAME\","
  "\"ROUTE_NODES\".\"NODE\","
  "\"ROUTE_NODES\".\"TYPE\","
  "\"ROUTE_NODES\".\"DWELL\","
  "\"ROUTE_NODES\".\"TIME\","
  "\"ROUTE_NODES\".\"SPEED\""
  " FROM \"ROUTE_NODES\""
  " LEFT JOIN \"VEH_TYPE\" AS \"VEH_TYPE\" ON \"VEH_TYPE\".\"TYPE\"=\"ROUTE_NODES\".\"VEH_TYPE\""
  " LEFT JOIN \"NODE\" AS \"NODES\" ON \"NODES\".\"NODE\"=\"ROUTE_NODES\".\"NODES\""
  " LEFT JOIN \"NODE\" AS \"NODE\" ON \"NODE\".\"NODE\"=\"ROUTE_NODES\".\"NODE\""
  " ";

  const char access::object_traits< ::pio::Route_Nodes >::erase_query_statement[] =
  "DELETE FROM \"ROUTE_NODES\""
  " ";

  const char access::object_traits< ::pio::Route_Nodes >::table_name[] =
  "\"ROUTE_NODES\"";

  void access::object_traits< ::pio::Route_Nodes >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Route_Nodes >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Route_Nodes >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Route_Nodes >::pointer_type
  access::object_traits< ::pio::Route_Nodes >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Route_Nodes >::object_type >
  access::object_traits< ::pio::Route_Nodes >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Route_Nodes >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"ROUTE_NODES\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"ROUTE_NODES\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"ROUTE\" INTEGER NOT NULL,\n"
                      "  \"MODE\" INTEGER NOT NULL,\n"
                      "  \"VEH_TYPE\" INTEGER,\n"
                      "  \"NODES\" INTEGER,\n"
                      "  \"NAME\" TEXT NOT NULL,\n"
                      "  \"NODE\" INTEGER,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"DWELL\" REAL,\n"
                      "  \"TIME\" REAL,\n"
                      "  \"SPEED\" REAL,\n"
                      "  CONSTRAINT \"VEH_TYPE_fk\"\n"
                      "    FOREIGN KEY (\"VEH_TYPE\")\n"
                      "    REFERENCES \"VEH_TYPE\" (\"TYPE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"NODES_fk\"\n"
                      "    FOREIGN KEY (\"NODES\")\n"
                      "    REFERENCES \"NODE\" (\"NODE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"NODE_fk\"\n"
                      "    FOREIGN KEY (\"NODE\")\n"
                      "    REFERENCES \"NODE\" (\"NODE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Route_Nodes_ (
    "",
    &access::object_traits< ::pio::Route_Nodes >::create_schema);

  // Selection
  //

  access::object_traits< ::pio::Selection >::id_type
  access::object_traits< ::pio::Selection >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Selection >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // type
    //
    t[5UL] = false;

    // partition
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Selection >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;
  }

  void access::object_traits< ::pio::Selection >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Selection >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Selection >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }
  }

  void access::object_traits< ::pio::Selection >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Selection >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Selection >::persist_statement[] =
  "INSERT INTO \"SELECTION\" ("
  "\"auto_id\","
  "\"HHOLD\","
  "\"PERSON\","
  "\"TOUR\","
  "\"TRIP\","
  "\"TYPE\","
  "\"PARTITION\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Selection >::find_statement[] =
  "SELECT "
  "\"SELECTION\".\"auto_id\","
  "\"SELECTION\".\"HHOLD\","
  "\"SELECTION\".\"PERSON\","
  "\"SELECTION\".\"TOUR\","
  "\"SELECTION\".\"TRIP\","
  "\"SELECTION\".\"TYPE\","
  "\"SELECTION\".\"PARTITION\""
  " FROM \"SELECTION\""
  " WHERE \"SELECTION\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Selection >::update_statement[] =
  "UPDATE \"SELECTION\" SET "
  "\"HHOLD\"=?,"
  "\"PERSON\"=?,"
  "\"TOUR\"=?,"
  "\"TRIP\"=?,"
  "\"TYPE\"=?,"
  "\"PARTITION\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Selection >::erase_statement[] =
  "DELETE FROM \"SELECTION\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Selection >::query_statement[] =
  "SELECT "
  "\"SELECTION\".\"auto_id\","
  "\"SELECTION\".\"HHOLD\","
  "\"SELECTION\".\"PERSON\","
  "\"SELECTION\".\"TOUR\","
  "\"SELECTION\".\"TRIP\","
  "\"SELECTION\".\"TYPE\","
  "\"SELECTION\".\"PARTITION\""
  " FROM \"SELECTION\""
  " ";

  const char access::object_traits< ::pio::Selection >::erase_query_statement[] =
  "DELETE FROM \"SELECTION\""
  " ";

  const char access::object_traits< ::pio::Selection >::table_name[] =
  "\"SELECTION\"";

  void access::object_traits< ::pio::Selection >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Selection >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Selection >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Selection >::pointer_type
  access::object_traits< ::pio::Selection >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Selection >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Selection >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Selection >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Selection >::object_type >
  access::object_traits< ::pio::Selection >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Selection >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Selection >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"SELECTION\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"SELECTION\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"HHOLD\" INTEGER NOT NULL,\n"
                      "  \"PERSON\" INTEGER NOT NULL,\n"
                      "  \"TOUR\" INTEGER NOT NULL,\n"
                      "  \"TRIP\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"PARTITION\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Selection_ (
    "",
    &access::object_traits< ::pio::Selection >::create_schema);

  // Household
  //

  access::object_traits< ::pio::Household >::id_type
  access::object_traits< ::pio::Household >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Household >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // location
    //
    t[2UL] = false;

    // persons
    //
    t[3UL] = false;

    // workers
    //
    t[4UL] = false;

    // vehicles
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // partition
    //
    t[7UL] = false;

    // person
    //
    t[8UL] = false;

    // age
    //
    t[9UL] = false;

    // relate
    //
    t[10UL] = false;

    // gender
    //
    t[11UL] = false;

    // work
    //
    t[12UL] = false;

    // drive
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Household >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // location
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.location_value;
    b[n].is_null = &i.location_null;
    n++;

    // persons
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.persons_value;
    b[n].is_null = &i.persons_null;
    n++;

    // workers
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.workers_value;
    b[n].is_null = &i.workers_null;
    n++;

    // vehicles
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.vehicles_value;
    b[n].is_null = &i.vehicles_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // age
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.age_value;
    b[n].is_null = &i.age_null;
    n++;

    // relate
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.relate_value;
    b[n].is_null = &i.relate_null;
    n++;

    // gender
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.gender_value;
    b[n].is_null = &i.gender_null;
    n++;

    // work
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.work_value;
    b[n].is_null = &i.work_null;
    n++;

    // drive
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.drive_value;
    b[n].is_null = &i.drive_null;
    n++;
  }

  void access::object_traits< ::pio::Household >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Household >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // location
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location > const& v =
        o.location;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.location_value,
          is_null,
          id);
        i.location_null = is_null;
      }
      else
        i.location_null = true;
    }

    // persons
    //
    {
      int const& v =
        o.persons;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.persons_value,
        is_null,
        v);
      i.persons_null = is_null;
    }

    // workers
    //
    {
      int const& v =
        o.workers;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.workers_value,
        is_null,
        v);
      i.workers_null = is_null;
    }

    // vehicles
    //
    {
      int const& v =
        o.vehicles;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.vehicles_value,
        is_null,
        v);
      i.vehicles_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // age
    //
    {
      int const& v =
        o.age;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.age_value,
        is_null,
        v);
      i.age_null = is_null;
    }

    // relate
    //
    {
      int const& v =
        o.relate;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.relate_value,
        is_null,
        v);
      i.relate_null = is_null;
    }

    // gender
    //
    {
      int const& v =
        o.gender;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.gender_value,
        is_null,
        v);
      i.gender_null = is_null;
    }

    // work
    //
    {
      int const& v =
        o.work;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.work_value,
        is_null,
        v);
      i.work_null = is_null;
    }

    // drive
    //
    {
      int const& v =
        o.drive;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.drive_value,
        is_null,
        v);
      i.drive_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Household >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // location
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location >& v =
        o.location;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      if (i.location_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.location_value,
          i.location_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // persons
    //
    {
      int& v =
        o.persons;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.persons_value,
        i.persons_null);
    }

    // workers
    //
    {
      int& v =
        o.workers;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.workers_value,
        i.workers_null);
    }

    // vehicles
    //
    {
      int& v =
        o.vehicles;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.vehicles_value,
        i.vehicles_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // age
    //
    {
      int& v =
        o.age;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.age_value,
        i.age_null);
    }

    // relate
    //
    {
      int& v =
        o.relate;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.relate_value,
        i.relate_null);
    }

    // gender
    //
    {
      int& v =
        o.gender;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.gender_value,
        i.gender_null);
    }

    // work
    //
    {
      int& v =
        o.work;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.work_value,
        i.work_null);
    }

    // drive
    //
    {
      int& v =
        o.drive;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.drive_value,
        i.drive_null);
    }
  }

  void access::object_traits< ::pio::Household >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Household >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Household >::persist_statement[] =
  "INSERT INTO \"HOUSEHOLD\" ("
  "\"auto_id\","
  "\"HHOLD\","
  "\"LOCATION\","
  "\"PERSONS\","
  "\"WORKERS\","
  "\"VEHICLES\","
  "\"TYPE\","
  "\"PARTITION\","
  "\"PERSON\","
  "\"AGE\","
  "\"RELATE\","
  "\"GENDER\","
  "\"WORK\","
  "\"DRIVE\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Household >::find_statement[] =
  "SELECT "
  "\"HOUSEHOLD\".\"auto_id\","
  "\"HOUSEHOLD\".\"HHOLD\","
  "\"HOUSEHOLD\".\"LOCATION\","
  "\"HOUSEHOLD\".\"PERSONS\","
  "\"HOUSEHOLD\".\"WORKERS\","
  "\"HOUSEHOLD\".\"VEHICLES\","
  "\"HOUSEHOLD\".\"TYPE\","
  "\"HOUSEHOLD\".\"PARTITION\","
  "\"HOUSEHOLD\".\"PERSON\","
  "\"HOUSEHOLD\".\"AGE\","
  "\"HOUSEHOLD\".\"RELATE\","
  "\"HOUSEHOLD\".\"GENDER\","
  "\"HOUSEHOLD\".\"WORK\","
  "\"HOUSEHOLD\".\"DRIVE\""
  " FROM \"HOUSEHOLD\""
  " WHERE \"HOUSEHOLD\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Household >::update_statement[] =
  "UPDATE \"HOUSEHOLD\" SET "
  "\"HHOLD\"=?,"
  "\"LOCATION\"=?,"
  "\"PERSONS\"=?,"
  "\"WORKERS\"=?,"
  "\"VEHICLES\"=?,"
  "\"TYPE\"=?,"
  "\"PARTITION\"=?,"
  "\"PERSON\"=?,"
  "\"AGE\"=?,"
  "\"RELATE\"=?,"
  "\"GENDER\"=?,"
  "\"WORK\"=?,"
  "\"DRIVE\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Household >::erase_statement[] =
  "DELETE FROM \"HOUSEHOLD\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Household >::query_statement[] =
  "SELECT "
  "\"HOUSEHOLD\".\"auto_id\","
  "\"HOUSEHOLD\".\"HHOLD\","
  "\"HOUSEHOLD\".\"LOCATION\","
  "\"HOUSEHOLD\".\"PERSONS\","
  "\"HOUSEHOLD\".\"WORKERS\","
  "\"HOUSEHOLD\".\"VEHICLES\","
  "\"HOUSEHOLD\".\"TYPE\","
  "\"HOUSEHOLD\".\"PARTITION\","
  "\"HOUSEHOLD\".\"PERSON\","
  "\"HOUSEHOLD\".\"AGE\","
  "\"HOUSEHOLD\".\"RELATE\","
  "\"HOUSEHOLD\".\"GENDER\","
  "\"HOUSEHOLD\".\"WORK\","
  "\"HOUSEHOLD\".\"DRIVE\""
  " FROM \"HOUSEHOLD\""
  " LEFT JOIN \"LOCATION\" AS \"LOCATION\" ON \"LOCATION\".\"LOCATION\"=\"HOUSEHOLD\".\"LOCATION\""
  " ";

  const char access::object_traits< ::pio::Household >::erase_query_statement[] =
  "DELETE FROM \"HOUSEHOLD\""
  " ";

  const char access::object_traits< ::pio::Household >::table_name[] =
  "\"HOUSEHOLD\"";

  void access::object_traits< ::pio::Household >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Household >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Household >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Household >::pointer_type
  access::object_traits< ::pio::Household >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Household >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Household >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Household >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Household >::object_type >
  access::object_traits< ::pio::Household >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Household >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Household >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"HOUSEHOLD\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"HOUSEHOLD\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"HHOLD\" INTEGER NOT NULL,\n"
                      "  \"LOCATION\" INTEGER,\n"
                      "  \"PERSONS\" INTEGER NOT NULL,\n"
                      "  \"WORKERS\" INTEGER NOT NULL,\n"
                      "  \"VEHICLES\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"PARTITION\" INTEGER NOT NULL,\n"
                      "  \"PERSON\" INTEGER NOT NULL,\n"
                      "  \"AGE\" INTEGER NOT NULL,\n"
                      "  \"RELATE\" INTEGER NOT NULL,\n"
                      "  \"GENDER\" INTEGER NOT NULL,\n"
                      "  \"WORK\" INTEGER NOT NULL,\n"
                      "  \"DRIVE\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LOCATION_fk\"\n"
                      "    FOREIGN KEY (\"LOCATION\")\n"
                      "    REFERENCES \"LOCATION\" (\"LOCATION\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Household_ (
    "",
    &access::object_traits< ::pio::Household >::create_schema);

  // Link_Delay
  //

  access::object_traits< ::pio::Link_Delay >::id_type
  access::object_traits< ::pio::Link_Delay >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // type
    //
    t[3UL] = false;

    // start
    //
    t[4UL] = false;

    // end
    //
    t[5UL] = false;

    // flow
    //
    t[6UL] = false;

    // time
    //
    t[7UL] = false;

    // out_link
    //
    t[8UL] = false;

    // out_flow
    //
    t[9UL] = false;

    // out_time
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Link_Delay >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // flow
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.flow_value;
    b[n].is_null = &i.flow_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // out_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.out_link_value;
    b[n].is_null = &i.out_link_null;
    n++;

    // out_flow
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.out_flow_value;
    b[n].is_null = &i.out_flow_null;
    n++;

    // out_time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.out_time_value;
    b[n].is_null = &i.out_time_null;
    n++;
  }

  void access::object_traits< ::pio::Link_Delay >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // flow
    //
    {
      double const& v =
        o.flow;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.flow_value,
        is_null,
        v);
      i.flow_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // out_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.out_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.out_link_value,
          is_null,
          id);
        i.out_link_null = is_null;
      }
      else
        i.out_link_null = true;
    }

    // out_flow
    //
    {
      double const& v =
        o.out_flow;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.out_flow_value,
        is_null,
        v);
      i.out_flow_null = is_null;
    }

    // out_time
    //
    {
      double const& v =
        o.out_time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.out_time_value,
        is_null,
        v);
      i.out_time_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Link_Delay >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // flow
    //
    {
      double& v =
        o.flow;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.flow_value,
        i.flow_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // out_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.out_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.out_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.out_link_value,
          i.out_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // out_flow
    //
    {
      double& v =
        o.out_flow;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.out_flow_value,
        i.out_flow_null);
    }

    // out_time
    //
    {
      double& v =
        o.out_time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.out_time_value,
        i.out_time_null);
    }
  }

  void access::object_traits< ::pio::Link_Delay >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Link_Delay >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Link_Delay >::persist_statement[] =
  "INSERT INTO \"LINK_DELAY\" ("
  "\"auto_id\","
  "\"LINK\","
  "\"DIR\","
  "\"TYPE\","
  "\"START\","
  "\"END\","
  "\"FLOW\","
  "\"TIME\","
  "\"OUT_LINK\","
  "\"OUT_FLOW\","
  "\"OUT_TIME\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Link_Delay >::find_statement[] =
  "SELECT "
  "\"LINK_DELAY\".\"auto_id\","
  "\"LINK_DELAY\".\"LINK\","
  "\"LINK_DELAY\".\"DIR\","
  "\"LINK_DELAY\".\"TYPE\","
  "\"LINK_DELAY\".\"START\","
  "\"LINK_DELAY\".\"END\","
  "\"LINK_DELAY\".\"FLOW\","
  "\"LINK_DELAY\".\"TIME\","
  "\"LINK_DELAY\".\"OUT_LINK\","
  "\"LINK_DELAY\".\"OUT_FLOW\","
  "\"LINK_DELAY\".\"OUT_TIME\""
  " FROM \"LINK_DELAY\""
  " WHERE \"LINK_DELAY\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Link_Delay >::update_statement[] =
  "UPDATE \"LINK_DELAY\" SET "
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"TYPE\"=?,"
  "\"START\"=?,"
  "\"END\"=?,"
  "\"FLOW\"=?,"
  "\"TIME\"=?,"
  "\"OUT_LINK\"=?,"
  "\"OUT_FLOW\"=?,"
  "\"OUT_TIME\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Link_Delay >::erase_statement[] =
  "DELETE FROM \"LINK_DELAY\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Link_Delay >::query_statement[] =
  "SELECT "
  "\"LINK_DELAY\".\"auto_id\","
  "\"LINK_DELAY\".\"LINK\","
  "\"LINK_DELAY\".\"DIR\","
  "\"LINK_DELAY\".\"TYPE\","
  "\"LINK_DELAY\".\"START\","
  "\"LINK_DELAY\".\"END\","
  "\"LINK_DELAY\".\"FLOW\","
  "\"LINK_DELAY\".\"TIME\","
  "\"LINK_DELAY\".\"OUT_LINK\","
  "\"LINK_DELAY\".\"OUT_FLOW\","
  "\"LINK_DELAY\".\"OUT_TIME\""
  " FROM \"LINK_DELAY\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"LINK_DELAY\".\"LINK\""
  " LEFT JOIN \"LINK\" AS \"OUT_LINK\" ON \"OUT_LINK\".\"LINK\"=\"LINK_DELAY\".\"OUT_LINK\""
  " ";

  const char access::object_traits< ::pio::Link_Delay >::erase_query_statement[] =
  "DELETE FROM \"LINK_DELAY\""
  " ";

  const char access::object_traits< ::pio::Link_Delay >::table_name[] =
  "\"LINK_DELAY\"";

  void access::object_traits< ::pio::Link_Delay >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Link_Delay >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Link_Delay >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Link_Delay >::pointer_type
  access::object_traits< ::pio::Link_Delay >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Link_Delay >::object_type >
  access::object_traits< ::pio::Link_Delay >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Link_Delay >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Link_Delay >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"LINK_DELAY\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"LINK_DELAY\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"START\" REAL,\n"
                      "  \"END\" REAL,\n"
                      "  \"FLOW\" REAL,\n"
                      "  \"TIME\" REAL,\n"
                      "  \"OUT_LINK\" INTEGER,\n"
                      "  \"OUT_FLOW\" REAL,\n"
                      "  \"OUT_TIME\" REAL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"OUT_LINK_fk\"\n"
                      "    FOREIGN KEY (\"OUT_LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Link_Delay_ (
    "",
    &access::object_traits< ::pio::Link_Delay >::create_schema);

  // Performance
  //

  access::object_traits< ::pio::Performance >::id_type
  access::object_traits< ::pio::Performance >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Performance >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // speed
    //
    t[1UL] = false;

    // delay
    //
    t[2UL] = false;

    // density
    //
    t[3UL] = false;

    // max_den
    //
    t[4UL] = false;

    // ratio
    //
    t[5UL] = false;

    // queue
    //
    t[6UL] = false;

    // max_que
    //
    t[7UL] = false;

    // fail
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Performance >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;

    // delay
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.delay_value;
    b[n].is_null = &i.delay_null;
    n++;

    // density
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.density_value;
    b[n].is_null = &i.density_null;
    n++;

    // max_den
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_den_value;
    b[n].is_null = &i.max_den_null;
    n++;

    // ratio
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.ratio_value;
    b[n].is_null = &i.ratio_null;
    n++;

    // queue
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.queue_value;
    b[n].is_null = &i.queue_null;
    n++;

    // max_que
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_que_value;
    b[n].is_null = &i.max_que_null;
    n++;

    // fail
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.fail_value;
    b[n].is_null = &i.fail_null;
    n++;
  }

  void access::object_traits< ::pio::Performance >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Performance >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    // delay
    //
    {
      double const& v =
        o.delay;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.delay_value,
        is_null,
        v);
      i.delay_null = is_null;
    }

    // density
    //
    {
      double const& v =
        o.density;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.density_value,
        is_null,
        v);
      i.density_null = is_null;
    }

    // max_den
    //
    {
      double const& v =
        o.max_den;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_den_value,
        is_null,
        v);
      i.max_den_null = is_null;
    }

    // ratio
    //
    {
      double const& v =
        o.ratio;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.ratio_value,
        is_null,
        v);
      i.ratio_null = is_null;
    }

    // queue
    //
    {
      double const& v =
        o.queue;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.queue_value,
        is_null,
        v);
      i.queue_null = is_null;
    }

    // max_que
    //
    {
      int const& v =
        o.max_que;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_que_value,
        is_null,
        v);
      i.max_que_null = is_null;
    }

    // fail
    //
    {
      int const& v =
        o.fail;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.fail_value,
        is_null,
        v);
      i.fail_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Performance >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }

    // delay
    //
    {
      double& v =
        o.delay;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.delay_value,
        i.delay_null);
    }

    // density
    //
    {
      double& v =
        o.density;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.density_value,
        i.density_null);
    }

    // max_den
    //
    {
      double& v =
        o.max_den;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_den_value,
        i.max_den_null);
    }

    // ratio
    //
    {
      double& v =
        o.ratio;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.ratio_value,
        i.ratio_null);
    }

    // queue
    //
    {
      double& v =
        o.queue;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.queue_value,
        i.queue_null);
    }

    // max_que
    //
    {
      int& v =
        o.max_que;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_que_value,
        i.max_que_null);
    }

    // fail
    //
    {
      int& v =
        o.fail;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.fail_value,
        i.fail_null);
    }
  }

  void access::object_traits< ::pio::Performance >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Performance >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Performance >::persist_statement[] =
  "INSERT INTO \"PERFORMANCE\" ("
  "\"auto_id\","
  "\"SPEED\","
  "\"DELAY\","
  "\"DENSITY\","
  "\"MAX_DEN\","
  "\"RATIO\","
  "\"QUEUE\","
  "\"MAX_QUE\","
  "\"FAIL\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Performance >::find_statement[] =
  "SELECT "
  "\"PERFORMANCE\".\"auto_id\","
  "\"PERFORMANCE\".\"SPEED\","
  "\"PERFORMANCE\".\"DELAY\","
  "\"PERFORMANCE\".\"DENSITY\","
  "\"PERFORMANCE\".\"MAX_DEN\","
  "\"PERFORMANCE\".\"RATIO\","
  "\"PERFORMANCE\".\"QUEUE\","
  "\"PERFORMANCE\".\"MAX_QUE\","
  "\"PERFORMANCE\".\"FAIL\""
  " FROM \"PERFORMANCE\""
  " WHERE \"PERFORMANCE\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Performance >::update_statement[] =
  "UPDATE \"PERFORMANCE\" SET "
  "\"SPEED\"=?,"
  "\"DELAY\"=?,"
  "\"DENSITY\"=?,"
  "\"MAX_DEN\"=?,"
  "\"RATIO\"=?,"
  "\"QUEUE\"=?,"
  "\"MAX_QUE\"=?,"
  "\"FAIL\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Performance >::erase_statement[] =
  "DELETE FROM \"PERFORMANCE\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Performance >::query_statement[] =
  "SELECT "
  "\"PERFORMANCE\".\"auto_id\","
  "\"PERFORMANCE\".\"SPEED\","
  "\"PERFORMANCE\".\"DELAY\","
  "\"PERFORMANCE\".\"DENSITY\","
  "\"PERFORMANCE\".\"MAX_DEN\","
  "\"PERFORMANCE\".\"RATIO\","
  "\"PERFORMANCE\".\"QUEUE\","
  "\"PERFORMANCE\".\"MAX_QUE\","
  "\"PERFORMANCE\".\"FAIL\""
  " FROM \"PERFORMANCE\""
  " ";

  const char access::object_traits< ::pio::Performance >::erase_query_statement[] =
  "DELETE FROM \"PERFORMANCE\""
  " ";

  const char access::object_traits< ::pio::Performance >::table_name[] =
  "\"PERFORMANCE\"";

  void access::object_traits< ::pio::Performance >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Performance >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Performance >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Performance >::pointer_type
  access::object_traits< ::pio::Performance >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Performance >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Performance >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Performance >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Performance >::object_type >
  access::object_traits< ::pio::Performance >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Performance >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Performance >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"PERFORMANCE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"PERFORMANCE\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"SPEED\" REAL,\n"
                      "  \"DELAY\" REAL,\n"
                      "  \"DENSITY\" REAL,\n"
                      "  \"MAX_DEN\" REAL,\n"
                      "  \"RATIO\" REAL,\n"
                      "  \"QUEUE\" REAL,\n"
                      "  \"MAX_QUE\" INTEGER NOT NULL,\n"
                      "  \"FAIL\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Performance_ (
    "",
    &access::object_traits< ::pio::Performance >::create_schema);

  // Ridership
  //

  access::object_traits< ::pio::Ridership >::id_type
  access::object_traits< ::pio::Ridership >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Ridership >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // mode
    //
    t[1UL] = false;

    // route
    //
    t[2UL] = false;

    // run
    //
    t[3UL] = false;

    // stop
    //
    t[4UL] = false;

    // schedule
    //
    t[5UL] = false;

    // time
    //
    t[6UL] = false;

    // board
    //
    t[7UL] = false;

    // alight
    //
    t[8UL] = false;

    // load
    //
    t[9UL] = false;

    // factor
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Ridership >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // run
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.run_value;
    b[n].is_null = &i.run_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;

    // schedule
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.schedule_value;
    b[n].is_null = &i.schedule_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // board
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.board_value;
    b[n].is_null = &i.board_null;
    n++;

    // alight
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.alight_value;
    b[n].is_null = &i.alight_null;
    n++;

    // load
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.load_value;
    b[n].is_null = &i.load_null;
    n++;

    // factor
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.factor_value;
    b[n].is_null = &i.factor_null;
    n++;
  }

  void access::object_traits< ::pio::Ridership >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Ridership >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // run
    //
    {
      int const& v =
        o.run;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.run_value,
        is_null,
        v);
      i.run_null = is_null;
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    // schedule
    //
    {
      double const& v =
        o.schedule;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.schedule_value,
        is_null,
        v);
      i.schedule_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // board
    //
    {
      int const& v =
        o.board;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.board_value,
        is_null,
        v);
      i.board_null = is_null;
    }

    // alight
    //
    {
      int const& v =
        o.alight;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.alight_value,
        is_null,
        v);
      i.alight_null = is_null;
    }

    // load
    //
    {
      int const& v =
        o.load;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.load_value,
        is_null,
        v);
      i.load_null = is_null;
    }

    // factor
    //
    {
      double const& v =
        o.factor;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.factor_value,
        is_null,
        v);
      i.factor_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Ridership >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // run
    //
    {
      int& v =
        o.run;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.run_value,
        i.run_null);
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // schedule
    //
    {
      double& v =
        o.schedule;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.schedule_value,
        i.schedule_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // board
    //
    {
      int& v =
        o.board;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.board_value,
        i.board_null);
    }

    // alight
    //
    {
      int& v =
        o.alight;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.alight_value,
        i.alight_null);
    }

    // load
    //
    {
      int& v =
        o.load;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.load_value,
        i.load_null);
    }

    // factor
    //
    {
      double& v =
        o.factor;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.factor_value,
        i.factor_null);
    }
  }

  void access::object_traits< ::pio::Ridership >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Ridership >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Ridership >::persist_statement[] =
  "INSERT INTO \"RIDERSHIP\" ("
  "\"auto_id\","
  "\"MODE\","
  "\"ROUTE\","
  "\"RUN\","
  "\"STOP\","
  "\"SCHEDULE\","
  "\"TIME\","
  "\"BOARD\","
  "\"ALIGHT\","
  "\"LOAD\","
  "\"FACTOR\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Ridership >::find_statement[] =
  "SELECT "
  "\"RIDERSHIP\".\"auto_id\","
  "\"RIDERSHIP\".\"MODE\","
  "\"RIDERSHIP\".\"ROUTE\","
  "\"RIDERSHIP\".\"RUN\","
  "\"RIDERSHIP\".\"STOP\","
  "\"RIDERSHIP\".\"SCHEDULE\","
  "\"RIDERSHIP\".\"TIME\","
  "\"RIDERSHIP\".\"BOARD\","
  "\"RIDERSHIP\".\"ALIGHT\","
  "\"RIDERSHIP\".\"LOAD\","
  "\"RIDERSHIP\".\"FACTOR\""
  " FROM \"RIDERSHIP\""
  " WHERE \"RIDERSHIP\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Ridership >::update_statement[] =
  "UPDATE \"RIDERSHIP\" SET "
  "\"MODE\"=?,"
  "\"ROUTE\"=?,"
  "\"RUN\"=?,"
  "\"STOP\"=?,"
  "\"SCHEDULE\"=?,"
  "\"TIME\"=?,"
  "\"BOARD\"=?,"
  "\"ALIGHT\"=?,"
  "\"LOAD\"=?,"
  "\"FACTOR\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Ridership >::erase_statement[] =
  "DELETE FROM \"RIDERSHIP\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Ridership >::query_statement[] =
  "SELECT "
  "\"RIDERSHIP\".\"auto_id\","
  "\"RIDERSHIP\".\"MODE\","
  "\"RIDERSHIP\".\"ROUTE\","
  "\"RIDERSHIP\".\"RUN\","
  "\"RIDERSHIP\".\"STOP\","
  "\"RIDERSHIP\".\"SCHEDULE\","
  "\"RIDERSHIP\".\"TIME\","
  "\"RIDERSHIP\".\"BOARD\","
  "\"RIDERSHIP\".\"ALIGHT\","
  "\"RIDERSHIP\".\"LOAD\","
  "\"RIDERSHIP\".\"FACTOR\""
  " FROM \"RIDERSHIP\""
  " LEFT JOIN \"STOP\" AS \"STOP\" ON \"STOP\".\"STOP\"=\"RIDERSHIP\".\"STOP\""
  " ";

  const char access::object_traits< ::pio::Ridership >::erase_query_statement[] =
  "DELETE FROM \"RIDERSHIP\""
  " ";

  const char access::object_traits< ::pio::Ridership >::table_name[] =
  "\"RIDERSHIP\"";

  void access::object_traits< ::pio::Ridership >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Ridership >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Ridership >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Ridership >::pointer_type
  access::object_traits< ::pio::Ridership >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Ridership >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Ridership >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Ridership >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Ridership >::object_type >
  access::object_traits< ::pio::Ridership >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Ridership >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Ridership >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"RIDERSHIP\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"RIDERSHIP\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"MODE\" INTEGER NOT NULL,\n"
                      "  \"ROUTE\" INTEGER NOT NULL,\n"
                      "  \"RUN\" INTEGER NOT NULL,\n"
                      "  \"STOP\" INTEGER,\n"
                      "  \"SCHEDULE\" REAL,\n"
                      "  \"TIME\" REAL,\n"
                      "  \"BOARD\" INTEGER NOT NULL,\n"
                      "  \"ALIGHT\" INTEGER NOT NULL,\n"
                      "  \"LOAD\" INTEGER NOT NULL,\n"
                      "  \"FACTOR\" REAL,\n"
                      "  CONSTRAINT \"STOP_fk\"\n"
                      "    FOREIGN KEY (\"STOP\")\n"
                      "    REFERENCES \"STOP\" (\"STOP\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Ridership_ (
    "",
    &access::object_traits< ::pio::Ridership >::create_schema);

  // Veh_Type
  //

  access::object_traits< ::pio::Veh_Type >::id_type
  access::object_traits< ::pio::Veh_Type >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.type_value,
        i.type_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // type
    //
    t[0UL] = false;

    // length
    //
    t[1UL] = false;

    // max_speed
    //
    t[2UL] = false;

    // max_accel
    //
    t[3UL] = false;

    // max_decel
    //
    t[4UL] = false;

    // op_cost
    //
    t[5UL] = false;

    // use
    //
    t[6UL] = false;

    // capacity
    //
    t[7UL] = false;

    // load
    //
    t[8UL] = false;

    // unload
    //
    t[9UL] = false;

    // method
    //
    t[10UL] = false;

    // min_dwell
    //
    t[11UL] = false;

    // max_dwell
    //
    t[12UL] = false;

    // subtype
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Veh_Type >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // type
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.type_value;
      b[n].is_null = &i.type_null;
      n++;
    }

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // max_speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_speed_value;
    b[n].is_null = &i.max_speed_null;
    n++;

    // max_accel
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_accel_value;
    b[n].is_null = &i.max_accel_null;
    n++;

    // max_decel
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_decel_value;
    b[n].is_null = &i.max_decel_null;
    n++;

    // op_cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.op_cost_value;
    b[n].is_null = &i.op_cost_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // capacity
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.capacity_value;
    b[n].is_null = &i.capacity_null;
    n++;

    // load
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.load_value;
    b[n].is_null = &i.load_null;
    n++;

    // unload
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.unload_value;
    b[n].is_null = &i.unload_null;
    n++;

    // method
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.method_value;
    b[n].is_null = &i.method_null;
    n++;

    // min_dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_dwell_value;
    b[n].is_null = &i.min_dwell_null;
    n++;

    // max_dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_dwell_value;
    b[n].is_null = &i.max_dwell_null;
    n++;

    // subtype
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subtype_value;
    b[n].is_null = &i.subtype_null;
    n++;
  }

  void access::object_traits< ::pio::Veh_Type >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // type
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // max_speed
    //
    {
      double const& v =
        o.max_speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_speed_value,
        is_null,
        v);
      i.max_speed_null = is_null;
    }

    // max_accel
    //
    {
      double const& v =
        o.max_accel;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_accel_value,
        is_null,
        v);
      i.max_accel_null = is_null;
    }

    // max_decel
    //
    {
      double const& v =
        o.max_decel;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_decel_value,
        is_null,
        v);
      i.max_decel_null = is_null;
    }

    // op_cost
    //
    {
      double const& v =
        o.op_cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.op_cost_value,
        is_null,
        v);
      i.op_cost_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // capacity
    //
    {
      int const& v =
        o.capacity;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.capacity_value,
        is_null,
        v);
      i.capacity_null = is_null;
    }

    // load
    //
    {
      double const& v =
        o.load;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.load_value,
        is_null,
        v);
      i.load_null = is_null;
    }

    // unload
    //
    {
      double const& v =
        o.unload;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.unload_value,
        is_null,
        v);
      i.unload_null = is_null;
    }

    // method
    //
    {
      int const& v =
        o.method;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.method_value,
        is_null,
        v);
      i.method_null = is_null;
    }

    // min_dwell
    //
    {
      double const& v =
        o.min_dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_dwell_value,
        is_null,
        v);
      i.min_dwell_null = is_null;
    }

    // max_dwell
    //
    {
      double const& v =
        o.max_dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_dwell_value,
        is_null,
        v);
      i.max_dwell_null = is_null;
    }

    // subtype
    //
    {
      int const& v =
        o.subtype;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subtype_value,
        is_null,
        v);
      i.subtype_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Veh_Type >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // max_speed
    //
    {
      double& v =
        o.max_speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_speed_value,
        i.max_speed_null);
    }

    // max_accel
    //
    {
      double& v =
        o.max_accel;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_accel_value,
        i.max_accel_null);
    }

    // max_decel
    //
    {
      double& v =
        o.max_decel;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_decel_value,
        i.max_decel_null);
    }

    // op_cost
    //
    {
      double& v =
        o.op_cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.op_cost_value,
        i.op_cost_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // capacity
    //
    {
      int& v =
        o.capacity;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.capacity_value,
        i.capacity_null);
    }

    // load
    //
    {
      double& v =
        o.load;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.load_value,
        i.load_null);
    }

    // unload
    //
    {
      double& v =
        o.unload;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.unload_value,
        i.unload_null);
    }

    // method
    //
    {
      int& v =
        o.method;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.method_value,
        i.method_null);
    }

    // min_dwell
    //
    {
      double& v =
        o.min_dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_dwell_value,
        i.min_dwell_null);
    }

    // max_dwell
    //
    {
      double& v =
        o.max_dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_dwell_value,
        i.max_dwell_null);
    }

    // subtype
    //
    {
      int& v =
        o.subtype;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subtype_value,
        i.subtype_null);
    }
  }

  void access::object_traits< ::pio::Veh_Type >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Veh_Type >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Veh_Type >::persist_statement[] =
  "INSERT INTO \"VEH_TYPE\" ("
  "\"TYPE\","
  "\"LENGTH\","
  "\"MAX_SPEED\","
  "\"MAX_ACCEL\","
  "\"MAX_DECEL\","
  "\"OP_COST\","
  "\"USE\","
  "\"CAPACITY\","
  "\"LOAD\","
  "\"UNLOAD\","
  "\"METHOD\","
  "\"MIN_DWELL\","
  "\"MAX_DWELL\","
  "\"SUBTYPE\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Veh_Type >::find_statement[] =
  "SELECT "
  "\"VEH_TYPE\".\"TYPE\","
  "\"VEH_TYPE\".\"LENGTH\","
  "\"VEH_TYPE\".\"MAX_SPEED\","
  "\"VEH_TYPE\".\"MAX_ACCEL\","
  "\"VEH_TYPE\".\"MAX_DECEL\","
  "\"VEH_TYPE\".\"OP_COST\","
  "\"VEH_TYPE\".\"USE\","
  "\"VEH_TYPE\".\"CAPACITY\","
  "\"VEH_TYPE\".\"LOAD\","
  "\"VEH_TYPE\".\"UNLOAD\","
  "\"VEH_TYPE\".\"METHOD\","
  "\"VEH_TYPE\".\"MIN_DWELL\","
  "\"VEH_TYPE\".\"MAX_DWELL\","
  "\"VEH_TYPE\".\"SUBTYPE\""
  " FROM \"VEH_TYPE\""
  " WHERE \"VEH_TYPE\".\"TYPE\"=?";

  const char access::object_traits< ::pio::Veh_Type >::update_statement[] =
  "UPDATE \"VEH_TYPE\" SET "
  "\"LENGTH\"=?,"
  "\"MAX_SPEED\"=?,"
  "\"MAX_ACCEL\"=?,"
  "\"MAX_DECEL\"=?,"
  "\"OP_COST\"=?,"
  "\"USE\"=?,"
  "\"CAPACITY\"=?,"
  "\"LOAD\"=?,"
  "\"UNLOAD\"=?,"
  "\"METHOD\"=?,"
  "\"MIN_DWELL\"=?,"
  "\"MAX_DWELL\"=?,"
  "\"SUBTYPE\"=?"
  " WHERE \"TYPE\"=?";

  const char access::object_traits< ::pio::Veh_Type >::erase_statement[] =
  "DELETE FROM \"VEH_TYPE\""
  " WHERE \"TYPE\"=?";

  const char access::object_traits< ::pio::Veh_Type >::query_statement[] =
  "SELECT "
  "\"VEH_TYPE\".\"TYPE\","
  "\"VEH_TYPE\".\"LENGTH\","
  "\"VEH_TYPE\".\"MAX_SPEED\","
  "\"VEH_TYPE\".\"MAX_ACCEL\","
  "\"VEH_TYPE\".\"MAX_DECEL\","
  "\"VEH_TYPE\".\"OP_COST\","
  "\"VEH_TYPE\".\"USE\","
  "\"VEH_TYPE\".\"CAPACITY\","
  "\"VEH_TYPE\".\"LOAD\","
  "\"VEH_TYPE\".\"UNLOAD\","
  "\"VEH_TYPE\".\"METHOD\","
  "\"VEH_TYPE\".\"MIN_DWELL\","
  "\"VEH_TYPE\".\"MAX_DWELL\","
  "\"VEH_TYPE\".\"SUBTYPE\""
  " FROM \"VEH_TYPE\""
  " ";

  const char access::object_traits< ::pio::Veh_Type >::erase_query_statement[] =
  "DELETE FROM \"VEH_TYPE\""
  " ";

  const char access::object_traits< ::pio::Veh_Type >::table_name[] =
  "\"VEH_TYPE\"";

  void access::object_traits< ::pio::Veh_Type >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Veh_Type >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.type);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Veh_Type >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Veh_Type >::pointer_type
  access::object_traits< ::pio::Veh_Type >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.type);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Veh_Type >::object_type >
  access::object_traits< ::pio::Veh_Type >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Veh_Type >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Veh_Type >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"VEH_TYPE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"VEH_TYPE\" (\n"
                      "  \"TYPE\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"LENGTH\" REAL,\n"
                      "  \"MAX_SPEED\" REAL,\n"
                      "  \"MAX_ACCEL\" REAL,\n"
                      "  \"MAX_DECEL\" REAL,\n"
                      "  \"OP_COST\" REAL,\n"
                      "  \"USE\" INTEGER NOT NULL,\n"
                      "  \"CAPACITY\" INTEGER NOT NULL,\n"
                      "  \"LOAD\" REAL,\n"
                      "  \"UNLOAD\" REAL,\n"
                      "  \"METHOD\" INTEGER NOT NULL,\n"
                      "  \"MIN_DWELL\" REAL,\n"
                      "  \"MAX_DWELL\" REAL,\n"
                      "  \"SUBTYPE\" INTEGER NOT NULL)");
          db.execute ("CREATE INDEX \"VEH_TYPE_TYPE_i\"\n"
                      "  ON \"VEH_TYPE\" (\"TYPE\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Veh_Type_ (
    "",
    &access::object_traits< ::pio::Veh_Type >::create_schema);

  // Vehicle
  //

  access::object_traits< ::pio::Vehicle >::id_type
  access::object_traits< ::pio::Vehicle >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Vehicle >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // vehicle
    //
    t[2UL] = false;

    // parking
    //
    t[3UL] = false;

    // type
    //
    t[4UL] = false;

    // subtype
    //
    t[5UL] = false;

    // partition
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Vehicle >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // vehicle
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.vehicle_value;
    b[n].is_null = &i.vehicle_null;
    n++;

    // parking
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.parking_value;
    b[n].is_null = &i.parking_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // subtype
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subtype_value;
    b[n].is_null = &i.subtype_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;
  }

  void access::object_traits< ::pio::Vehicle >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Vehicle >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // vehicle
    //
    {
      int const& v =
        o.vehicle;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.vehicle_value,
        is_null,
        v);
      i.vehicle_null = is_null;
    }

    // parking
    //
    {
      ::std::tr1::shared_ptr< ::pio::Parking > const& v =
        o.parking;

      typedef object_traits< ::pio::Parking > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Parking > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.parking_value,
          is_null,
          id);
        i.parking_null = is_null;
      }
      else
        i.parking_null = true;
    }

    // type
    //
    {
      ::std::tr1::shared_ptr< ::pio::Veh_Type > const& v =
        o.type;

      typedef object_traits< ::pio::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Veh_Type > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.type_value,
          is_null,
          id);
        i.type_null = is_null;
      }
      else
        i.type_null = true;
    }

    // subtype
    //
    {
      int const& v =
        o.subtype;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subtype_value,
        is_null,
        v);
      i.subtype_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Vehicle >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // vehicle
    //
    {
      int& v =
        o.vehicle;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.vehicle_value,
        i.vehicle_null);
    }

    // parking
    //
    {
      ::std::tr1::shared_ptr< ::pio::Parking >& v =
        o.parking;

      typedef object_traits< ::pio::Parking > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Parking > > ptr_traits;

      if (i.parking_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.parking_value,
          i.parking_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      ::std::tr1::shared_ptr< ::pio::Veh_Type >& v =
        o.type;

      typedef object_traits< ::pio::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Veh_Type > > ptr_traits;

      if (i.type_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.type_value,
          i.type_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // subtype
    //
    {
      int& v =
        o.subtype;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subtype_value,
        i.subtype_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }
  }

  void access::object_traits< ::pio::Vehicle >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Vehicle >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Vehicle >::persist_statement[] =
  "INSERT INTO \"VEHICLE\" ("
  "\"auto_id\","
  "\"HHOLD\","
  "\"VEHICLE\","
  "\"PARKING\","
  "\"TYPE\","
  "\"SUBTYPE\","
  "\"PARTITION\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Vehicle >::find_statement[] =
  "SELECT "
  "\"VEHICLE\".\"auto_id\","
  "\"VEHICLE\".\"HHOLD\","
  "\"VEHICLE\".\"VEHICLE\","
  "\"VEHICLE\".\"PARKING\","
  "\"VEHICLE\".\"TYPE\","
  "\"VEHICLE\".\"SUBTYPE\","
  "\"VEHICLE\".\"PARTITION\""
  " FROM \"VEHICLE\""
  " WHERE \"VEHICLE\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Vehicle >::update_statement[] =
  "UPDATE \"VEHICLE\" SET "
  "\"HHOLD\"=?,"
  "\"VEHICLE\"=?,"
  "\"PARKING\"=?,"
  "\"TYPE\"=?,"
  "\"SUBTYPE\"=?,"
  "\"PARTITION\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Vehicle >::erase_statement[] =
  "DELETE FROM \"VEHICLE\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Vehicle >::query_statement[] =
  "SELECT "
  "\"VEHICLE\".\"auto_id\","
  "\"VEHICLE\".\"HHOLD\","
  "\"VEHICLE\".\"VEHICLE\","
  "\"VEHICLE\".\"PARKING\","
  "\"VEHICLE\".\"TYPE\","
  "\"VEHICLE\".\"SUBTYPE\","
  "\"VEHICLE\".\"PARTITION\""
  " FROM \"VEHICLE\""
  " LEFT JOIN \"PARKING\" AS \"PARKING\" ON \"PARKING\".\"PARKING\"=\"VEHICLE\".\"PARKING\""
  " LEFT JOIN \"VEH_TYPE\" AS \"TYPE\" ON \"TYPE\".\"TYPE\"=\"VEHICLE\".\"TYPE\""
  " ";

  const char access::object_traits< ::pio::Vehicle >::erase_query_statement[] =
  "DELETE FROM \"VEHICLE\""
  " ";

  const char access::object_traits< ::pio::Vehicle >::table_name[] =
  "\"VEHICLE\"";

  void access::object_traits< ::pio::Vehicle >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Vehicle >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Vehicle >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Vehicle >::pointer_type
  access::object_traits< ::pio::Vehicle >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Vehicle >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Vehicle >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Vehicle >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Vehicle >::object_type >
  access::object_traits< ::pio::Vehicle >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Vehicle >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Vehicle >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"VEHICLE\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"VEHICLE\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"HHOLD\" INTEGER NOT NULL,\n"
                      "  \"VEHICLE\" INTEGER NOT NULL,\n"
                      "  \"PARKING\" INTEGER,\n"
                      "  \"TYPE\" INTEGER,\n"
                      "  \"SUBTYPE\" INTEGER NOT NULL,\n"
                      "  \"PARTITION\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"PARKING_fk\"\n"
                      "    FOREIGN KEY (\"PARKING\")\n"
                      "    REFERENCES \"PARKING\" (\"PARKING\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"TYPE_fk\"\n"
                      "    FOREIGN KEY (\"TYPE\")\n"
                      "    REFERENCES \"VEH_TYPE\" (\"TYPE\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Vehicle_ (
    "",
    &access::object_traits< ::pio::Vehicle >::create_schema);

  // Trip
  //

  access::object_traits< ::pio::Trip >::id_type
  access::object_traits< ::pio::Trip >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Trip >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // start
    //
    t[5UL] = false;

    // end
    //
    t[6UL] = false;

    // duration
    //
    t[7UL] = false;

    // origin
    //
    t[8UL] = false;

    // destination
    //
    t[9UL] = false;

    // purpose
    //
    t[10UL] = false;

    // mode
    //
    t[11UL] = false;

    // constraint
    //
    t[12UL] = false;

    // priority
    //
    t[13UL] = false;

    // vehicle
    //
    t[14UL] = false;

    // passengers
    //
    t[15UL] = false;

    // type
    //
    t[16UL] = false;

    // partition
    //
    t[17UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Trip >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // duration
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.duration_value;
    b[n].is_null = &i.duration_null;
    n++;

    // origin
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.origin_value;
    b[n].is_null = &i.origin_null;
    n++;

    // destination
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.destination_value;
    b[n].is_null = &i.destination_null;
    n++;

    // purpose
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.purpose_value;
    b[n].is_null = &i.purpose_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // constraint
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.constraint_value;
    b[n].is_null = &i.constraint_null;
    n++;

    // priority
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.priority_value;
    b[n].is_null = &i.priority_null;
    n++;

    // vehicle
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.vehicle_value;
    b[n].is_null = &i.vehicle_null;
    n++;

    // passengers
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.passengers_value;
    b[n].is_null = &i.passengers_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;
  }

  void access::object_traits< ::pio::Trip >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Trip >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // duration
    //
    {
      double const& v =
        o.duration;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.duration_value,
        is_null,
        v);
      i.duration_null = is_null;
    }

    // origin
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location > const& v =
        o.origin;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.origin_value,
          is_null,
          id);
        i.origin_null = is_null;
      }
      else
        i.origin_null = true;
    }

    // destination
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location > const& v =
        o.destination;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.destination_value,
          is_null,
          id);
        i.destination_null = is_null;
      }
      else
        i.destination_null = true;
    }

    // purpose
    //
    {
      int const& v =
        o.purpose;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.purpose_value,
        is_null,
        v);
      i.purpose_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // constraint
    //
    {
      int const& v =
        o.constraint;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.constraint_value,
        is_null,
        v);
      i.constraint_null = is_null;
    }

    // priority
    //
    {
      int const& v =
        o.priority;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.priority_value,
        is_null,
        v);
      i.priority_null = is_null;
    }

    // vehicle
    //
    {
      int const& v =
        o.vehicle;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.vehicle_value,
        is_null,
        v);
      i.vehicle_null = is_null;
    }

    // passengers
    //
    {
      int const& v =
        o.passengers;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.passengers_value,
        is_null,
        v);
      i.passengers_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Trip >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // duration
    //
    {
      double& v =
        o.duration;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.duration_value,
        i.duration_null);
    }

    // origin
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location >& v =
        o.origin;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      if (i.origin_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.origin_value,
          i.origin_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // destination
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location >& v =
        o.destination;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      if (i.destination_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.destination_value,
          i.destination_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // purpose
    //
    {
      int& v =
        o.purpose;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.purpose_value,
        i.purpose_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // constraint
    //
    {
      int& v =
        o.constraint;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.constraint_value,
        i.constraint_null);
    }

    // priority
    //
    {
      int& v =
        o.priority;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.priority_value,
        i.priority_null);
    }

    // vehicle
    //
    {
      int& v =
        o.vehicle;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.vehicle_value,
        i.vehicle_null);
    }

    // passengers
    //
    {
      int& v =
        o.passengers;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.passengers_value,
        i.passengers_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }
  }

  void access::object_traits< ::pio::Trip >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Trip >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Trip >::persist_statement[] =
  "INSERT INTO \"TRIP\" ("
  "\"auto_id\","
  "\"HHOLD\","
  "\"PERSON\","
  "\"TOUR\","
  "\"TRIP\","
  "\"START\","
  "\"END\","
  "\"DURATION\","
  "\"ORIGIN\","
  "\"DESTINATION\","
  "\"PURPOSE\","
  "\"MODE\","
  "\"CONSTRAINT\","
  "\"PRIORITY\","
  "\"VEHICLE\","
  "\"PASSENGERS\","
  "\"TYPE\","
  "\"PARTITION\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Trip >::find_statement[] =
  "SELECT "
  "\"TRIP\".\"auto_id\","
  "\"TRIP\".\"HHOLD\","
  "\"TRIP\".\"PERSON\","
  "\"TRIP\".\"TOUR\","
  "\"TRIP\".\"TRIP\","
  "\"TRIP\".\"START\","
  "\"TRIP\".\"END\","
  "\"TRIP\".\"DURATION\","
  "\"TRIP\".\"ORIGIN\","
  "\"TRIP\".\"DESTINATION\","
  "\"TRIP\".\"PURPOSE\","
  "\"TRIP\".\"MODE\","
  "\"TRIP\".\"CONSTRAINT\","
  "\"TRIP\".\"PRIORITY\","
  "\"TRIP\".\"VEHICLE\","
  "\"TRIP\".\"PASSENGERS\","
  "\"TRIP\".\"TYPE\","
  "\"TRIP\".\"PARTITION\""
  " FROM \"TRIP\""
  " WHERE \"TRIP\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Trip >::update_statement[] =
  "UPDATE \"TRIP\" SET "
  "\"HHOLD\"=?,"
  "\"PERSON\"=?,"
  "\"TOUR\"=?,"
  "\"TRIP\"=?,"
  "\"START\"=?,"
  "\"END\"=?,"
  "\"DURATION\"=?,"
  "\"ORIGIN\"=?,"
  "\"DESTINATION\"=?,"
  "\"PURPOSE\"=?,"
  "\"MODE\"=?,"
  "\"CONSTRAINT\"=?,"
  "\"PRIORITY\"=?,"
  "\"VEHICLE\"=?,"
  "\"PASSENGERS\"=?,"
  "\"TYPE\"=?,"
  "\"PARTITION\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Trip >::erase_statement[] =
  "DELETE FROM \"TRIP\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Trip >::query_statement[] =
  "SELECT "
  "\"TRIP\".\"auto_id\","
  "\"TRIP\".\"HHOLD\","
  "\"TRIP\".\"PERSON\","
  "\"TRIP\".\"TOUR\","
  "\"TRIP\".\"TRIP\","
  "\"TRIP\".\"START\","
  "\"TRIP\".\"END\","
  "\"TRIP\".\"DURATION\","
  "\"TRIP\".\"ORIGIN\","
  "\"TRIP\".\"DESTINATION\","
  "\"TRIP\".\"PURPOSE\","
  "\"TRIP\".\"MODE\","
  "\"TRIP\".\"CONSTRAINT\","
  "\"TRIP\".\"PRIORITY\","
  "\"TRIP\".\"VEHICLE\","
  "\"TRIP\".\"PASSENGERS\","
  "\"TRIP\".\"TYPE\","
  "\"TRIP\".\"PARTITION\""
  " FROM \"TRIP\""
  " LEFT JOIN \"LOCATION\" AS \"ORIGIN\" ON \"ORIGIN\".\"LOCATION\"=\"TRIP\".\"ORIGIN\""
  " LEFT JOIN \"LOCATION\" AS \"DESTINATION\" ON \"DESTINATION\".\"LOCATION\"=\"TRIP\".\"DESTINATION\""
  " ";

  const char access::object_traits< ::pio::Trip >::erase_query_statement[] =
  "DELETE FROM \"TRIP\""
  " ";

  const char access::object_traits< ::pio::Trip >::table_name[] =
  "\"TRIP\"";

  void access::object_traits< ::pio::Trip >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Trip >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Trip >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Trip >::pointer_type
  access::object_traits< ::pio::Trip >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Trip >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Trip >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Trip >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Trip >::object_type >
  access::object_traits< ::pio::Trip >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Trip >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Trip >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"TRIP\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"TRIP\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"HHOLD\" INTEGER NOT NULL,\n"
                      "  \"PERSON\" INTEGER NOT NULL,\n"
                      "  \"TOUR\" INTEGER NOT NULL,\n"
                      "  \"TRIP\" INTEGER NOT NULL,\n"
                      "  \"START\" REAL,\n"
                      "  \"END\" REAL,\n"
                      "  \"DURATION\" REAL,\n"
                      "  \"ORIGIN\" INTEGER,\n"
                      "  \"DESTINATION\" INTEGER,\n"
                      "  \"PURPOSE\" INTEGER NOT NULL,\n"
                      "  \"MODE\" INTEGER NOT NULL,\n"
                      "  \"CONSTRAINT\" INTEGER NOT NULL,\n"
                      "  \"PRIORITY\" INTEGER NOT NULL,\n"
                      "  \"VEHICLE\" INTEGER NOT NULL,\n"
                      "  \"PASSENGERS\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"PARTITION\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"ORIGIN_fk\"\n"
                      "    FOREIGN KEY (\"ORIGIN\")\n"
                      "    REFERENCES \"LOCATION\" (\"LOCATION\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"DESTINATION_fk\"\n"
                      "    FOREIGN KEY (\"DESTINATION\")\n"
                      "    REFERENCES \"LOCATION\" (\"LOCATION\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Trip_ (
    "",
    &access::object_traits< ::pio::Trip >::create_schema);

  // Problem
  //

  access::object_traits< ::pio::Problem >::id_type
  access::object_traits< ::pio::Problem >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.problem_value,
        i.problem_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Problem >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // problem
    //
    t[0UL] = false;

    // time
    //
    t[1UL] = false;

    // link
    //
    t[2UL] = false;

    // dir
    //
    t[3UL] = false;

    // lane
    //
    t[4UL] = false;

    // offset
    //
    t[5UL] = false;

    // route
    //
    t[6UL] = false;

    // survey
    //
    t[7UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Problem >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // problem
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.problem_value;
      b[n].is_null = &i.problem_null;
      n++;
    }

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lane
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lane_value;
    b[n].is_null = &i.lane_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // survey
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.survey_value;
    b[n].is_null = &i.survey_null;
    n++;
  }

  void access::object_traits< ::pio::Problem >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Problem >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // problem
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.problem;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.problem_value,
        is_null,
        v);
      i.problem_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lane
    //
    {
      int const& v =
        o.lane;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lane_value,
        is_null,
        v);
      i.lane_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // survey
    //
    {
      int const& v =
        o.survey;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.survey_value,
        is_null,
        v);
      i.survey_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Problem >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // problem
    //
    {
      int& v =
        o.problem;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.problem_value,
        i.problem_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lane
    //
    {
      int& v =
        o.lane;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lane_value,
        i.lane_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // survey
    //
    {
      int& v =
        o.survey;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.survey_value,
        i.survey_null);
    }
  }

  void access::object_traits< ::pio::Problem >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Problem >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Problem >::persist_statement[] =
  "INSERT INTO \"PROBLEM\" ("
  "\"PROBLEM\","
  "\"TIME\","
  "\"LINK\","
  "\"DIR\","
  "\"LANE\","
  "\"OFFSET\","
  "\"ROUTE\","
  "\"SURVEY\")"
  " VALUES (?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Problem >::find_statement[] =
  "SELECT "
  "\"PROBLEM\".\"PROBLEM\","
  "\"PROBLEM\".\"TIME\","
  "\"PROBLEM\".\"LINK\","
  "\"PROBLEM\".\"DIR\","
  "\"PROBLEM\".\"LANE\","
  "\"PROBLEM\".\"OFFSET\","
  "\"PROBLEM\".\"ROUTE\","
  "\"PROBLEM\".\"SURVEY\""
  " FROM \"PROBLEM\""
  " WHERE \"PROBLEM\".\"PROBLEM\"=?";

  const char access::object_traits< ::pio::Problem >::update_statement[] =
  "UPDATE \"PROBLEM\" SET "
  "\"TIME\"=?,"
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"LANE\"=?,"
  "\"OFFSET\"=?,"
  "\"ROUTE\"=?,"
  "\"SURVEY\"=?"
  " WHERE \"PROBLEM\"=?";

  const char access::object_traits< ::pio::Problem >::erase_statement[] =
  "DELETE FROM \"PROBLEM\""
  " WHERE \"PROBLEM\"=?";

  const char access::object_traits< ::pio::Problem >::query_statement[] =
  "SELECT "
  "\"PROBLEM\".\"PROBLEM\","
  "\"PROBLEM\".\"TIME\","
  "\"PROBLEM\".\"LINK\","
  "\"PROBLEM\".\"DIR\","
  "\"PROBLEM\".\"LANE\","
  "\"PROBLEM\".\"OFFSET\","
  "\"PROBLEM\".\"ROUTE\","
  "\"PROBLEM\".\"SURVEY\""
  " FROM \"PROBLEM\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"PROBLEM\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Problem >::erase_query_statement[] =
  "DELETE FROM \"PROBLEM\""
  " ";

  const char access::object_traits< ::pio::Problem >::table_name[] =
  "\"PROBLEM\"";

  void access::object_traits< ::pio::Problem >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Problem >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.problem);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Problem >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Problem >::pointer_type
  access::object_traits< ::pio::Problem >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Problem >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Problem >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.problem);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Problem >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Problem >::object_type >
  access::object_traits< ::pio::Problem >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Problem >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Problem >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"PROBLEM\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"PROBLEM\" (\n"
                      "  \"PROBLEM\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"TIME\" REAL,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"LANE\" INTEGER NOT NULL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  \"ROUTE\" INTEGER NOT NULL,\n"
                      "  \"SURVEY\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"PROBLEM_PROBLEM_i\"\n"
                      "  ON \"PROBLEM\" (\"PROBLEM\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Problem_ (
    "",
    &access::object_traits< ::pio::Problem >::create_schema);

  // Plan
  //

  access::object_traits< ::pio::Plan >::id_type
  access::object_traits< ::pio::Plan >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Plan >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // depart
    //
    t[1UL] = false;

    // arrive
    //
    t[2UL] = false;

    // activity
    //
    t[3UL] = false;

    // walk
    //
    t[4UL] = false;

    // drive
    //
    t[5UL] = false;

    // transit
    //
    t[6UL] = false;

    // wait
    //
    t[7UL] = false;

    // other
    //
    t[8UL] = false;

    // length
    //
    t[9UL] = false;

    // cost
    //
    t[10UL] = false;

    // impedance
    //
    t[11UL] = false;

    // leg_mode
    //
    t[12UL] = false;

    // leg_type
    //
    t[13UL] = false;

    // leg_id
    //
    t[14UL] = false;

    // leg_time
    //
    t[15UL] = false;

    // leg_length
    //
    t[16UL] = false;

    // leg_cost
    //
    t[17UL] = false;

    // leg_imp
    //
    t[18UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Plan >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // depart
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.depart_value;
    b[n].is_null = &i.depart_null;
    n++;

    // arrive
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.arrive_value;
    b[n].is_null = &i.arrive_null;
    n++;

    // activity
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.activity_value;
    b[n].is_null = &i.activity_null;
    n++;

    // walk
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.walk_value;
    b[n].is_null = &i.walk_null;
    n++;

    // drive
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.drive_value;
    b[n].is_null = &i.drive_null;
    n++;

    // transit
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.transit_value;
    b[n].is_null = &i.transit_null;
    n++;

    // wait
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.wait_value;
    b[n].is_null = &i.wait_null;
    n++;

    // other
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.other_value;
    b[n].is_null = &i.other_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.cost_value;
    b[n].is_null = &i.cost_null;
    n++;

    // impedance
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.impedance_value;
    b[n].is_null = &i.impedance_null;
    n++;

    // leg_mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.leg_mode_value;
    b[n].is_null = &i.leg_mode_null;
    n++;

    // leg_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.leg_type_value;
    b[n].is_null = &i.leg_type_null;
    n++;

    // leg_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.leg_id_value;
    b[n].is_null = &i.leg_id_null;
    n++;

    // leg_time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.leg_time_value;
    b[n].is_null = &i.leg_time_null;
    n++;

    // leg_length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.leg_length_value;
    b[n].is_null = &i.leg_length_null;
    n++;

    // leg_cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.leg_cost_value;
    b[n].is_null = &i.leg_cost_null;
    n++;

    // leg_imp
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.leg_imp_value;
    b[n].is_null = &i.leg_imp_null;
    n++;
  }

  void access::object_traits< ::pio::Plan >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Plan >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // depart
    //
    {
      double const& v =
        o.depart;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.depart_value,
        is_null,
        v);
      i.depart_null = is_null;
    }

    // arrive
    //
    {
      double const& v =
        o.arrive;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.arrive_value,
        is_null,
        v);
      i.arrive_null = is_null;
    }

    // activity
    //
    {
      double const& v =
        o.activity;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.activity_value,
        is_null,
        v);
      i.activity_null = is_null;
    }

    // walk
    //
    {
      double const& v =
        o.walk;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.walk_value,
        is_null,
        v);
      i.walk_null = is_null;
    }

    // drive
    //
    {
      double const& v =
        o.drive;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.drive_value,
        is_null,
        v);
      i.drive_null = is_null;
    }

    // transit
    //
    {
      double const& v =
        o.transit;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.transit_value,
        is_null,
        v);
      i.transit_null = is_null;
    }

    // wait
    //
    {
      double const& v =
        o.wait;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.wait_value,
        is_null,
        v);
      i.wait_null = is_null;
    }

    // other
    //
    {
      double const& v =
        o.other;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.other_value,
        is_null,
        v);
      i.other_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // cost
    //
    {
      double const& v =
        o.cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.cost_value,
        is_null,
        v);
      i.cost_null = is_null;
    }

    // impedance
    //
    {
      int const& v =
        o.impedance;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.impedance_value,
        is_null,
        v);
      i.impedance_null = is_null;
    }

    // leg_mode
    //
    {
      int const& v =
        o.leg_mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.leg_mode_value,
        is_null,
        v);
      i.leg_mode_null = is_null;
    }

    // leg_type
    //
    {
      int const& v =
        o.leg_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.leg_type_value,
        is_null,
        v);
      i.leg_type_null = is_null;
    }

    // leg_id
    //
    {
      int const& v =
        o.leg_id;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.leg_id_value,
        is_null,
        v);
      i.leg_id_null = is_null;
    }

    // leg_time
    //
    {
      double const& v =
        o.leg_time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.leg_time_value,
        is_null,
        v);
      i.leg_time_null = is_null;
    }

    // leg_length
    //
    {
      double const& v =
        o.leg_length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.leg_length_value,
        is_null,
        v);
      i.leg_length_null = is_null;
    }

    // leg_cost
    //
    {
      double const& v =
        o.leg_cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.leg_cost_value,
        is_null,
        v);
      i.leg_cost_null = is_null;
    }

    // leg_imp
    //
    {
      int const& v =
        o.leg_imp;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.leg_imp_value,
        is_null,
        v);
      i.leg_imp_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Plan >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // depart
    //
    {
      double& v =
        o.depart;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.depart_value,
        i.depart_null);
    }

    // arrive
    //
    {
      double& v =
        o.arrive;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.arrive_value,
        i.arrive_null);
    }

    // activity
    //
    {
      double& v =
        o.activity;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.activity_value,
        i.activity_null);
    }

    // walk
    //
    {
      double& v =
        o.walk;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.walk_value,
        i.walk_null);
    }

    // drive
    //
    {
      double& v =
        o.drive;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.drive_value,
        i.drive_null);
    }

    // transit
    //
    {
      double& v =
        o.transit;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.transit_value,
        i.transit_null);
    }

    // wait
    //
    {
      double& v =
        o.wait;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.wait_value,
        i.wait_null);
    }

    // other
    //
    {
      double& v =
        o.other;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.other_value,
        i.other_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // cost
    //
    {
      double& v =
        o.cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.cost_value,
        i.cost_null);
    }

    // impedance
    //
    {
      int& v =
        o.impedance;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.impedance_value,
        i.impedance_null);
    }

    // leg_mode
    //
    {
      int& v =
        o.leg_mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.leg_mode_value,
        i.leg_mode_null);
    }

    // leg_type
    //
    {
      int& v =
        o.leg_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.leg_type_value,
        i.leg_type_null);
    }

    // leg_id
    //
    {
      int& v =
        o.leg_id;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.leg_id_value,
        i.leg_id_null);
    }

    // leg_time
    //
    {
      double& v =
        o.leg_time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.leg_time_value,
        i.leg_time_null);
    }

    // leg_length
    //
    {
      double& v =
        o.leg_length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.leg_length_value,
        i.leg_length_null);
    }

    // leg_cost
    //
    {
      double& v =
        o.leg_cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.leg_cost_value,
        i.leg_cost_null);
    }

    // leg_imp
    //
    {
      int& v =
        o.leg_imp;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.leg_imp_value,
        i.leg_imp_null);
    }
  }

  void access::object_traits< ::pio::Plan >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Plan >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Plan >::persist_statement[] =
  "INSERT INTO \"PLAN\" ("
  "\"auto_id\","
  "\"DEPART\","
  "\"ARRIVE\","
  "\"ACTIVITY\","
  "\"WALK\","
  "\"DRIVE\","
  "\"TRANSIT\","
  "\"WAIT\","
  "\"OTHER\","
  "\"LENGTH\","
  "\"COST\","
  "\"IMPEDANCE\","
  "\"LEG_MODE\","
  "\"LEG_TYPE\","
  "\"LEG_ID\","
  "\"LEG_TIME\","
  "\"LEG_LENGTH\","
  "\"LEG_COST\","
  "\"LEG_IMP\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Plan >::find_statement[] =
  "SELECT "
  "\"PLAN\".\"auto_id\","
  "\"PLAN\".\"DEPART\","
  "\"PLAN\".\"ARRIVE\","
  "\"PLAN\".\"ACTIVITY\","
  "\"PLAN\".\"WALK\","
  "\"PLAN\".\"DRIVE\","
  "\"PLAN\".\"TRANSIT\","
  "\"PLAN\".\"WAIT\","
  "\"PLAN\".\"OTHER\","
  "\"PLAN\".\"LENGTH\","
  "\"PLAN\".\"COST\","
  "\"PLAN\".\"IMPEDANCE\","
  "\"PLAN\".\"LEG_MODE\","
  "\"PLAN\".\"LEG_TYPE\","
  "\"PLAN\".\"LEG_ID\","
  "\"PLAN\".\"LEG_TIME\","
  "\"PLAN\".\"LEG_LENGTH\","
  "\"PLAN\".\"LEG_COST\","
  "\"PLAN\".\"LEG_IMP\""
  " FROM \"PLAN\""
  " WHERE \"PLAN\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Plan >::update_statement[] =
  "UPDATE \"PLAN\" SET "
  "\"DEPART\"=?,"
  "\"ARRIVE\"=?,"
  "\"ACTIVITY\"=?,"
  "\"WALK\"=?,"
  "\"DRIVE\"=?,"
  "\"TRANSIT\"=?,"
  "\"WAIT\"=?,"
  "\"OTHER\"=?,"
  "\"LENGTH\"=?,"
  "\"COST\"=?,"
  "\"IMPEDANCE\"=?,"
  "\"LEG_MODE\"=?,"
  "\"LEG_TYPE\"=?,"
  "\"LEG_ID\"=?,"
  "\"LEG_TIME\"=?,"
  "\"LEG_LENGTH\"=?,"
  "\"LEG_COST\"=?,"
  "\"LEG_IMP\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Plan >::erase_statement[] =
  "DELETE FROM \"PLAN\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Plan >::query_statement[] =
  "SELECT "
  "\"PLAN\".\"auto_id\","
  "\"PLAN\".\"DEPART\","
  "\"PLAN\".\"ARRIVE\","
  "\"PLAN\".\"ACTIVITY\","
  "\"PLAN\".\"WALK\","
  "\"PLAN\".\"DRIVE\","
  "\"PLAN\".\"TRANSIT\","
  "\"PLAN\".\"WAIT\","
  "\"PLAN\".\"OTHER\","
  "\"PLAN\".\"LENGTH\","
  "\"PLAN\".\"COST\","
  "\"PLAN\".\"IMPEDANCE\","
  "\"PLAN\".\"LEG_MODE\","
  "\"PLAN\".\"LEG_TYPE\","
  "\"PLAN\".\"LEG_ID\","
  "\"PLAN\".\"LEG_TIME\","
  "\"PLAN\".\"LEG_LENGTH\","
  "\"PLAN\".\"LEG_COST\","
  "\"PLAN\".\"LEG_IMP\""
  " FROM \"PLAN\""
  " ";

  const char access::object_traits< ::pio::Plan >::erase_query_statement[] =
  "DELETE FROM \"PLAN\""
  " ";

  const char access::object_traits< ::pio::Plan >::table_name[] =
  "\"PLAN\"";

  void access::object_traits< ::pio::Plan >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Plan >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Plan >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Plan >::pointer_type
  access::object_traits< ::pio::Plan >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Plan >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Plan >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Plan >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Plan >::object_type >
  access::object_traits< ::pio::Plan >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Plan >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Plan >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"PLAN\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"PLAN\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"DEPART\" REAL,\n"
                      "  \"ARRIVE\" REAL,\n"
                      "  \"ACTIVITY\" REAL,\n"
                      "  \"WALK\" REAL,\n"
                      "  \"DRIVE\" REAL,\n"
                      "  \"TRANSIT\" REAL,\n"
                      "  \"WAIT\" REAL,\n"
                      "  \"OTHER\" REAL,\n"
                      "  \"LENGTH\" REAL,\n"
                      "  \"COST\" REAL,\n"
                      "  \"IMPEDANCE\" INTEGER NOT NULL,\n"
                      "  \"LEG_MODE\" INTEGER NOT NULL,\n"
                      "  \"LEG_TYPE\" INTEGER NOT NULL,\n"
                      "  \"LEG_ID\" INTEGER NOT NULL,\n"
                      "  \"LEG_TIME\" REAL,\n"
                      "  \"LEG_LENGTH\" REAL,\n"
                      "  \"LEG_COST\" REAL,\n"
                      "  \"LEG_IMP\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Plan_ (
    "",
    &access::object_traits< ::pio::Plan >::create_schema);

  // Skim
  //

  access::object_traits< ::pio::Skim >::id_type
  access::object_traits< ::pio::Skim >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Skim >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // time
    //
    t[1UL] = false;

    // walk
    //
    t[2UL] = false;

    // drive
    //
    t[3UL] = false;

    // transit
    //
    t[4UL] = false;

    // wait
    //
    t[5UL] = false;

    // other
    //
    t[6UL] = false;

    // length
    //
    t[7UL] = false;

    // cost
    //
    t[8UL] = false;

    // impedance
    //
    t[9UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Skim >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // walk
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.walk_value;
    b[n].is_null = &i.walk_null;
    n++;

    // drive
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.drive_value;
    b[n].is_null = &i.drive_null;
    n++;

    // transit
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.transit_value;
    b[n].is_null = &i.transit_null;
    n++;

    // wait
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.wait_value;
    b[n].is_null = &i.wait_null;
    n++;

    // other
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.other_value;
    b[n].is_null = &i.other_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.cost_value;
    b[n].is_null = &i.cost_null;
    n++;

    // impedance
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.impedance_value;
    b[n].is_null = &i.impedance_null;
    n++;
  }

  void access::object_traits< ::pio::Skim >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Skim >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // walk
    //
    {
      double const& v =
        o.walk;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.walk_value,
        is_null,
        v);
      i.walk_null = is_null;
    }

    // drive
    //
    {
      double const& v =
        o.drive;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.drive_value,
        is_null,
        v);
      i.drive_null = is_null;
    }

    // transit
    //
    {
      double const& v =
        o.transit;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.transit_value,
        is_null,
        v);
      i.transit_null = is_null;
    }

    // wait
    //
    {
      double const& v =
        o.wait;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.wait_value,
        is_null,
        v);
      i.wait_null = is_null;
    }

    // other
    //
    {
      double const& v =
        o.other;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.other_value,
        is_null,
        v);
      i.other_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // cost
    //
    {
      double const& v =
        o.cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.cost_value,
        is_null,
        v);
      i.cost_null = is_null;
    }

    // impedance
    //
    {
      int const& v =
        o.impedance;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.impedance_value,
        is_null,
        v);
      i.impedance_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Skim >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // walk
    //
    {
      double& v =
        o.walk;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.walk_value,
        i.walk_null);
    }

    // drive
    //
    {
      double& v =
        o.drive;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.drive_value,
        i.drive_null);
    }

    // transit
    //
    {
      double& v =
        o.transit;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.transit_value,
        i.transit_null);
    }

    // wait
    //
    {
      double& v =
        o.wait;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.wait_value,
        i.wait_null);
    }

    // other
    //
    {
      double& v =
        o.other;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.other_value,
        i.other_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // cost
    //
    {
      double& v =
        o.cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.cost_value,
        i.cost_null);
    }

    // impedance
    //
    {
      int& v =
        o.impedance;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.impedance_value,
        i.impedance_null);
    }
  }

  void access::object_traits< ::pio::Skim >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Skim >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Skim >::persist_statement[] =
  "INSERT INTO \"SKIM\" ("
  "\"auto_id\","
  "\"TIME\","
  "\"WALK\","
  "\"DRIVE\","
  "\"TRANSIT\","
  "\"WAIT\","
  "\"OTHER\","
  "\"LENGTH\","
  "\"COST\","
  "\"IMPEDANCE\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Skim >::find_statement[] =
  "SELECT "
  "\"SKIM\".\"auto_id\","
  "\"SKIM\".\"TIME\","
  "\"SKIM\".\"WALK\","
  "\"SKIM\".\"DRIVE\","
  "\"SKIM\".\"TRANSIT\","
  "\"SKIM\".\"WAIT\","
  "\"SKIM\".\"OTHER\","
  "\"SKIM\".\"LENGTH\","
  "\"SKIM\".\"COST\","
  "\"SKIM\".\"IMPEDANCE\""
  " FROM \"SKIM\""
  " WHERE \"SKIM\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Skim >::update_statement[] =
  "UPDATE \"SKIM\" SET "
  "\"TIME\"=?,"
  "\"WALK\"=?,"
  "\"DRIVE\"=?,"
  "\"TRANSIT\"=?,"
  "\"WAIT\"=?,"
  "\"OTHER\"=?,"
  "\"LENGTH\"=?,"
  "\"COST\"=?,"
  "\"IMPEDANCE\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Skim >::erase_statement[] =
  "DELETE FROM \"SKIM\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Skim >::query_statement[] =
  "SELECT "
  "\"SKIM\".\"auto_id\","
  "\"SKIM\".\"TIME\","
  "\"SKIM\".\"WALK\","
  "\"SKIM\".\"DRIVE\","
  "\"SKIM\".\"TRANSIT\","
  "\"SKIM\".\"WAIT\","
  "\"SKIM\".\"OTHER\","
  "\"SKIM\".\"LENGTH\","
  "\"SKIM\".\"COST\","
  "\"SKIM\".\"IMPEDANCE\""
  " FROM \"SKIM\""
  " ";

  const char access::object_traits< ::pio::Skim >::erase_query_statement[] =
  "DELETE FROM \"SKIM\""
  " ";

  const char access::object_traits< ::pio::Skim >::table_name[] =
  "\"SKIM\"";

  void access::object_traits< ::pio::Skim >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Skim >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Skim >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Skim >::pointer_type
  access::object_traits< ::pio::Skim >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Skim >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Skim >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Skim >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Skim >::object_type >
  access::object_traits< ::pio::Skim >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Skim >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Skim >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"SKIM\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"SKIM\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"TIME\" REAL,\n"
                      "  \"WALK\" REAL,\n"
                      "  \"DRIVE\" REAL,\n"
                      "  \"TRANSIT\" REAL,\n"
                      "  \"WAIT\" REAL,\n"
                      "  \"OTHER\" REAL,\n"
                      "  \"LENGTH\" REAL,\n"
                      "  \"COST\" REAL,\n"
                      "  \"IMPEDANCE\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Skim_ (
    "",
    &access::object_traits< ::pio::Skim >::create_schema);

  // Event
  //

  access::object_traits< ::pio::Event >::id_type
  access::object_traits< ::pio::Event >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Event >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // mode
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // schedule
    //
    t[7UL] = false;

    // actual
    //
    t[8UL] = false;

    // link
    //
    t[9UL] = false;

    // dir
    //
    t[10UL] = false;

    // lane
    //
    t[11UL] = false;

    // offset
    //
    t[12UL] = false;

    // route
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Event >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // schedule
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.schedule_value;
    b[n].is_null = &i.schedule_null;
    n++;

    // actual
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.actual_value;
    b[n].is_null = &i.actual_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lane
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lane_value;
    b[n].is_null = &i.lane_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;
  }

  void access::object_traits< ::pio::Event >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Event >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // schedule
    //
    {
      double const& v =
        o.schedule;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.schedule_value,
        is_null,
        v);
      i.schedule_null = is_null;
    }

    // actual
    //
    {
      double const& v =
        o.actual;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.actual_value,
        is_null,
        v);
      i.actual_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lane
    //
    {
      int const& v =
        o.lane;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lane_value,
        is_null,
        v);
      i.lane_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Event >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // schedule
    //
    {
      double& v =
        o.schedule;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.schedule_value,
        i.schedule_null);
    }

    // actual
    //
    {
      double& v =
        o.actual;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.actual_value,
        i.actual_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lane
    //
    {
      int& v =
        o.lane;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lane_value,
        i.lane_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }
  }

  void access::object_traits< ::pio::Event >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Event >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Event >::persist_statement[] =
  "INSERT INTO \"EVENT\" ("
  "\"auto_id\","
  "\"HHOLD\","
  "\"PERSON\","
  "\"TOUR\","
  "\"TRIP\","
  "\"MODE\","
  "\"TYPE\","
  "\"SCHEDULE\","
  "\"ACTUAL\","
  "\"LINK\","
  "\"DIR\","
  "\"LANE\","
  "\"OFFSET\","
  "\"ROUTE\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Event >::find_statement[] =
  "SELECT "
  "\"EVENT\".\"auto_id\","
  "\"EVENT\".\"HHOLD\","
  "\"EVENT\".\"PERSON\","
  "\"EVENT\".\"TOUR\","
  "\"EVENT\".\"TRIP\","
  "\"EVENT\".\"MODE\","
  "\"EVENT\".\"TYPE\","
  "\"EVENT\".\"SCHEDULE\","
  "\"EVENT\".\"ACTUAL\","
  "\"EVENT\".\"LINK\","
  "\"EVENT\".\"DIR\","
  "\"EVENT\".\"LANE\","
  "\"EVENT\".\"OFFSET\","
  "\"EVENT\".\"ROUTE\""
  " FROM \"EVENT\""
  " WHERE \"EVENT\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Event >::update_statement[] =
  "UPDATE \"EVENT\" SET "
  "\"HHOLD\"=?,"
  "\"PERSON\"=?,"
  "\"TOUR\"=?,"
  "\"TRIP\"=?,"
  "\"MODE\"=?,"
  "\"TYPE\"=?,"
  "\"SCHEDULE\"=?,"
  "\"ACTUAL\"=?,"
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"LANE\"=?,"
  "\"OFFSET\"=?,"
  "\"ROUTE\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Event >::erase_statement[] =
  "DELETE FROM \"EVENT\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Event >::query_statement[] =
  "SELECT "
  "\"EVENT\".\"auto_id\","
  "\"EVENT\".\"HHOLD\","
  "\"EVENT\".\"PERSON\","
  "\"EVENT\".\"TOUR\","
  "\"EVENT\".\"TRIP\","
  "\"EVENT\".\"MODE\","
  "\"EVENT\".\"TYPE\","
  "\"EVENT\".\"SCHEDULE\","
  "\"EVENT\".\"ACTUAL\","
  "\"EVENT\".\"LINK\","
  "\"EVENT\".\"DIR\","
  "\"EVENT\".\"LANE\","
  "\"EVENT\".\"OFFSET\","
  "\"EVENT\".\"ROUTE\""
  " FROM \"EVENT\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"EVENT\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Event >::erase_query_statement[] =
  "DELETE FROM \"EVENT\""
  " ";

  const char access::object_traits< ::pio::Event >::table_name[] =
  "\"EVENT\"";

  void access::object_traits< ::pio::Event >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Event >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Event >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Event >::pointer_type
  access::object_traits< ::pio::Event >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Event >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Event >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Event >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Event >::object_type >
  access::object_traits< ::pio::Event >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Event >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Event >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"EVENT\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"EVENT\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"HHOLD\" INTEGER NOT NULL,\n"
                      "  \"PERSON\" INTEGER NOT NULL,\n"
                      "  \"TOUR\" INTEGER NOT NULL,\n"
                      "  \"TRIP\" INTEGER NOT NULL,\n"
                      "  \"MODE\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"SCHEDULE\" REAL,\n"
                      "  \"ACTUAL\" REAL,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"LANE\" INTEGER NOT NULL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  \"ROUTE\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Event_ (
    "",
    &access::object_traits< ::pio::Event >::create_schema);

  // Traveler
  //

  access::object_traits< ::pio::Traveler >::id_type
  access::object_traits< ::pio::Traveler >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Traveler >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // mode
    //
    t[5UL] = false;

    // time
    //
    t[6UL] = false;

    // distance
    //
    t[7UL] = false;

    // speed
    //
    t[8UL] = false;

    // link
    //
    t[9UL] = false;

    // dir
    //
    t[10UL] = false;

    // lane
    //
    t[11UL] = false;

    // offset
    //
    t[12UL] = false;

    // route
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Traveler >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // distance
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.distance_value;
    b[n].is_null = &i.distance_null;
    n++;

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lane
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lane_value;
    b[n].is_null = &i.lane_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;
  }

  void access::object_traits< ::pio::Traveler >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Traveler >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // distance
    //
    {
      double const& v =
        o.distance;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.distance_value,
        is_null,
        v);
      i.distance_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lane
    //
    {
      int const& v =
        o.lane;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lane_value,
        is_null,
        v);
      i.lane_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Traveler >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // distance
    //
    {
      double& v =
        o.distance;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.distance_value,
        i.distance_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lane
    //
    {
      int& v =
        o.lane;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lane_value,
        i.lane_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }
  }

  void access::object_traits< ::pio::Traveler >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Traveler >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Traveler >::persist_statement[] =
  "INSERT INTO \"TRAVELER\" ("
  "\"auto_id\","
  "\"HHOLD\","
  "\"PERSON\","
  "\"TOUR\","
  "\"TRIP\","
  "\"MODE\","
  "\"TIME\","
  "\"DISTANCE\","
  "\"SPEED\","
  "\"LINK\","
  "\"DIR\","
  "\"LANE\","
  "\"OFFSET\","
  "\"ROUTE\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Traveler >::find_statement[] =
  "SELECT "
  "\"TRAVELER\".\"auto_id\","
  "\"TRAVELER\".\"HHOLD\","
  "\"TRAVELER\".\"PERSON\","
  "\"TRAVELER\".\"TOUR\","
  "\"TRAVELER\".\"TRIP\","
  "\"TRAVELER\".\"MODE\","
  "\"TRAVELER\".\"TIME\","
  "\"TRAVELER\".\"DISTANCE\","
  "\"TRAVELER\".\"SPEED\","
  "\"TRAVELER\".\"LINK\","
  "\"TRAVELER\".\"DIR\","
  "\"TRAVELER\".\"LANE\","
  "\"TRAVELER\".\"OFFSET\","
  "\"TRAVELER\".\"ROUTE\""
  " FROM \"TRAVELER\""
  " WHERE \"TRAVELER\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Traveler >::update_statement[] =
  "UPDATE \"TRAVELER\" SET "
  "\"HHOLD\"=?,"
  "\"PERSON\"=?,"
  "\"TOUR\"=?,"
  "\"TRIP\"=?,"
  "\"MODE\"=?,"
  "\"TIME\"=?,"
  "\"DISTANCE\"=?,"
  "\"SPEED\"=?,"
  "\"LINK\"=?,"
  "\"DIR\"=?,"
  "\"LANE\"=?,"
  "\"OFFSET\"=?,"
  "\"ROUTE\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Traveler >::erase_statement[] =
  "DELETE FROM \"TRAVELER\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Traveler >::query_statement[] =
  "SELECT "
  "\"TRAVELER\".\"auto_id\","
  "\"TRAVELER\".\"HHOLD\","
  "\"TRAVELER\".\"PERSON\","
  "\"TRAVELER\".\"TOUR\","
  "\"TRAVELER\".\"TRIP\","
  "\"TRAVELER\".\"MODE\","
  "\"TRAVELER\".\"TIME\","
  "\"TRAVELER\".\"DISTANCE\","
  "\"TRAVELER\".\"SPEED\","
  "\"TRAVELER\".\"LINK\","
  "\"TRAVELER\".\"DIR\","
  "\"TRAVELER\".\"LANE\","
  "\"TRAVELER\".\"OFFSET\","
  "\"TRAVELER\".\"ROUTE\""
  " FROM \"TRAVELER\""
  " LEFT JOIN \"LINK\" AS \"LINK\" ON \"LINK\".\"LINK\"=\"TRAVELER\".\"LINK\""
  " ";

  const char access::object_traits< ::pio::Traveler >::erase_query_statement[] =
  "DELETE FROM \"TRAVELER\""
  " ";

  const char access::object_traits< ::pio::Traveler >::table_name[] =
  "\"TRAVELER\"";

  void access::object_traits< ::pio::Traveler >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Traveler >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Traveler >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Traveler >::pointer_type
  access::object_traits< ::pio::Traveler >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Traveler >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Traveler >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Traveler >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Traveler >::object_type >
  access::object_traits< ::pio::Traveler >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Traveler >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Traveler >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"TRAVELER\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"TRAVELER\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"HHOLD\" INTEGER NOT NULL,\n"
                      "  \"PERSON\" INTEGER NOT NULL,\n"
                      "  \"TOUR\" INTEGER NOT NULL,\n"
                      "  \"TRIP\" INTEGER NOT NULL,\n"
                      "  \"MODE\" INTEGER NOT NULL,\n"
                      "  \"TIME\" REAL,\n"
                      "  \"DISTANCE\" REAL,\n"
                      "  \"SPEED\" REAL,\n"
                      "  \"LINK\" INTEGER,\n"
                      "  \"DIR\" INTEGER NOT NULL,\n"
                      "  \"LANE\" INTEGER NOT NULL,\n"
                      "  \"OFFSET\" REAL,\n"
                      "  \"ROUTE\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"LINK_fk\"\n"
                      "    FOREIGN KEY (\"LINK\")\n"
                      "    REFERENCES \"LINK\" (\"LINK\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Traveler_ (
    "",
    &access::object_traits< ::pio::Traveler >::create_schema);

  // TripNoRef
  //

  access::object_traits< ::pio::TripNoRef >::id_type
  access::object_traits< ::pio::TripNoRef >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::TripNoRef >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // start
    //
    t[5UL] = false;

    // end
    //
    t[6UL] = false;

    // duration
    //
    t[7UL] = false;

    // origin
    //
    t[8UL] = false;

    // destination
    //
    t[9UL] = false;

    // purpose
    //
    t[10UL] = false;

    // mode
    //
    t[11UL] = false;

    // constraint
    //
    t[12UL] = false;

    // priority
    //
    t[13UL] = false;

    // vehicle
    //
    t[14UL] = false;

    // passengers
    //
    t[15UL] = false;

    // type
    //
    t[16UL] = false;

    // partition
    //
    t[17UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::TripNoRef >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // duration
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.duration_value;
    b[n].is_null = &i.duration_null;
    n++;

    // origin
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.origin_value;
    b[n].is_null = &i.origin_null;
    n++;

    // destination
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.destination_value;
    b[n].is_null = &i.destination_null;
    n++;

    // purpose
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.purpose_value;
    b[n].is_null = &i.purpose_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // constraint
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.constraint_value;
    b[n].is_null = &i.constraint_null;
    n++;

    // priority
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.priority_value;
    b[n].is_null = &i.priority_null;
    n++;

    // vehicle
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.vehicle_value;
    b[n].is_null = &i.vehicle_null;
    n++;

    // passengers
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.passengers_value;
    b[n].is_null = &i.passengers_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;
  }

  void access::object_traits< ::pio::TripNoRef >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::TripNoRef >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // duration
    //
    {
      double const& v =
        o.duration;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.duration_value,
        is_null,
        v);
      i.duration_null = is_null;
    }

    // origin
    //
    {
      int const& v =
        o.origin;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.origin_value,
        is_null,
        v);
      i.origin_null = is_null;
    }

    // destination
    //
    {
      int const& v =
        o.destination;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.destination_value,
        is_null,
        v);
      i.destination_null = is_null;
    }

    // purpose
    //
    {
      int const& v =
        o.purpose;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.purpose_value,
        is_null,
        v);
      i.purpose_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // constraint
    //
    {
      int const& v =
        o.constraint;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.constraint_value,
        is_null,
        v);
      i.constraint_null = is_null;
    }

    // priority
    //
    {
      int const& v =
        o.priority;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.priority_value,
        is_null,
        v);
      i.priority_null = is_null;
    }

    // vehicle
    //
    {
      int const& v =
        o.vehicle;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.vehicle_value,
        is_null,
        v);
      i.vehicle_null = is_null;
    }

    // passengers
    //
    {
      int const& v =
        o.passengers;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.passengers_value,
        is_null,
        v);
      i.passengers_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::TripNoRef >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // duration
    //
    {
      double& v =
        o.duration;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.duration_value,
        i.duration_null);
    }

    // origin
    //
    {
      int& v =
        o.origin;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.origin_value,
        i.origin_null);
    }

    // destination
    //
    {
      int& v =
        o.destination;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.destination_value,
        i.destination_null);
    }

    // purpose
    //
    {
      int& v =
        o.purpose;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.purpose_value,
        i.purpose_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // constraint
    //
    {
      int& v =
        o.constraint;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.constraint_value,
        i.constraint_null);
    }

    // priority
    //
    {
      int& v =
        o.priority;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.priority_value,
        i.priority_null);
    }

    // vehicle
    //
    {
      int& v =
        o.vehicle;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.vehicle_value,
        i.vehicle_null);
    }

    // passengers
    //
    {
      int& v =
        o.passengers;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.passengers_value,
        i.passengers_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }
  }

  void access::object_traits< ::pio::TripNoRef >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::TripNoRef >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::TripNoRef >::persist_statement[] =
  "INSERT INTO \"TRIPNOREF\" ("
  "\"auto_id\","
  "\"HHOLD\","
  "\"PERSON\","
  "\"TOUR\","
  "\"TRIP\","
  "\"START\","
  "\"END\","
  "\"DURATION\","
  "\"ORIGIN\","
  "\"DESTINATION\","
  "\"PURPOSE\","
  "\"MODE\","
  "\"CONSTRAINT\","
  "\"PRIORITY\","
  "\"VEHICLE\","
  "\"PASSENGERS\","
  "\"TYPE\","
  "\"PARTITION\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::TripNoRef >::find_statement[] =
  "SELECT "
  "\"TRIPNOREF\".\"auto_id\","
  "\"TRIPNOREF\".\"HHOLD\","
  "\"TRIPNOREF\".\"PERSON\","
  "\"TRIPNOREF\".\"TOUR\","
  "\"TRIPNOREF\".\"TRIP\","
  "\"TRIPNOREF\".\"START\","
  "\"TRIPNOREF\".\"END\","
  "\"TRIPNOREF\".\"DURATION\","
  "\"TRIPNOREF\".\"ORIGIN\","
  "\"TRIPNOREF\".\"DESTINATION\","
  "\"TRIPNOREF\".\"PURPOSE\","
  "\"TRIPNOREF\".\"MODE\","
  "\"TRIPNOREF\".\"CONSTRAINT\","
  "\"TRIPNOREF\".\"PRIORITY\","
  "\"TRIPNOREF\".\"VEHICLE\","
  "\"TRIPNOREF\".\"PASSENGERS\","
  "\"TRIPNOREF\".\"TYPE\","
  "\"TRIPNOREF\".\"PARTITION\""
  " FROM \"TRIPNOREF\""
  " WHERE \"TRIPNOREF\".\"auto_id\"=?";

  const char access::object_traits< ::pio::TripNoRef >::update_statement[] =
  "UPDATE \"TRIPNOREF\" SET "
  "\"HHOLD\"=?,"
  "\"PERSON\"=?,"
  "\"TOUR\"=?,"
  "\"TRIP\"=?,"
  "\"START\"=?,"
  "\"END\"=?,"
  "\"DURATION\"=?,"
  "\"ORIGIN\"=?,"
  "\"DESTINATION\"=?,"
  "\"PURPOSE\"=?,"
  "\"MODE\"=?,"
  "\"CONSTRAINT\"=?,"
  "\"PRIORITY\"=?,"
  "\"VEHICLE\"=?,"
  "\"PASSENGERS\"=?,"
  "\"TYPE\"=?,"
  "\"PARTITION\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::TripNoRef >::erase_statement[] =
  "DELETE FROM \"TRIPNOREF\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::TripNoRef >::query_statement[] =
  "SELECT "
  "\"TRIPNOREF\".\"auto_id\","
  "\"TRIPNOREF\".\"HHOLD\","
  "\"TRIPNOREF\".\"PERSON\","
  "\"TRIPNOREF\".\"TOUR\","
  "\"TRIPNOREF\".\"TRIP\","
  "\"TRIPNOREF\".\"START\","
  "\"TRIPNOREF\".\"END\","
  "\"TRIPNOREF\".\"DURATION\","
  "\"TRIPNOREF\".\"ORIGIN\","
  "\"TRIPNOREF\".\"DESTINATION\","
  "\"TRIPNOREF\".\"PURPOSE\","
  "\"TRIPNOREF\".\"MODE\","
  "\"TRIPNOREF\".\"CONSTRAINT\","
  "\"TRIPNOREF\".\"PRIORITY\","
  "\"TRIPNOREF\".\"VEHICLE\","
  "\"TRIPNOREF\".\"PASSENGERS\","
  "\"TRIPNOREF\".\"TYPE\","
  "\"TRIPNOREF\".\"PARTITION\""
  " FROM \"TRIPNOREF\""
  " ";

  const char access::object_traits< ::pio::TripNoRef >::erase_query_statement[] =
  "DELETE FROM \"TRIPNOREF\""
  " ";

  const char access::object_traits< ::pio::TripNoRef >::table_name[] =
  "\"TRIPNOREF\"";

  void access::object_traits< ::pio::TripNoRef >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::TripNoRef >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::TripNoRef >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::TripNoRef >::pointer_type
  access::object_traits< ::pio::TripNoRef >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::TripNoRef >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::TripNoRef >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::TripNoRef >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::TripNoRef >::object_type >
  access::object_traits< ::pio::TripNoRef >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::TripNoRef >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::TripNoRef >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"TRIPNOREF\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"TRIPNOREF\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"HHOLD\" INTEGER NOT NULL,\n"
                      "  \"PERSON\" INTEGER NOT NULL,\n"
                      "  \"TOUR\" INTEGER NOT NULL,\n"
                      "  \"TRIP\" INTEGER NOT NULL,\n"
                      "  \"START\" REAL,\n"
                      "  \"END\" REAL,\n"
                      "  \"DURATION\" REAL,\n"
                      "  \"ORIGIN\" INTEGER NOT NULL,\n"
                      "  \"DESTINATION\" INTEGER NOT NULL,\n"
                      "  \"PURPOSE\" INTEGER NOT NULL,\n"
                      "  \"MODE\" INTEGER NOT NULL,\n"
                      "  \"CONSTRAINT\" INTEGER NOT NULL,\n"
                      "  \"PRIORITY\" INTEGER NOT NULL,\n"
                      "  \"VEHICLE\" INTEGER NOT NULL,\n"
                      "  \"PASSENGERS\" INTEGER NOT NULL,\n"
                      "  \"TYPE\" INTEGER NOT NULL,\n"
                      "  \"PARTITION\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_TripNoRef_ (
    "",
    &access::object_traits< ::pio::TripNoRef >::create_schema);
}

#include <odb/post.hxx>
