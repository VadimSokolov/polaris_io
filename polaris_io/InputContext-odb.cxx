// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include "InputContext-odb.hxx"

#include <cassert>
#include <cstring>  // std::memcpy

#include <odb/schema-catalog-impl.hxx>
#include <odb/details/shared-ptr.hxx>

#include <odb/sqlite/traits.hxx>
#include <odb/sqlite/database.hxx>
#include <odb/sqlite/transaction.hxx>
#include <odb/sqlite/connection.hxx>
#include <odb/sqlite/statement.hxx>
#include <odb/sqlite/statement-cache.hxx>
#include <odb/sqlite/simple-object-statements.hxx>
#include <odb/sqlite/container-statements.hxx>
#include <odb/sqlite/exceptions.hxx>
#include <odb/sqlite/simple-object-result.hxx>

namespace odb
{
  // Node
  //

  access::object_traits< ::pio::Node >::id_type
  access::object_traits< ::pio::Node >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.node_value,
        i.node_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Node >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // node
    //
    t[0UL] = false;

    // x
    //
    t[1UL] = false;

    // y
    //
    t[2UL] = false;

    // z
    //
    t[3UL] = false;

    // subarea
    //
    t[4UL] = false;

    // part
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Node >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // node
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.node_value;
      b[n].is_null = &i.node_null;
      n++;
    }

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;

    // subarea
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subarea_value;
    b[n].is_null = &i.subarea_null;
    n++;

    // part
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.part_value;
    b[n].is_null = &i.part_null;
    n++;
  }

  void access::object_traits< ::pio::Node >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Node >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // node
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.node;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.node_value,
        is_null,
        v);
      i.node_null = is_null;
    }

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    // subarea
    //
    {
      int const& v =
        o.subarea;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subarea_value,
        is_null,
        v);
      i.subarea_null = is_null;
    }

    // part
    //
    {
      int const& v =
        o.part;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.part_value,
        is_null,
        v);
      i.part_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Node >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // node
    //
    {
      int& v =
        o.node;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.node_value,
        i.node_null);
    }

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }

    // subarea
    //
    {
      int& v =
        o.subarea;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subarea_value,
        i.subarea_null);
    }

    // part
    //
    {
      int& v =
        o.part;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.part_value,
        i.part_null);
    }
  }

  void access::object_traits< ::pio::Node >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Node >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Node >::persist_statement[] =
  "INSERT INTO \"Node\" ("
  "\"node\","
  "\"x\","
  "\"y\","
  "\"z\","
  "\"subarea\","
  "\"part\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Node >::find_statement[] =
  "SELECT "
  "\"Node\".\"node\","
  "\"Node\".\"x\","
  "\"Node\".\"y\","
  "\"Node\".\"z\","
  "\"Node\".\"subarea\","
  "\"Node\".\"part\""
  " FROM \"Node\""
  " WHERE \"Node\".\"node\"=?";

  const char access::object_traits< ::pio::Node >::update_statement[] =
  "UPDATE \"Node\" SET "
  "\"x\"=?,"
  "\"y\"=?,"
  "\"z\"=?,"
  "\"subarea\"=?,"
  "\"part\"=?"
  " WHERE \"node\"=?";

  const char access::object_traits< ::pio::Node >::erase_statement[] =
  "DELETE FROM \"Node\""
  " WHERE \"node\"=?";

  const char access::object_traits< ::pio::Node >::query_statement[] =
  "SELECT "
  "\"Node\".\"node\","
  "\"Node\".\"x\","
  "\"Node\".\"y\","
  "\"Node\".\"z\","
  "\"Node\".\"subarea\","
  "\"Node\".\"part\""
  " FROM \"Node\""
  " ";

  const char access::object_traits< ::pio::Node >::erase_query_statement[] =
  "DELETE FROM \"Node\""
  " ";

  const char access::object_traits< ::pio::Node >::table_name[] =
  "\"Node\"";

  void access::object_traits< ::pio::Node >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Node >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.node);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Node >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Node >::pointer_type
  access::object_traits< ::pio::Node >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Node >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Node >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.node);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Node >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Node >::object_type >
  access::object_traits< ::pio::Node >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Node >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Node >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Node\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Node\" (\n"
                      "  \"node\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"x\" REAL,\n"
                      "  \"y\" REAL,\n"
                      "  \"z\" REAL,\n"
                      "  \"subarea\" INTEGER NOT NULL,\n"
                      "  \"part\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Node_ (
    "",
    &access::object_traits< ::pio::Node >::create_schema);

  // Zone
  //

  access::object_traits< ::pio::Zone >::id_type
  access::object_traits< ::pio::Zone >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.zone_value,
        i.zone_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Zone >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // zone
    //
    t[0UL] = false;

    // x
    //
    t[1UL] = false;

    // y
    //
    t[2UL] = false;

    // z
    //
    t[3UL] = false;

    // area
    //
    t[4UL] = false;

    // min_x
    //
    t[5UL] = false;

    // min_y
    //
    t[6UL] = false;

    // max_x
    //
    t[7UL] = false;

    // max_y
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Zone >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // zone
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.zone_value;
      b[n].is_null = &i.zone_null;
      n++;
    }

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;

    // area
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.area_value;
    b[n].is_null = &i.area_null;
    n++;

    // min_x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_x_value;
    b[n].is_null = &i.min_x_null;
    n++;

    // min_y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_y_value;
    b[n].is_null = &i.min_y_null;
    n++;

    // max_x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_x_value;
    b[n].is_null = &i.max_x_null;
    n++;

    // max_y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_y_value;
    b[n].is_null = &i.max_y_null;
    n++;
  }

  void access::object_traits< ::pio::Zone >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Zone >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // zone
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.zone;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.zone_value,
        is_null,
        v);
      i.zone_null = is_null;
    }

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    // area
    //
    {
      int const& v =
        o.area;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.area_value,
        is_null,
        v);
      i.area_null = is_null;
    }

    // min_x
    //
    {
      double const& v =
        o.min_x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_x_value,
        is_null,
        v);
      i.min_x_null = is_null;
    }

    // min_y
    //
    {
      double const& v =
        o.min_y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_y_value,
        is_null,
        v);
      i.min_y_null = is_null;
    }

    // max_x
    //
    {
      double const& v =
        o.max_x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_x_value,
        is_null,
        v);
      i.max_x_null = is_null;
    }

    // max_y
    //
    {
      double const& v =
        o.max_y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_y_value,
        is_null,
        v);
      i.max_y_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Zone >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // zone
    //
    {
      int& v =
        o.zone;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.zone_value,
        i.zone_null);
    }

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }

    // area
    //
    {
      int& v =
        o.area;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.area_value,
        i.area_null);
    }

    // min_x
    //
    {
      double& v =
        o.min_x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_x_value,
        i.min_x_null);
    }

    // min_y
    //
    {
      double& v =
        o.min_y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_y_value,
        i.min_y_null);
    }

    // max_x
    //
    {
      double& v =
        o.max_x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_x_value,
        i.max_x_null);
    }

    // max_y
    //
    {
      double& v =
        o.max_y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_y_value,
        i.max_y_null);
    }
  }

  void access::object_traits< ::pio::Zone >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Zone >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Zone >::persist_statement[] =
  "INSERT INTO \"Zone\" ("
  "\"zone\","
  "\"x\","
  "\"y\","
  "\"z\","
  "\"area\","
  "\"min_x\","
  "\"min_y\","
  "\"max_x\","
  "\"max_y\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Zone >::find_statement[] =
  "SELECT "
  "\"Zone\".\"zone\","
  "\"Zone\".\"x\","
  "\"Zone\".\"y\","
  "\"Zone\".\"z\","
  "\"Zone\".\"area\","
  "\"Zone\".\"min_x\","
  "\"Zone\".\"min_y\","
  "\"Zone\".\"max_x\","
  "\"Zone\".\"max_y\""
  " FROM \"Zone\""
  " WHERE \"Zone\".\"zone\"=?";

  const char access::object_traits< ::pio::Zone >::update_statement[] =
  "UPDATE \"Zone\" SET "
  "\"x\"=?,"
  "\"y\"=?,"
  "\"z\"=?,"
  "\"area\"=?,"
  "\"min_x\"=?,"
  "\"min_y\"=?,"
  "\"max_x\"=?,"
  "\"max_y\"=?"
  " WHERE \"zone\"=?";

  const char access::object_traits< ::pio::Zone >::erase_statement[] =
  "DELETE FROM \"Zone\""
  " WHERE \"zone\"=?";

  const char access::object_traits< ::pio::Zone >::query_statement[] =
  "SELECT "
  "\"Zone\".\"zone\","
  "\"Zone\".\"x\","
  "\"Zone\".\"y\","
  "\"Zone\".\"z\","
  "\"Zone\".\"area\","
  "\"Zone\".\"min_x\","
  "\"Zone\".\"min_y\","
  "\"Zone\".\"max_x\","
  "\"Zone\".\"max_y\""
  " FROM \"Zone\""
  " ";

  const char access::object_traits< ::pio::Zone >::erase_query_statement[] =
  "DELETE FROM \"Zone\""
  " ";

  const char access::object_traits< ::pio::Zone >::table_name[] =
  "\"Zone\"";

  void access::object_traits< ::pio::Zone >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Zone >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.zone);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Zone >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Zone >::pointer_type
  access::object_traits< ::pio::Zone >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Zone >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Zone >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.zone);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Zone >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Zone >::object_type >
  access::object_traits< ::pio::Zone >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Zone >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Zone >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Zone\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Zone\" (\n"
                      "  \"zone\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"x\" REAL,\n"
                      "  \"y\" REAL,\n"
                      "  \"z\" REAL,\n"
                      "  \"area\" INTEGER NOT NULL,\n"
                      "  \"min_x\" REAL,\n"
                      "  \"min_y\" REAL,\n"
                      "  \"max_x\" REAL,\n"
                      "  \"max_y\" REAL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Zone_ (
    "",
    &access::object_traits< ::pio::Zone >::create_schema);

  // Shape
  //

  access::object_traits< ::pio::Shape >::id_type
  access::object_traits< ::pio::Shape >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Shape >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // points
    //
    t[2UL] = false;

    // x
    //
    t[3UL] = false;

    // y
    //
    t[4UL] = false;

    // z
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Shape >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // points
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.points_value;
    b[n].is_null = &i.points_null;
    n++;

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;
  }

  void access::object_traits< ::pio::Shape >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Shape >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // points
    //
    {
      int const& v =
        o.points;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.points_value,
        is_null,
        v);
      i.points_null = is_null;
    }

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Shape >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // points
    //
    {
      int& v =
        o.points;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.points_value,
        i.points_null);
    }

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }
  }

  void access::object_traits< ::pio::Shape >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Shape >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Shape >::persist_statement[] =
  "INSERT INTO \"Shape\" ("
  "\"auto_id\","
  "\"link\","
  "\"points\","
  "\"x\","
  "\"y\","
  "\"z\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Shape >::find_statement[] =
  "SELECT "
  "\"Shape\".\"auto_id\","
  "\"Shape\".\"link\","
  "\"Shape\".\"points\","
  "\"Shape\".\"x\","
  "\"Shape\".\"y\","
  "\"Shape\".\"z\""
  " FROM \"Shape\""
  " WHERE \"Shape\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Shape >::update_statement[] =
  "UPDATE \"Shape\" SET "
  "\"link\"=?,"
  "\"points\"=?,"
  "\"x\"=?,"
  "\"y\"=?,"
  "\"z\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Shape >::erase_statement[] =
  "DELETE FROM \"Shape\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Shape >::query_statement[] =
  "SELECT "
  "\"Shape\".\"auto_id\","
  "\"Shape\".\"link\","
  "\"Shape\".\"points\","
  "\"Shape\".\"x\","
  "\"Shape\".\"y\","
  "\"Shape\".\"z\""
  " FROM \"Shape\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Shape\".\"link\""
  " ";

  const char access::object_traits< ::pio::Shape >::erase_query_statement[] =
  "DELETE FROM \"Shape\""
  " ";

  const char access::object_traits< ::pio::Shape >::table_name[] =
  "\"Shape\"";

  void access::object_traits< ::pio::Shape >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Shape >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Shape >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Shape >::pointer_type
  access::object_traits< ::pio::Shape >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Shape >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Shape >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Shape >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Shape >::object_type >
  access::object_traits< ::pio::Shape >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Shape >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Shape >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Shape\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Shape\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"points\" INTEGER NOT NULL,\n"
                      "  \"x\" REAL,\n"
                      "  \"y\" REAL,\n"
                      "  \"z\" REAL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Shape_ (
    "",
    &access::object_traits< ::pio::Shape >::create_schema);

  // Link
  //

  access::object_traits< ::pio::Link >::id_type
  access::object_traits< ::pio::Link >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.link_value,
        i.link_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Link >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // link
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // node_a
    //
    t[2UL] = false;

    // node_b
    //
    t[3UL] = false;

    // length
    //
    t[4UL] = false;

    // setback_a
    //
    t[5UL] = false;

    // setback_b
    //
    t[6UL] = false;

    // bearing_a
    //
    t[7UL] = false;

    // bearing_b
    //
    t[8UL] = false;

    // type
    //
    if (t[9UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // divided
    //
    t[10UL] = false;

    // area_type
    //
    t[11UL] = false;

    // use
    //
    t[12UL] = false;

    // grade
    //
    t[13UL] = false;

    // lanes_ab
    //
    t[14UL] = false;

    // speed_ab
    //
    t[15UL] = false;

    // fspd_ab
    //
    t[16UL] = false;

    // cap_ab
    //
    t[17UL] = false;

    // lanes_ba
    //
    t[18UL] = false;

    // speed_ba
    //
    t[19UL] = false;

    // fspd_ba
    //
    t[20UL] = false;

    // cap_ba
    //
    t[21UL] = false;

    // left_ab
    //
    t[22UL] = false;

    // right_ab
    //
    t[23UL] = false;

    // left_ba
    //
    t[24UL] = false;

    // right_ba
    //
    t[25UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Link >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // link
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.link_value;
      b[n].is_null = &i.link_null;
      n++;
    }

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // node_a
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_a_value;
    b[n].is_null = &i.node_a_null;
    n++;

    // node_b
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_b_value;
    b[n].is_null = &i.node_b_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // setback_a
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_a_value;
    b[n].is_null = &i.setback_a_null;
    n++;

    // setback_b
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_b_value;
    b[n].is_null = &i.setback_b_null;
    n++;

    // bearing_a
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bearing_a_value;
    b[n].is_null = &i.bearing_a_null;
    n++;

    // bearing_b
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bearing_b_value;
    b[n].is_null = &i.bearing_b_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // divided
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.divided_value;
    b[n].is_null = &i.divided_null;
    n++;

    // area_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.area_type_value;
    b[n].is_null = &i.area_type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // grade
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.grade_value;
    b[n].is_null = &i.grade_null;
    n++;

    // lanes_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_ab_value;
    b[n].is_null = &i.lanes_ab_null;
    n++;

    // speed_ab
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_ab_value;
    b[n].is_null = &i.speed_ab_null;
    n++;

    // fspd_ab
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.fspd_ab_value;
    b[n].is_null = &i.fspd_ab_null;
    n++;

    // cap_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cap_ab_value;
    b[n].is_null = &i.cap_ab_null;
    n++;

    // lanes_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_ba_value;
    b[n].is_null = &i.lanes_ba_null;
    n++;

    // speed_ba
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_ba_value;
    b[n].is_null = &i.speed_ba_null;
    n++;

    // fspd_ba
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.fspd_ba_value;
    b[n].is_null = &i.fspd_ba_null;
    n++;

    // cap_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cap_ba_value;
    b[n].is_null = &i.cap_ba_null;
    n++;

    // left_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.left_ab_value;
    b[n].is_null = &i.left_ab_null;
    n++;

    // right_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.right_ab_value;
    b[n].is_null = &i.right_ab_null;
    n++;

    // left_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.left_ba_value;
    b[n].is_null = &i.left_ba_null;
    n++;

    // right_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.right_ba_value;
    b[n].is_null = &i.right_ba_null;
    n++;
  }

  void access::object_traits< ::pio::Link >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Link >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // link
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.link;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.link_value,
        is_null,
        v);
      i.link_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // node_a
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.node_a;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_a_value,
          is_null,
          id);
        i.node_a_null = is_null;
      }
      else
        i.node_a_null = true;
    }

    // node_b
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.node_b;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_b_value,
          is_null,
          id);
        i.node_b_null = is_null;
      }
      else
        i.node_b_null = true;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // setback_a
    //
    {
      double const& v =
        o.setback_a;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_a_value,
        is_null,
        v);
      i.setback_a_null = is_null;
    }

    // setback_b
    //
    {
      double const& v =
        o.setback_b;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_b_value,
        is_null,
        v);
      i.setback_b_null = is_null;
    }

    // bearing_a
    //
    {
      int const& v =
        o.bearing_a;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.bearing_a_value,
        is_null,
        v);
      i.bearing_a_null = is_null;
    }

    // bearing_b
    //
    {
      int const& v =
        o.bearing_b;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.bearing_b_value,
        is_null,
        v);
      i.bearing_b_null = is_null;
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // divided
    //
    {
      int const& v =
        o.divided;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.divided_value,
        is_null,
        v);
      i.divided_null = is_null;
    }

    // area_type
    //
    {
      int const& v =
        o.area_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.area_type_value,
        is_null,
        v);
      i.area_type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // grade
    //
    {
      double const& v =
        o.grade;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.grade_value,
        is_null,
        v);
      i.grade_null = is_null;
    }

    // lanes_ab
    //
    {
      int const& v =
        o.lanes_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_ab_value,
        is_null,
        v);
      i.lanes_ab_null = is_null;
    }

    // speed_ab
    //
    {
      double const& v =
        o.speed_ab;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_ab_value,
        is_null,
        v);
      i.speed_ab_null = is_null;
    }

    // fspd_ab
    //
    {
      double const& v =
        o.fspd_ab;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.fspd_ab_value,
        is_null,
        v);
      i.fspd_ab_null = is_null;
    }

    // cap_ab
    //
    {
      int const& v =
        o.cap_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cap_ab_value,
        is_null,
        v);
      i.cap_ab_null = is_null;
    }

    // lanes_ba
    //
    {
      int const& v =
        o.lanes_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_ba_value,
        is_null,
        v);
      i.lanes_ba_null = is_null;
    }

    // speed_ba
    //
    {
      double const& v =
        o.speed_ba;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_ba_value,
        is_null,
        v);
      i.speed_ba_null = is_null;
    }

    // fspd_ba
    //
    {
      double const& v =
        o.fspd_ba;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.fspd_ba_value,
        is_null,
        v);
      i.fspd_ba_null = is_null;
    }

    // cap_ba
    //
    {
      int const& v =
        o.cap_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cap_ba_value,
        is_null,
        v);
      i.cap_ba_null = is_null;
    }

    // left_ab
    //
    {
      int const& v =
        o.left_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.left_ab_value,
        is_null,
        v);
      i.left_ab_null = is_null;
    }

    // right_ab
    //
    {
      int const& v =
        o.right_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.right_ab_value,
        is_null,
        v);
      i.right_ab_null = is_null;
    }

    // left_ba
    //
    {
      int const& v =
        o.left_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.left_ba_value,
        is_null,
        v);
      i.left_ba_null = is_null;
    }

    // right_ba
    //
    {
      int const& v =
        o.right_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.right_ba_value,
        is_null,
        v);
      i.right_ba_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Link >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // link
    //
    {
      int& v =
        o.link;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.link_value,
        i.link_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // node_a
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.node_a;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.node_a_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_a_value,
          i.node_a_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // node_b
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.node_b;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.node_b_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_b_value,
          i.node_b_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // setback_a
    //
    {
      double& v =
        o.setback_a;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_a_value,
        i.setback_a_null);
    }

    // setback_b
    //
    {
      double& v =
        o.setback_b;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_b_value,
        i.setback_b_null);
    }

    // bearing_a
    //
    {
      int& v =
        o.bearing_a;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.bearing_a_value,
        i.bearing_a_null);
    }

    // bearing_b
    //
    {
      int& v =
        o.bearing_b;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.bearing_b_value,
        i.bearing_b_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // divided
    //
    {
      int& v =
        o.divided;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.divided_value,
        i.divided_null);
    }

    // area_type
    //
    {
      int& v =
        o.area_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.area_type_value,
        i.area_type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // grade
    //
    {
      double& v =
        o.grade;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.grade_value,
        i.grade_null);
    }

    // lanes_ab
    //
    {
      int& v =
        o.lanes_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_ab_value,
        i.lanes_ab_null);
    }

    // speed_ab
    //
    {
      double& v =
        o.speed_ab;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_ab_value,
        i.speed_ab_null);
    }

    // fspd_ab
    //
    {
      double& v =
        o.fspd_ab;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.fspd_ab_value,
        i.fspd_ab_null);
    }

    // cap_ab
    //
    {
      int& v =
        o.cap_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cap_ab_value,
        i.cap_ab_null);
    }

    // lanes_ba
    //
    {
      int& v =
        o.lanes_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_ba_value,
        i.lanes_ba_null);
    }

    // speed_ba
    //
    {
      double& v =
        o.speed_ba;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_ba_value,
        i.speed_ba_null);
    }

    // fspd_ba
    //
    {
      double& v =
        o.fspd_ba;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.fspd_ba_value,
        i.fspd_ba_null);
    }

    // cap_ba
    //
    {
      int& v =
        o.cap_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cap_ba_value,
        i.cap_ba_null);
    }

    // left_ab
    //
    {
      int& v =
        o.left_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.left_ab_value,
        i.left_ab_null);
    }

    // right_ab
    //
    {
      int& v =
        o.right_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.right_ab_value,
        i.right_ab_null);
    }

    // left_ba
    //
    {
      int& v =
        o.left_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.left_ba_value,
        i.left_ba_null);
    }

    // right_ba
    //
    {
      int& v =
        o.right_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.right_ba_value,
        i.right_ba_null);
    }
  }

  void access::object_traits< ::pio::Link >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Link >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Link >::persist_statement[] =
  "INSERT INTO \"Link\" ("
  "\"link\","
  "\"name\","
  "\"node_a\","
  "\"node_b\","
  "\"length\","
  "\"setback_a\","
  "\"setback_b\","
  "\"bearing_a\","
  "\"bearing_b\","
  "\"type\","
  "\"divided\","
  "\"area_type\","
  "\"use\","
  "\"grade\","
  "\"lanes_ab\","
  "\"speed_ab\","
  "\"fspd_ab\","
  "\"cap_ab\","
  "\"lanes_ba\","
  "\"speed_ba\","
  "\"fspd_ba\","
  "\"cap_ba\","
  "\"left_ab\","
  "\"right_ab\","
  "\"left_ba\","
  "\"right_ba\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Link >::find_statement[] =
  "SELECT "
  "\"Link\".\"link\","
  "\"Link\".\"name\","
  "\"Link\".\"node_a\","
  "\"Link\".\"node_b\","
  "\"Link\".\"length\","
  "\"Link\".\"setback_a\","
  "\"Link\".\"setback_b\","
  "\"Link\".\"bearing_a\","
  "\"Link\".\"bearing_b\","
  "\"Link\".\"type\","
  "\"Link\".\"divided\","
  "\"Link\".\"area_type\","
  "\"Link\".\"use\","
  "\"Link\".\"grade\","
  "\"Link\".\"lanes_ab\","
  "\"Link\".\"speed_ab\","
  "\"Link\".\"fspd_ab\","
  "\"Link\".\"cap_ab\","
  "\"Link\".\"lanes_ba\","
  "\"Link\".\"speed_ba\","
  "\"Link\".\"fspd_ba\","
  "\"Link\".\"cap_ba\","
  "\"Link\".\"left_ab\","
  "\"Link\".\"right_ab\","
  "\"Link\".\"left_ba\","
  "\"Link\".\"right_ba\""
  " FROM \"Link\""
  " WHERE \"Link\".\"link\"=?";

  const char access::object_traits< ::pio::Link >::update_statement[] =
  "UPDATE \"Link\" SET "
  "\"name\"=?,"
  "\"node_a\"=?,"
  "\"node_b\"=?,"
  "\"length\"=?,"
  "\"setback_a\"=?,"
  "\"setback_b\"=?,"
  "\"bearing_a\"=?,"
  "\"bearing_b\"=?,"
  "\"type\"=?,"
  "\"divided\"=?,"
  "\"area_type\"=?,"
  "\"use\"=?,"
  "\"grade\"=?,"
  "\"lanes_ab\"=?,"
  "\"speed_ab\"=?,"
  "\"fspd_ab\"=?,"
  "\"cap_ab\"=?,"
  "\"lanes_ba\"=?,"
  "\"speed_ba\"=?,"
  "\"fspd_ba\"=?,"
  "\"cap_ba\"=?,"
  "\"left_ab\"=?,"
  "\"right_ab\"=?,"
  "\"left_ba\"=?,"
  "\"right_ba\"=?"
  " WHERE \"link\"=?";

  const char access::object_traits< ::pio::Link >::erase_statement[] =
  "DELETE FROM \"Link\""
  " WHERE \"link\"=?";

  const char access::object_traits< ::pio::Link >::query_statement[] =
  "SELECT "
  "\"Link\".\"link\","
  "\"Link\".\"name\","
  "\"Link\".\"node_a\","
  "\"Link\".\"node_b\","
  "\"Link\".\"length\","
  "\"Link\".\"setback_a\","
  "\"Link\".\"setback_b\","
  "\"Link\".\"bearing_a\","
  "\"Link\".\"bearing_b\","
  "\"Link\".\"type\","
  "\"Link\".\"divided\","
  "\"Link\".\"area_type\","
  "\"Link\".\"use\","
  "\"Link\".\"grade\","
  "\"Link\".\"lanes_ab\","
  "\"Link\".\"speed_ab\","
  "\"Link\".\"fspd_ab\","
  "\"Link\".\"cap_ab\","
  "\"Link\".\"lanes_ba\","
  "\"Link\".\"speed_ba\","
  "\"Link\".\"fspd_ba\","
  "\"Link\".\"cap_ba\","
  "\"Link\".\"left_ab\","
  "\"Link\".\"right_ab\","
  "\"Link\".\"left_ba\","
  "\"Link\".\"right_ba\""
  " FROM \"Link\""
  " LEFT JOIN \"Node\" AS \"node_a\" ON \"node_a\".\"node\"=\"Link\".\"node_a\""
  " LEFT JOIN \"Node\" AS \"node_b\" ON \"node_b\".\"node\"=\"Link\".\"node_b\""
  " ";

  const char access::object_traits< ::pio::Link >::erase_query_statement[] =
  "DELETE FROM \"Link\""
  " ";

  const char access::object_traits< ::pio::Link >::table_name[] =
  "\"Link\"";

  void access::object_traits< ::pio::Link >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Link >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.link);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Link >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Link >::pointer_type
  access::object_traits< ::pio::Link >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Link >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Link >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.link);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Link >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Link >::object_type >
  access::object_traits< ::pio::Link >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Link >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Link >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Link\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Link\" (\n"
                      "  \"link\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"node_a\" INTEGER,\n"
                      "  \"node_b\" INTEGER,\n"
                      "  \"length\" REAL,\n"
                      "  \"setback_a\" REAL,\n"
                      "  \"setback_b\" REAL,\n"
                      "  \"bearing_a\" INTEGER NOT NULL,\n"
                      "  \"bearing_b\" INTEGER NOT NULL,\n"
                      "  \"type\" TEXT NOT NULL,\n"
                      "  \"divided\" INTEGER NOT NULL,\n"
                      "  \"area_type\" INTEGER NOT NULL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"grade\" REAL,\n"
                      "  \"lanes_ab\" INTEGER NOT NULL,\n"
                      "  \"speed_ab\" REAL,\n"
                      "  \"fspd_ab\" REAL,\n"
                      "  \"cap_ab\" INTEGER NOT NULL,\n"
                      "  \"lanes_ba\" INTEGER NOT NULL,\n"
                      "  \"speed_ba\" REAL,\n"
                      "  \"fspd_ba\" REAL,\n"
                      "  \"cap_ba\" INTEGER NOT NULL,\n"
                      "  \"left_ab\" INTEGER NOT NULL,\n"
                      "  \"right_ab\" INTEGER NOT NULL,\n"
                      "  \"left_ba\" INTEGER NOT NULL,\n"
                      "  \"right_ba\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"node_a_fk\"\n"
                      "    FOREIGN KEY (\"node_a\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"node_b_fk\"\n"
                      "    FOREIGN KEY (\"node_b\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Link_ (
    "",
    &access::object_traits< ::pio::Link >::create_schema);

  // Pocket
  //

  access::object_traits< ::pio::Pocket >::id_type
  access::object_traits< ::pio::Pocket >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Pocket >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // type
    //
    if (t[3UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // lanes
    //
    t[4UL] = false;

    // length
    //
    t[5UL] = false;

    // offset
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Pocket >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;
  }

  void access::object_traits< ::pio::Pocket >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Pocket >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Pocket >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }
  }

  void access::object_traits< ::pio::Pocket >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Pocket >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Pocket >::persist_statement[] =
  "INSERT INTO \"Pocket\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"type\","
  "\"lanes\","
  "\"length\","
  "\"offset\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Pocket >::find_statement[] =
  "SELECT "
  "\"Pocket\".\"auto_id\","
  "\"Pocket\".\"link\","
  "\"Pocket\".\"dir\","
  "\"Pocket\".\"type\","
  "\"Pocket\".\"lanes\","
  "\"Pocket\".\"length\","
  "\"Pocket\".\"offset\""
  " FROM \"Pocket\""
  " WHERE \"Pocket\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Pocket >::update_statement[] =
  "UPDATE \"Pocket\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"type\"=?,"
  "\"lanes\"=?,"
  "\"length\"=?,"
  "\"offset\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Pocket >::erase_statement[] =
  "DELETE FROM \"Pocket\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Pocket >::query_statement[] =
  "SELECT "
  "\"Pocket\".\"auto_id\","
  "\"Pocket\".\"link\","
  "\"Pocket\".\"dir\","
  "\"Pocket\".\"type\","
  "\"Pocket\".\"lanes\","
  "\"Pocket\".\"length\","
  "\"Pocket\".\"offset\""
  " FROM \"Pocket\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Pocket\".\"link\""
  " ";

  const char access::object_traits< ::pio::Pocket >::erase_query_statement[] =
  "DELETE FROM \"Pocket\""
  " ";

  const char access::object_traits< ::pio::Pocket >::table_name[] =
  "\"Pocket\"";

  void access::object_traits< ::pio::Pocket >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Pocket >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Pocket >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Pocket >::pointer_type
  access::object_traits< ::pio::Pocket >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Pocket >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Pocket >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Pocket >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Pocket >::object_type >
  access::object_traits< ::pio::Pocket >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Pocket >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Pocket >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Pocket\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Pocket\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"type\" TEXT NOT NULL,\n"
                      "  \"lanes\" INTEGER NOT NULL,\n"
                      "  \"length\" REAL,\n"
                      "  \"offset\" REAL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Pocket_ (
    "",
    &access::object_traits< ::pio::Pocket >::create_schema);

  // Lane_Use
  //

  access::object_traits< ::pio::Lane_Use >::id_type
  access::object_traits< ::pio::Lane_Use >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // lanes
    //
    t[3UL] = false;

    // use
    //
    t[4UL] = false;

    // type
    //
    t[5UL] = false;

    // min_type
    //
    t[6UL] = false;

    // max_type
    //
    t[7UL] = false;

    // min_trav
    //
    t[8UL] = false;

    // max_trav
    //
    t[9UL] = false;

    // start
    //
    t[10UL] = false;

    // end
    //
    t[11UL] = false;

    // offset
    //
    t[12UL] = false;

    // length
    //
    t[13UL] = false;

    // toll
    //
    t[14UL] = false;

    // rate
    //
    t[15UL] = false;

    // min_delay
    //
    t[16UL] = false;

    // max_delay
    //
    t[17UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Lane_Use >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // min_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_type_value;
    b[n].is_null = &i.min_type_null;
    n++;

    // max_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_type_value;
    b[n].is_null = &i.max_type_null;
    n++;

    // min_trav
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_trav_value;
    b[n].is_null = &i.min_trav_null;
    n++;

    // max_trav
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_trav_value;
    b[n].is_null = &i.max_trav_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // toll
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.toll_value;
    b[n].is_null = &i.toll_null;
    n++;

    // rate
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.rate_value;
    b[n].is_null = &i.rate_null;
    n++;

    // min_delay
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_delay_value;
    b[n].is_null = &i.min_delay_null;
    n++;

    // max_delay
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_delay_value;
    b[n].is_null = &i.max_delay_null;
    n++;
  }

  void access::object_traits< ::pio::Lane_Use >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // min_type
    //
    {
      int const& v =
        o.min_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_type_value,
        is_null,
        v);
      i.min_type_null = is_null;
    }

    // max_type
    //
    {
      int const& v =
        o.max_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_type_value,
        is_null,
        v);
      i.max_type_null = is_null;
    }

    // min_trav
    //
    {
      int const& v =
        o.min_trav;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_trav_value,
        is_null,
        v);
      i.min_trav_null = is_null;
    }

    // max_trav
    //
    {
      int const& v =
        o.max_trav;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_trav_value,
        is_null,
        v);
      i.max_trav_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // toll
    //
    {
      int const& v =
        o.toll;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.toll_value,
        is_null,
        v);
      i.toll_null = is_null;
    }

    // rate
    //
    {
      double const& v =
        o.rate;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.rate_value,
        is_null,
        v);
      i.rate_null = is_null;
    }

    // min_delay
    //
    {
      double const& v =
        o.min_delay;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_delay_value,
        is_null,
        v);
      i.min_delay_null = is_null;
    }

    // max_delay
    //
    {
      double const& v =
        o.max_delay;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_delay_value,
        is_null,
        v);
      i.max_delay_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Lane_Use >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // min_type
    //
    {
      int& v =
        o.min_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_type_value,
        i.min_type_null);
    }

    // max_type
    //
    {
      int& v =
        o.max_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_type_value,
        i.max_type_null);
    }

    // min_trav
    //
    {
      int& v =
        o.min_trav;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_trav_value,
        i.min_trav_null);
    }

    // max_trav
    //
    {
      int& v =
        o.max_trav;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_trav_value,
        i.max_trav_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // toll
    //
    {
      int& v =
        o.toll;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.toll_value,
        i.toll_null);
    }

    // rate
    //
    {
      double& v =
        o.rate;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.rate_value,
        i.rate_null);
    }

    // min_delay
    //
    {
      double& v =
        o.min_delay;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_delay_value,
        i.min_delay_null);
    }

    // max_delay
    //
    {
      double& v =
        o.max_delay;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_delay_value,
        i.max_delay_null);
    }
  }

  void access::object_traits< ::pio::Lane_Use >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Lane_Use >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Lane_Use >::persist_statement[] =
  "INSERT INTO \"Lane_Use\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"lanes\","
  "\"use\","
  "\"type\","
  "\"min_type\","
  "\"max_type\","
  "\"min_trav\","
  "\"max_trav\","
  "\"start\","
  "\"end\","
  "\"offset\","
  "\"length\","
  "\"toll\","
  "\"rate\","
  "\"min_delay\","
  "\"max_delay\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Lane_Use >::find_statement[] =
  "SELECT "
  "\"Lane_Use\".\"auto_id\","
  "\"Lane_Use\".\"link\","
  "\"Lane_Use\".\"dir\","
  "\"Lane_Use\".\"lanes\","
  "\"Lane_Use\".\"use\","
  "\"Lane_Use\".\"type\","
  "\"Lane_Use\".\"min_type\","
  "\"Lane_Use\".\"max_type\","
  "\"Lane_Use\".\"min_trav\","
  "\"Lane_Use\".\"max_trav\","
  "\"Lane_Use\".\"start\","
  "\"Lane_Use\".\"end\","
  "\"Lane_Use\".\"offset\","
  "\"Lane_Use\".\"length\","
  "\"Lane_Use\".\"toll\","
  "\"Lane_Use\".\"rate\","
  "\"Lane_Use\".\"min_delay\","
  "\"Lane_Use\".\"max_delay\""
  " FROM \"Lane_Use\""
  " WHERE \"Lane_Use\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Lane_Use >::update_statement[] =
  "UPDATE \"Lane_Use\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"lanes\"=?,"
  "\"use\"=?,"
  "\"type\"=?,"
  "\"min_type\"=?,"
  "\"max_type\"=?,"
  "\"min_trav\"=?,"
  "\"max_trav\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"offset\"=?,"
  "\"length\"=?,"
  "\"toll\"=?,"
  "\"rate\"=?,"
  "\"min_delay\"=?,"
  "\"max_delay\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Lane_Use >::erase_statement[] =
  "DELETE FROM \"Lane_Use\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Lane_Use >::query_statement[] =
  "SELECT "
  "\"Lane_Use\".\"auto_id\","
  "\"Lane_Use\".\"link\","
  "\"Lane_Use\".\"dir\","
  "\"Lane_Use\".\"lanes\","
  "\"Lane_Use\".\"use\","
  "\"Lane_Use\".\"type\","
  "\"Lane_Use\".\"min_type\","
  "\"Lane_Use\".\"max_type\","
  "\"Lane_Use\".\"min_trav\","
  "\"Lane_Use\".\"max_trav\","
  "\"Lane_Use\".\"start\","
  "\"Lane_Use\".\"end\","
  "\"Lane_Use\".\"offset\","
  "\"Lane_Use\".\"length\","
  "\"Lane_Use\".\"toll\","
  "\"Lane_Use\".\"rate\","
  "\"Lane_Use\".\"min_delay\","
  "\"Lane_Use\".\"max_delay\""
  " FROM \"Lane_Use\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Lane_Use\".\"link\""
  " ";

  const char access::object_traits< ::pio::Lane_Use >::erase_query_statement[] =
  "DELETE FROM \"Lane_Use\""
  " ";

  const char access::object_traits< ::pio::Lane_Use >::table_name[] =
  "\"Lane_Use\"";

  void access::object_traits< ::pio::Lane_Use >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Lane_Use >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Lane_Use >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Lane_Use >::pointer_type
  access::object_traits< ::pio::Lane_Use >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Lane_Use >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Lane_Use >::object_type >
  access::object_traits< ::pio::Lane_Use >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Lane_Use >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Lane_Use >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Lane_Use\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Lane_Use\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"lanes\" INTEGER NOT NULL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"min_type\" INTEGER NOT NULL,\n"
                      "  \"max_type\" INTEGER NOT NULL,\n"
                      "  \"min_trav\" INTEGER NOT NULL,\n"
                      "  \"max_trav\" INTEGER NOT NULL,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"length\" REAL,\n"
                      "  \"toll\" INTEGER NOT NULL,\n"
                      "  \"rate\" REAL,\n"
                      "  \"min_delay\" REAL,\n"
                      "  \"max_delay\" REAL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Lane_Use_ (
    "",
    &access::object_traits< ::pio::Lane_Use >::create_schema);

  // Connect
  //

  access::object_traits< ::pio::Connect >::id_type
  access::object_traits< ::pio::Connect >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Connect >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // to_link
    //
    t[3UL] = false;

    // lanes
    //
    if (t[4UL])
    {
      i.lanes_value.capacity (i.lanes_size);
      grew = true;
    }

    // to_lanes
    //
    if (t[5UL])
    {
      i.to_lanes_value.capacity (i.to_lanes_size);
      grew = true;
    }

    // type
    //
    if (t[6UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // penalty
    //
    t[7UL] = false;

    // speed
    //
    t[8UL] = false;

    // capacity
    //
    t[9UL] = false;

    // in_high
    //
    t[10UL] = false;

    // out_high
    //
    t[11UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Connect >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.lanes_value.data ();
    b[n].size = &i.lanes_size;
    b[n].capacity = i.lanes_value.capacity ();
    b[n].is_null = &i.lanes_null;
    n++;

    // to_lanes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.to_lanes_value.data ();
    b[n].size = &i.to_lanes_size;
    b[n].capacity = i.to_lanes_value.capacity ();
    b[n].is_null = &i.to_lanes_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // penalty
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.penalty_value;
    b[n].is_null = &i.penalty_null;
    n++;

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;

    // capacity
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.capacity_value;
    b[n].is_null = &i.capacity_null;
    n++;

    // in_high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.in_high_value;
    b[n].is_null = &i.in_high_null;
    n++;

    // out_high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.out_high_value;
    b[n].is_null = &i.out_high_null;
    n++;
  }

  void access::object_traits< ::pio::Connect >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Connect >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // lanes
    //
    {
      ::std::string const& v =
        o.lanes;

      bool is_null (false);
      std::size_t cap (i.lanes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.lanes_value,
        i.lanes_size,
        is_null,
        v);
      i.lanes_null = is_null;
      grew = grew || (cap != i.lanes_value.capacity ());
    }

    // to_lanes
    //
    {
      ::std::string const& v =
        o.to_lanes;

      bool is_null (false);
      std::size_t cap (i.to_lanes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.to_lanes_value,
        i.to_lanes_size,
        is_null,
        v);
      i.to_lanes_null = is_null;
      grew = grew || (cap != i.to_lanes_value.capacity ());
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // penalty
    //
    {
      int const& v =
        o.penalty;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.penalty_value,
        is_null,
        v);
      i.penalty_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    // capacity
    //
    {
      int const& v =
        o.capacity;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.capacity_value,
        is_null,
        v);
      i.capacity_null = is_null;
    }

    // in_high
    //
    {
      int const& v =
        o.in_high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.in_high_value,
        is_null,
        v);
      i.in_high_null = is_null;
    }

    // out_high
    //
    {
      int const& v =
        o.out_high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.out_high_value,
        is_null,
        v);
      i.out_high_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Connect >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // lanes
    //
    {
      ::std::string& v =
        o.lanes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.lanes_value,
        i.lanes_size,
        i.lanes_null);
    }

    // to_lanes
    //
    {
      ::std::string& v =
        o.to_lanes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.to_lanes_value,
        i.to_lanes_size,
        i.to_lanes_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // penalty
    //
    {
      int& v =
        o.penalty;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.penalty_value,
        i.penalty_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }

    // capacity
    //
    {
      int& v =
        o.capacity;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.capacity_value,
        i.capacity_null);
    }

    // in_high
    //
    {
      int& v =
        o.in_high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.in_high_value,
        i.in_high_null);
    }

    // out_high
    //
    {
      int& v =
        o.out_high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.out_high_value,
        i.out_high_null);
    }
  }

  void access::object_traits< ::pio::Connect >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Connect >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Connect >::persist_statement[] =
  "INSERT INTO \"Connect\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"to_link\","
  "\"lanes\","
  "\"to_lanes\","
  "\"type\","
  "\"penalty\","
  "\"speed\","
  "\"capacity\","
  "\"in_high\","
  "\"out_high\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Connect >::find_statement[] =
  "SELECT "
  "\"Connect\".\"auto_id\","
  "\"Connect\".\"link\","
  "\"Connect\".\"dir\","
  "\"Connect\".\"to_link\","
  "\"Connect\".\"lanes\","
  "\"Connect\".\"to_lanes\","
  "\"Connect\".\"type\","
  "\"Connect\".\"penalty\","
  "\"Connect\".\"speed\","
  "\"Connect\".\"capacity\","
  "\"Connect\".\"in_high\","
  "\"Connect\".\"out_high\""
  " FROM \"Connect\""
  " WHERE \"Connect\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Connect >::update_statement[] =
  "UPDATE \"Connect\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"to_link\"=?,"
  "\"lanes\"=?,"
  "\"to_lanes\"=?,"
  "\"type\"=?,"
  "\"penalty\"=?,"
  "\"speed\"=?,"
  "\"capacity\"=?,"
  "\"in_high\"=?,"
  "\"out_high\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Connect >::erase_statement[] =
  "DELETE FROM \"Connect\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Connect >::query_statement[] =
  "SELECT "
  "\"Connect\".\"auto_id\","
  "\"Connect\".\"link\","
  "\"Connect\".\"dir\","
  "\"Connect\".\"to_link\","
  "\"Connect\".\"lanes\","
  "\"Connect\".\"to_lanes\","
  "\"Connect\".\"type\","
  "\"Connect\".\"penalty\","
  "\"Connect\".\"speed\","
  "\"Connect\".\"capacity\","
  "\"Connect\".\"in_high\","
  "\"Connect\".\"out_high\""
  " FROM \"Connect\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Connect\".\"link\""
  " LEFT JOIN \"Link\" AS \"to_link\" ON \"to_link\".\"link\"=\"Connect\".\"to_link\""
  " ";

  const char access::object_traits< ::pio::Connect >::erase_query_statement[] =
  "DELETE FROM \"Connect\""
  " ";

  const char access::object_traits< ::pio::Connect >::table_name[] =
  "\"Connect\"";

  void access::object_traits< ::pio::Connect >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Connect >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Connect >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Connect >::pointer_type
  access::object_traits< ::pio::Connect >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Connect >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Connect >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Connect >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Connect >::object_type >
  access::object_traits< ::pio::Connect >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Connect >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Connect >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Connect\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Connect\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"to_link\" INTEGER,\n"
                      "  \"lanes\" TEXT NOT NULL,\n"
                      "  \"to_lanes\" TEXT NOT NULL,\n"
                      "  \"type\" TEXT NOT NULL,\n"
                      "  \"penalty\" INTEGER NOT NULL,\n"
                      "  \"speed\" REAL,\n"
                      "  \"capacity\" INTEGER NOT NULL,\n"
                      "  \"in_high\" INTEGER NOT NULL,\n"
                      "  \"out_high\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"to_link_fk\"\n"
                      "    FOREIGN KEY (\"to_link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Connect_ (
    "",
    &access::object_traits< ::pio::Connect >::create_schema);

  // Turn_Pen
  //

  access::object_traits< ::pio::Turn_Pen >::id_type
  access::object_traits< ::pio::Turn_Pen >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // to_link
    //
    t[3UL] = false;

    // start
    //
    t[4UL] = false;

    // end
    //
    t[5UL] = false;

    // use
    //
    t[6UL] = false;

    // min_type
    //
    t[7UL] = false;

    // max_type
    //
    t[8UL] = false;

    // penalty
    //
    t[9UL] = false;

    // in_node
    //
    t[10UL] = false;

    // out_node
    //
    t[11UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Turn_Pen >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // min_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_type_value;
    b[n].is_null = &i.min_type_null;
    n++;

    // max_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_type_value;
    b[n].is_null = &i.max_type_null;
    n++;

    // penalty
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.penalty_value;
    b[n].is_null = &i.penalty_null;
    n++;

    // in_node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.in_node_value;
    b[n].is_null = &i.in_node_null;
    n++;

    // out_node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.out_node_value;
    b[n].is_null = &i.out_node_null;
    n++;
  }

  void access::object_traits< ::pio::Turn_Pen >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // min_type
    //
    {
      int const& v =
        o.min_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_type_value,
        is_null,
        v);
      i.min_type_null = is_null;
    }

    // max_type
    //
    {
      int const& v =
        o.max_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_type_value,
        is_null,
        v);
      i.max_type_null = is_null;
    }

    // penalty
    //
    {
      int const& v =
        o.penalty;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.penalty_value,
        is_null,
        v);
      i.penalty_null = is_null;
    }

    // in_node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.in_node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.in_node_value,
          is_null,
          id);
        i.in_node_null = is_null;
      }
      else
        i.in_node_null = true;
    }

    // out_node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.out_node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.out_node_value,
          is_null,
          id);
        i.out_node_null = is_null;
      }
      else
        i.out_node_null = true;
    }

    return grew;
  }

  void access::object_traits< ::pio::Turn_Pen >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // min_type
    //
    {
      int& v =
        o.min_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_type_value,
        i.min_type_null);
    }

    // max_type
    //
    {
      int& v =
        o.max_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_type_value,
        i.max_type_null);
    }

    // penalty
    //
    {
      int& v =
        o.penalty;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.penalty_value,
        i.penalty_null);
    }

    // in_node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.in_node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.in_node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.in_node_value,
          i.in_node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // out_node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.out_node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.out_node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.out_node_value,
          i.out_node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits< ::pio::Turn_Pen >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Turn_Pen >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Turn_Pen >::persist_statement[] =
  "INSERT INTO \"Turn_Pen\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"to_link\","
  "\"start\","
  "\"end\","
  "\"use\","
  "\"min_type\","
  "\"max_type\","
  "\"penalty\","
  "\"in_node\","
  "\"out_node\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Turn_Pen >::find_statement[] =
  "SELECT "
  "\"Turn_Pen\".\"auto_id\","
  "\"Turn_Pen\".\"link\","
  "\"Turn_Pen\".\"dir\","
  "\"Turn_Pen\".\"to_link\","
  "\"Turn_Pen\".\"start\","
  "\"Turn_Pen\".\"end\","
  "\"Turn_Pen\".\"use\","
  "\"Turn_Pen\".\"min_type\","
  "\"Turn_Pen\".\"max_type\","
  "\"Turn_Pen\".\"penalty\","
  "\"Turn_Pen\".\"in_node\","
  "\"Turn_Pen\".\"out_node\""
  " FROM \"Turn_Pen\""
  " WHERE \"Turn_Pen\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Turn_Pen >::update_statement[] =
  "UPDATE \"Turn_Pen\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"to_link\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"use\"=?,"
  "\"min_type\"=?,"
  "\"max_type\"=?,"
  "\"penalty\"=?,"
  "\"in_node\"=?,"
  "\"out_node\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Turn_Pen >::erase_statement[] =
  "DELETE FROM \"Turn_Pen\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Turn_Pen >::query_statement[] =
  "SELECT "
  "\"Turn_Pen\".\"auto_id\","
  "\"Turn_Pen\".\"link\","
  "\"Turn_Pen\".\"dir\","
  "\"Turn_Pen\".\"to_link\","
  "\"Turn_Pen\".\"start\","
  "\"Turn_Pen\".\"end\","
  "\"Turn_Pen\".\"use\","
  "\"Turn_Pen\".\"min_type\","
  "\"Turn_Pen\".\"max_type\","
  "\"Turn_Pen\".\"penalty\","
  "\"Turn_Pen\".\"in_node\","
  "\"Turn_Pen\".\"out_node\""
  " FROM \"Turn_Pen\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Turn_Pen\".\"link\""
  " LEFT JOIN \"Link\" AS \"to_link\" ON \"to_link\".\"link\"=\"Turn_Pen\".\"to_link\""
  " LEFT JOIN \"Node\" AS \"in_node\" ON \"in_node\".\"node\"=\"Turn_Pen\".\"in_node\""
  " LEFT JOIN \"Node\" AS \"out_node\" ON \"out_node\".\"node\"=\"Turn_Pen\".\"out_node\""
  " ";

  const char access::object_traits< ::pio::Turn_Pen >::erase_query_statement[] =
  "DELETE FROM \"Turn_Pen\""
  " ";

  const char access::object_traits< ::pio::Turn_Pen >::table_name[] =
  "\"Turn_Pen\"";

  void access::object_traits< ::pio::Turn_Pen >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Turn_Pen >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Turn_Pen >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Turn_Pen >::pointer_type
  access::object_traits< ::pio::Turn_Pen >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Turn_Pen >::object_type >
  access::object_traits< ::pio::Turn_Pen >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Turn_Pen >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Turn_Pen >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Turn_Pen\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Turn_Pen\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"to_link\" INTEGER,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"min_type\" INTEGER NOT NULL,\n"
                      "  \"max_type\" INTEGER NOT NULL,\n"
                      "  \"penalty\" INTEGER NOT NULL,\n"
                      "  \"in_node\" INTEGER,\n"
                      "  \"out_node\" INTEGER,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"to_link_fk\"\n"
                      "    FOREIGN KEY (\"to_link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"in_node_fk\"\n"
                      "    FOREIGN KEY (\"in_node\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"out_node_fk\"\n"
                      "    FOREIGN KEY (\"out_node\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Turn_Pen_ (
    "",
    &access::object_traits< ::pio::Turn_Pen >::create_schema);

  // Parking
  //

  access::object_traits< ::pio::Parking >::id_type
  access::object_traits< ::pio::Parking >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.parking_value,
        i.parking_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Parking >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // parking
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // type
    //
    t[4UL] = false;

    // use
    //
    t[5UL] = false;

    // start
    //
    t[6UL] = false;

    // end
    //
    t[7UL] = false;

    // space
    //
    t[8UL] = false;

    // time_in
    //
    t[9UL] = false;

    // time_out
    //
    t[10UL] = false;

    // hourly
    //
    t[11UL] = false;

    // daily
    //
    t[12UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Parking >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // parking
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.parking_value;
      b[n].is_null = &i.parking_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // space
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.space_value;
    b[n].is_null = &i.space_null;
    n++;

    // time_in
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_in_value;
    b[n].is_null = &i.time_in_null;
    n++;

    // time_out
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_out_value;
    b[n].is_null = &i.time_out_null;
    n++;

    // hourly
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hourly_value;
    b[n].is_null = &i.hourly_null;
    n++;

    // daily
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.daily_value;
    b[n].is_null = &i.daily_null;
    n++;
  }

  void access::object_traits< ::pio::Parking >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Parking >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // parking
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.parking;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.parking_value,
        is_null,
        v);
      i.parking_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // space
    //
    {
      int const& v =
        o.space;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.space_value,
        is_null,
        v);
      i.space_null = is_null;
    }

    // time_in
    //
    {
      double const& v =
        o.time_in;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_in_value,
        is_null,
        v);
      i.time_in_null = is_null;
    }

    // time_out
    //
    {
      double const& v =
        o.time_out;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_out_value,
        is_null,
        v);
      i.time_out_null = is_null;
    }

    // hourly
    //
    {
      int const& v =
        o.hourly;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hourly_value,
        is_null,
        v);
      i.hourly_null = is_null;
    }

    // daily
    //
    {
      int const& v =
        o.daily;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.daily_value,
        is_null,
        v);
      i.daily_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Parking >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // parking
    //
    {
      int& v =
        o.parking;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.parking_value,
        i.parking_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // space
    //
    {
      int& v =
        o.space;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.space_value,
        i.space_null);
    }

    // time_in
    //
    {
      double& v =
        o.time_in;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_in_value,
        i.time_in_null);
    }

    // time_out
    //
    {
      double& v =
        o.time_out;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_out_value,
        i.time_out_null);
    }

    // hourly
    //
    {
      int& v =
        o.hourly;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hourly_value,
        i.hourly_null);
    }

    // daily
    //
    {
      int& v =
        o.daily;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.daily_value,
        i.daily_null);
    }
  }

  void access::object_traits< ::pio::Parking >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Parking >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Parking >::persist_statement[] =
  "INSERT INTO \"Parking\" ("
  "\"parking\","
  "\"link\","
  "\"dir\","
  "\"offset\","
  "\"type\","
  "\"use\","
  "\"start\","
  "\"end\","
  "\"space\","
  "\"time_in\","
  "\"time_out\","
  "\"hourly\","
  "\"daily\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Parking >::find_statement[] =
  "SELECT "
  "\"Parking\".\"parking\","
  "\"Parking\".\"link\","
  "\"Parking\".\"dir\","
  "\"Parking\".\"offset\","
  "\"Parking\".\"type\","
  "\"Parking\".\"use\","
  "\"Parking\".\"start\","
  "\"Parking\".\"end\","
  "\"Parking\".\"space\","
  "\"Parking\".\"time_in\","
  "\"Parking\".\"time_out\","
  "\"Parking\".\"hourly\","
  "\"Parking\".\"daily\""
  " FROM \"Parking\""
  " WHERE \"Parking\".\"parking\"=?";

  const char access::object_traits< ::pio::Parking >::update_statement[] =
  "UPDATE \"Parking\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"offset\"=?,"
  "\"type\"=?,"
  "\"use\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"space\"=?,"
  "\"time_in\"=?,"
  "\"time_out\"=?,"
  "\"hourly\"=?,"
  "\"daily\"=?"
  " WHERE \"parking\"=?";

  const char access::object_traits< ::pio::Parking >::erase_statement[] =
  "DELETE FROM \"Parking\""
  " WHERE \"parking\"=?";

  const char access::object_traits< ::pio::Parking >::query_statement[] =
  "SELECT "
  "\"Parking\".\"parking\","
  "\"Parking\".\"link\","
  "\"Parking\".\"dir\","
  "\"Parking\".\"offset\","
  "\"Parking\".\"type\","
  "\"Parking\".\"use\","
  "\"Parking\".\"start\","
  "\"Parking\".\"end\","
  "\"Parking\".\"space\","
  "\"Parking\".\"time_in\","
  "\"Parking\".\"time_out\","
  "\"Parking\".\"hourly\","
  "\"Parking\".\"daily\""
  " FROM \"Parking\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Parking\".\"link\""
  " ";

  const char access::object_traits< ::pio::Parking >::erase_query_statement[] =
  "DELETE FROM \"Parking\""
  " ";

  const char access::object_traits< ::pio::Parking >::table_name[] =
  "\"Parking\"";

  void access::object_traits< ::pio::Parking >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Parking >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.parking);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Parking >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Parking >::pointer_type
  access::object_traits< ::pio::Parking >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Parking >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Parking >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.parking);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Parking >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Parking >::object_type >
  access::object_traits< ::pio::Parking >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Parking >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Parking >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Parking\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Parking\" (\n"
                      "  \"parking\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"space\" INTEGER NOT NULL,\n"
                      "  \"time_in\" REAL,\n"
                      "  \"time_out\" REAL,\n"
                      "  \"hourly\" INTEGER NOT NULL,\n"
                      "  \"daily\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Parking_ (
    "",
    &access::object_traits< ::pio::Parking >::create_schema);

  // Location
  //

  access::object_traits< ::pio::Location >::id_type
  access::object_traits< ::pio::Location >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.location_value,
        i.location_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Location >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // location
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // setback
    //
    t[4UL] = false;

    // zone
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Location >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // location
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.location_value;
      b[n].is_null = &i.location_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // setback
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_value;
    b[n].is_null = &i.setback_null;
    n++;

    // zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.zone_value;
    b[n].is_null = &i.zone_null;
    n++;
  }

  void access::object_traits< ::pio::Location >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Location >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // location
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.location;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.location_value,
        is_null,
        v);
      i.location_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // setback
    //
    {
      double const& v =
        o.setback;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_value,
        is_null,
        v);
      i.setback_null = is_null;
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone > const& v =
        o.zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.zone_value,
          is_null,
          id);
        i.zone_null = is_null;
      }
      else
        i.zone_null = true;
    }

    return grew;
  }

  void access::object_traits< ::pio::Location >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // location
    //
    {
      int& v =
        o.location;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.location_value,
        i.location_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // setback
    //
    {
      double& v =
        o.setback;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_value,
        i.setback_null);
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone >& v =
        o.zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      if (i.zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.zone_value,
          i.zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits< ::pio::Location >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Location >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Location >::persist_statement[] =
  "INSERT INTO \"Location\" ("
  "\"location\","
  "\"link\","
  "\"dir\","
  "\"offset\","
  "\"setback\","
  "\"zone\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Location >::find_statement[] =
  "SELECT "
  "\"Location\".\"location\","
  "\"Location\".\"link\","
  "\"Location\".\"dir\","
  "\"Location\".\"offset\","
  "\"Location\".\"setback\","
  "\"Location\".\"zone\""
  " FROM \"Location\""
  " WHERE \"Location\".\"location\"=?";

  const char access::object_traits< ::pio::Location >::update_statement[] =
  "UPDATE \"Location\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"offset\"=?,"
  "\"setback\"=?,"
  "\"zone\"=?"
  " WHERE \"location\"=?";

  const char access::object_traits< ::pio::Location >::erase_statement[] =
  "DELETE FROM \"Location\""
  " WHERE \"location\"=?";

  const char access::object_traits< ::pio::Location >::query_statement[] =
  "SELECT "
  "\"Location\".\"location\","
  "\"Location\".\"link\","
  "\"Location\".\"dir\","
  "\"Location\".\"offset\","
  "\"Location\".\"setback\","
  "\"Location\".\"zone\""
  " FROM \"Location\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Location\".\"link\""
  " LEFT JOIN \"Zone\" AS \"zone\" ON \"zone\".\"zone\"=\"Location\".\"zone\""
  " ";

  const char access::object_traits< ::pio::Location >::erase_query_statement[] =
  "DELETE FROM \"Location\""
  " ";

  const char access::object_traits< ::pio::Location >::table_name[] =
  "\"Location\"";

  void access::object_traits< ::pio::Location >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Location >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.location);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Location >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Location >::pointer_type
  access::object_traits< ::pio::Location >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Location >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Location >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.location);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Location >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Location >::object_type >
  access::object_traits< ::pio::Location >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Location >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Location >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Location\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Location\" (\n"
                      "  \"location\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"setback\" REAL,\n"
                      "  \"zone\" INTEGER,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"zone_fk\"\n"
                      "    FOREIGN KEY (\"zone\")\n"
                      "    REFERENCES \"Zone\" (\"zone\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Location_ (
    "",
    &access::object_traits< ::pio::Location >::create_schema);

  // Access
  //

  access::object_traits< ::pio::Access >::id_type
  access::object_traits< ::pio::Access >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Access >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // from_id
    //
    t[2UL] = false;

    // from_type
    //
    t[3UL] = false;

    // to_id
    //
    t[4UL] = false;

    // to_type
    //
    t[5UL] = false;

    // dir
    //
    t[6UL] = false;

    // time
    //
    t[7UL] = false;

    // cost
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Access >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // from_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_id_value;
    b[n].is_null = &i.from_id_null;
    n++;

    // from_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_type_value;
    b[n].is_null = &i.from_type_null;
    n++;

    // to_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_id_value;
    b[n].is_null = &i.to_id_null;
    n++;

    // to_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_type_value;
    b[n].is_null = &i.to_type_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // cost
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cost_value;
    b[n].is_null = &i.cost_null;
    n++;
  }

  void access::object_traits< ::pio::Access >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Access >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // from_id
    //
    {
      int const& v =
        o.from_id;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_id_value,
        is_null,
        v);
      i.from_id_null = is_null;
    }

    // from_type
    //
    {
      int const& v =
        o.from_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_type_value,
        is_null,
        v);
      i.from_type_null = is_null;
    }

    // to_id
    //
    {
      int const& v =
        o.to_id;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_id_value,
        is_null,
        v);
      i.to_id_null = is_null;
    }

    // to_type
    //
    {
      int const& v =
        o.to_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_type_value,
        is_null,
        v);
      i.to_type_null = is_null;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // cost
    //
    {
      int const& v =
        o.cost;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cost_value,
        is_null,
        v);
      i.cost_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Access >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // from_id
    //
    {
      int& v =
        o.from_id;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_id_value,
        i.from_id_null);
    }

    // from_type
    //
    {
      int& v =
        o.from_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_type_value,
        i.from_type_null);
    }

    // to_id
    //
    {
      int& v =
        o.to_id;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_id_value,
        i.to_id_null);
    }

    // to_type
    //
    {
      int& v =
        o.to_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_type_value,
        i.to_type_null);
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // cost
    //
    {
      int& v =
        o.cost;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cost_value,
        i.cost_null);
    }
  }

  void access::object_traits< ::pio::Access >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Access >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Access >::persist_statement[] =
  "INSERT INTO \"Access\" ("
  "\"auto_id\","
  "\"link\","
  "\"from_id\","
  "\"from_type\","
  "\"to_id\","
  "\"to_type\","
  "\"dir\","
  "\"time\","
  "\"cost\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Access >::find_statement[] =
  "SELECT "
  "\"Access\".\"auto_id\","
  "\"Access\".\"link\","
  "\"Access\".\"from_id\","
  "\"Access\".\"from_type\","
  "\"Access\".\"to_id\","
  "\"Access\".\"to_type\","
  "\"Access\".\"dir\","
  "\"Access\".\"time\","
  "\"Access\".\"cost\""
  " FROM \"Access\""
  " WHERE \"Access\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Access >::update_statement[] =
  "UPDATE \"Access\" SET "
  "\"link\"=?,"
  "\"from_id\"=?,"
  "\"from_type\"=?,"
  "\"to_id\"=?,"
  "\"to_type\"=?,"
  "\"dir\"=?,"
  "\"time\"=?,"
  "\"cost\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Access >::erase_statement[] =
  "DELETE FROM \"Access\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Access >::query_statement[] =
  "SELECT "
  "\"Access\".\"auto_id\","
  "\"Access\".\"link\","
  "\"Access\".\"from_id\","
  "\"Access\".\"from_type\","
  "\"Access\".\"to_id\","
  "\"Access\".\"to_type\","
  "\"Access\".\"dir\","
  "\"Access\".\"time\","
  "\"Access\".\"cost\""
  " FROM \"Access\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Access\".\"link\""
  " ";

  const char access::object_traits< ::pio::Access >::erase_query_statement[] =
  "DELETE FROM \"Access\""
  " ";

  const char access::object_traits< ::pio::Access >::table_name[] =
  "\"Access\"";

  void access::object_traits< ::pio::Access >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Access >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Access >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Access >::pointer_type
  access::object_traits< ::pio::Access >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Access >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Access >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Access >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Access >::object_type >
  access::object_traits< ::pio::Access >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Access >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Access >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Access\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Access\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"from_id\" INTEGER NOT NULL,\n"
                      "  \"from_type\" INTEGER NOT NULL,\n"
                      "  \"to_id\" INTEGER NOT NULL,\n"
                      "  \"to_type\" INTEGER NOT NULL,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"time\" REAL,\n"
                      "  \"cost\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Access_ (
    "",
    &access::object_traits< ::pio::Access >::create_schema);

  // Sign
  //

  access::object_traits< ::pio::Sign >::id_type
  access::object_traits< ::pio::Sign >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Sign >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // sign
    //
    if (t[3UL])
    {
      i.sign_value.capacity (i.sign_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits< ::pio::Sign >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // sign
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.sign_value.data ();
    b[n].size = &i.sign_size;
    b[n].capacity = i.sign_value.capacity ();
    b[n].is_null = &i.sign_null;
    n++;
  }

  void access::object_traits< ::pio::Sign >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Sign >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // sign
    //
    {
      ::std::string const& v =
        o.sign;

      bool is_null (false);
      std::size_t cap (i.sign_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.sign_value,
        i.sign_size,
        is_null,
        v);
      i.sign_null = is_null;
      grew = grew || (cap != i.sign_value.capacity ());
    }

    return grew;
  }

  void access::object_traits< ::pio::Sign >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // sign
    //
    {
      ::std::string& v =
        o.sign;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.sign_value,
        i.sign_size,
        i.sign_null);
    }
  }

  void access::object_traits< ::pio::Sign >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Sign >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Sign >::persist_statement[] =
  "INSERT INTO \"Sign\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"sign\")"
  " VALUES (?,?,?,?)";

  const char access::object_traits< ::pio::Sign >::find_statement[] =
  "SELECT "
  "\"Sign\".\"auto_id\","
  "\"Sign\".\"link\","
  "\"Sign\".\"dir\","
  "\"Sign\".\"sign\""
  " FROM \"Sign\""
  " WHERE \"Sign\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Sign >::update_statement[] =
  "UPDATE \"Sign\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"sign\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Sign >::erase_statement[] =
  "DELETE FROM \"Sign\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Sign >::query_statement[] =
  "SELECT "
  "\"Sign\".\"auto_id\","
  "\"Sign\".\"link\","
  "\"Sign\".\"dir\","
  "\"Sign\".\"sign\""
  " FROM \"Sign\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Sign\".\"link\""
  " ";

  const char access::object_traits< ::pio::Sign >::erase_query_statement[] =
  "DELETE FROM \"Sign\""
  " ";

  const char access::object_traits< ::pio::Sign >::table_name[] =
  "\"Sign\"";

  void access::object_traits< ::pio::Sign >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Sign >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Sign >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Sign >::pointer_type
  access::object_traits< ::pio::Sign >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Sign >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Sign >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Sign >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Sign >::object_type >
  access::object_traits< ::pio::Sign >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Sign >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Sign >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Sign\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Sign\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"sign\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Sign_ (
    "",
    &access::object_traits< ::pio::Sign >::create_schema);

  // Signal
  //

  access::object_traits< ::pio::Signal >::id_type
  access::object_traits< ::pio::Signal >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.signal_value,
        i.signal_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Signal >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // signal
    //
    t[0UL] = false;

    // group
    //
    t[1UL] = false;

    // times
    //
    t[2UL] = false;

    // start
    //
    t[3UL] = false;

    // end
    //
    t[4UL] = false;

    // timing
    //
    t[5UL] = false;

    // phasing
    //
    t[6UL] = false;

    // type
    //
    if (t[7UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // offset
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Signal >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // signal
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.signal_value;
      b[n].is_null = &i.signal_null;
      n++;
    }

    // group
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.group_value;
    b[n].is_null = &i.group_null;
    n++;

    // times
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.times_value;
    b[n].is_null = &i.times_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // timing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timing_value;
    b[n].is_null = &i.timing_null;
    n++;

    // phasing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phasing_value;
    b[n].is_null = &i.phasing_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;
  }

  void access::object_traits< ::pio::Signal >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Signal >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // signal
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.signal;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.signal_value,
        is_null,
        v);
      i.signal_null = is_null;
    }

    // group
    //
    {
      int const& v =
        o.group;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.group_value,
        is_null,
        v);
      i.group_null = is_null;
    }

    // times
    //
    {
      int const& v =
        o.times;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.times_value,
        is_null,
        v);
      i.times_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // timing
    //
    {
      int const& v =
        o.timing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.timing_value,
        is_null,
        v);
      i.timing_null = is_null;
    }

    // phasing
    //
    {
      int const& v =
        o.phasing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phasing_value,
        is_null,
        v);
      i.phasing_null = is_null;
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // offset
    //
    {
      int const& v =
        o.offset;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Signal >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // signal
    //
    {
      int& v =
        o.signal;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.signal_value,
        i.signal_null);
    }

    // group
    //
    {
      int& v =
        o.group;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.group_value,
        i.group_null);
    }

    // times
    //
    {
      int& v =
        o.times;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.times_value,
        i.times_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // timing
    //
    {
      int& v =
        o.timing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.timing_value,
        i.timing_null);
    }

    // phasing
    //
    {
      int& v =
        o.phasing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phasing_value,
        i.phasing_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // offset
    //
    {
      int& v =
        o.offset;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }
  }

  void access::object_traits< ::pio::Signal >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Signal >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Signal >::persist_statement[] =
  "INSERT INTO \"Signal\" ("
  "\"signal\","
  "\"group\","
  "\"times\","
  "\"start\","
  "\"end\","
  "\"timing\","
  "\"phasing\","
  "\"type\","
  "\"offset\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Signal >::find_statement[] =
  "SELECT "
  "\"Signal\".\"signal\","
  "\"Signal\".\"group\","
  "\"Signal\".\"times\","
  "\"Signal\".\"start\","
  "\"Signal\".\"end\","
  "\"Signal\".\"timing\","
  "\"Signal\".\"phasing\","
  "\"Signal\".\"type\","
  "\"Signal\".\"offset\""
  " FROM \"Signal\""
  " WHERE \"Signal\".\"signal\"=?";

  const char access::object_traits< ::pio::Signal >::update_statement[] =
  "UPDATE \"Signal\" SET "
  "\"group\"=?,"
  "\"times\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"timing\"=?,"
  "\"phasing\"=?,"
  "\"type\"=?,"
  "\"offset\"=?"
  " WHERE \"signal\"=?";

  const char access::object_traits< ::pio::Signal >::erase_statement[] =
  "DELETE FROM \"Signal\""
  " WHERE \"signal\"=?";

  const char access::object_traits< ::pio::Signal >::query_statement[] =
  "SELECT "
  "\"Signal\".\"signal\","
  "\"Signal\".\"group\","
  "\"Signal\".\"times\","
  "\"Signal\".\"start\","
  "\"Signal\".\"end\","
  "\"Signal\".\"timing\","
  "\"Signal\".\"phasing\","
  "\"Signal\".\"type\","
  "\"Signal\".\"offset\""
  " FROM \"Signal\""
  " ";

  const char access::object_traits< ::pio::Signal >::erase_query_statement[] =
  "DELETE FROM \"Signal\""
  " ";

  const char access::object_traits< ::pio::Signal >::table_name[] =
  "\"Signal\"";

  void access::object_traits< ::pio::Signal >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Signal >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.signal);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Signal >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Signal >::pointer_type
  access::object_traits< ::pio::Signal >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Signal >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Signal >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.signal);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Signal >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Signal >::object_type >
  access::object_traits< ::pio::Signal >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Signal >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Signal >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Signal\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Signal\" (\n"
                      "  \"signal\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"group\" INTEGER NOT NULL,\n"
                      "  \"times\" INTEGER NOT NULL,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"timing\" INTEGER NOT NULL,\n"
                      "  \"phasing\" INTEGER NOT NULL,\n"
                      "  \"type\" TEXT NOT NULL,\n"
                      "  \"offset\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Signal_ (
    "",
    &access::object_traits< ::pio::Signal >::create_schema);

  // Timing
  //

  access::object_traits< ::pio::Timing >::id_type
  access::object_traits< ::pio::Timing >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Timing >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // signal
    //
    t[1UL] = false;

    // timing
    //
    t[2UL] = false;

    // type
    //
    t[3UL] = false;

    // cycle
    //
    t[4UL] = false;

    // offset
    //
    t[5UL] = false;

    // phases
    //
    t[6UL] = false;

    // phase
    //
    t[7UL] = false;

    // barrier
    //
    t[8UL] = false;

    // ring
    //
    t[9UL] = false;

    // position
    //
    t[10UL] = false;

    // minimum
    //
    t[11UL] = false;

    // maximum
    //
    t[12UL] = false;

    // extend
    //
    t[13UL] = false;

    // yellow
    //
    t[14UL] = false;

    // red
    //
    t[15UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Timing >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // signal
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signal_value;
    b[n].is_null = &i.signal_null;
    n++;

    // timing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timing_value;
    b[n].is_null = &i.timing_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // cycle
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cycle_value;
    b[n].is_null = &i.cycle_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // phases
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phases_value;
    b[n].is_null = &i.phases_null;
    n++;

    // phase
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phase_value;
    b[n].is_null = &i.phase_null;
    n++;

    // barrier
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.barrier_value;
    b[n].is_null = &i.barrier_null;
    n++;

    // ring
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.ring_value;
    b[n].is_null = &i.ring_null;
    n++;

    // position
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.position_value;
    b[n].is_null = &i.position_null;
    n++;

    // minimum
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.minimum_value;
    b[n].is_null = &i.minimum_null;
    n++;

    // maximum
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.maximum_value;
    b[n].is_null = &i.maximum_null;
    n++;

    // extend
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.extend_value;
    b[n].is_null = &i.extend_null;
    n++;

    // yellow
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.yellow_value;
    b[n].is_null = &i.yellow_null;
    n++;

    // red
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.red_value;
    b[n].is_null = &i.red_null;
    n++;
  }

  void access::object_traits< ::pio::Timing >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Timing >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::pio::Signal > const& v =
        o.signal;

      typedef object_traits< ::pio::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Signal > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.signal_value,
          is_null,
          id);
        i.signal_null = is_null;
      }
      else
        i.signal_null = true;
    }

    // timing
    //
    {
      int const& v =
        o.timing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.timing_value,
        is_null,
        v);
      i.timing_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // cycle
    //
    {
      int const& v =
        o.cycle;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cycle_value,
        is_null,
        v);
      i.cycle_null = is_null;
    }

    // offset
    //
    {
      int const& v =
        o.offset;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // phases
    //
    {
      int const& v =
        o.phases;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phases_value,
        is_null,
        v);
      i.phases_null = is_null;
    }

    // phase
    //
    {
      int const& v =
        o.phase;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phase_value,
        is_null,
        v);
      i.phase_null = is_null;
    }

    // barrier
    //
    {
      int const& v =
        o.barrier;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.barrier_value,
        is_null,
        v);
      i.barrier_null = is_null;
    }

    // ring
    //
    {
      int const& v =
        o.ring;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.ring_value,
        is_null,
        v);
      i.ring_null = is_null;
    }

    // position
    //
    {
      int const& v =
        o.position;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.position_value,
        is_null,
        v);
      i.position_null = is_null;
    }

    // minimum
    //
    {
      int const& v =
        o.minimum;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.minimum_value,
        is_null,
        v);
      i.minimum_null = is_null;
    }

    // maximum
    //
    {
      int const& v =
        o.maximum;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.maximum_value,
        is_null,
        v);
      i.maximum_null = is_null;
    }

    // extend
    //
    {
      int const& v =
        o.extend;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.extend_value,
        is_null,
        v);
      i.extend_null = is_null;
    }

    // yellow
    //
    {
      int const& v =
        o.yellow;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.yellow_value,
        is_null,
        v);
      i.yellow_null = is_null;
    }

    // red
    //
    {
      int const& v =
        o.red;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.red_value,
        is_null,
        v);
      i.red_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Timing >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::pio::Signal >& v =
        o.signal;

      typedef object_traits< ::pio::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Signal > > ptr_traits;

      if (i.signal_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.signal_value,
          i.signal_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // timing
    //
    {
      int& v =
        o.timing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.timing_value,
        i.timing_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // cycle
    //
    {
      int& v =
        o.cycle;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cycle_value,
        i.cycle_null);
    }

    // offset
    //
    {
      int& v =
        o.offset;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // phases
    //
    {
      int& v =
        o.phases;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phases_value,
        i.phases_null);
    }

    // phase
    //
    {
      int& v =
        o.phase;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phase_value,
        i.phase_null);
    }

    // barrier
    //
    {
      int& v =
        o.barrier;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.barrier_value,
        i.barrier_null);
    }

    // ring
    //
    {
      int& v =
        o.ring;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.ring_value,
        i.ring_null);
    }

    // position
    //
    {
      int& v =
        o.position;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.position_value,
        i.position_null);
    }

    // minimum
    //
    {
      int& v =
        o.minimum;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.minimum_value,
        i.minimum_null);
    }

    // maximum
    //
    {
      int& v =
        o.maximum;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.maximum_value,
        i.maximum_null);
    }

    // extend
    //
    {
      int& v =
        o.extend;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.extend_value,
        i.extend_null);
    }

    // yellow
    //
    {
      int& v =
        o.yellow;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.yellow_value,
        i.yellow_null);
    }

    // red
    //
    {
      int& v =
        o.red;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.red_value,
        i.red_null);
    }
  }

  void access::object_traits< ::pio::Timing >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Timing >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Timing >::persist_statement[] =
  "INSERT INTO \"Timing\" ("
  "\"auto_id\","
  "\"signal\","
  "\"timing\","
  "\"type\","
  "\"cycle\","
  "\"offset\","
  "\"phases\","
  "\"phase\","
  "\"barrier\","
  "\"ring\","
  "\"position\","
  "\"minimum\","
  "\"maximum\","
  "\"extend\","
  "\"yellow\","
  "\"red\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Timing >::find_statement[] =
  "SELECT "
  "\"Timing\".\"auto_id\","
  "\"Timing\".\"signal\","
  "\"Timing\".\"timing\","
  "\"Timing\".\"type\","
  "\"Timing\".\"cycle\","
  "\"Timing\".\"offset\","
  "\"Timing\".\"phases\","
  "\"Timing\".\"phase\","
  "\"Timing\".\"barrier\","
  "\"Timing\".\"ring\","
  "\"Timing\".\"position\","
  "\"Timing\".\"minimum\","
  "\"Timing\".\"maximum\","
  "\"Timing\".\"extend\","
  "\"Timing\".\"yellow\","
  "\"Timing\".\"red\""
  " FROM \"Timing\""
  " WHERE \"Timing\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Timing >::update_statement[] =
  "UPDATE \"Timing\" SET "
  "\"signal\"=?,"
  "\"timing\"=?,"
  "\"type\"=?,"
  "\"cycle\"=?,"
  "\"offset\"=?,"
  "\"phases\"=?,"
  "\"phase\"=?,"
  "\"barrier\"=?,"
  "\"ring\"=?,"
  "\"position\"=?,"
  "\"minimum\"=?,"
  "\"maximum\"=?,"
  "\"extend\"=?,"
  "\"yellow\"=?,"
  "\"red\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Timing >::erase_statement[] =
  "DELETE FROM \"Timing\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Timing >::query_statement[] =
  "SELECT "
  "\"Timing\".\"auto_id\","
  "\"Timing\".\"signal\","
  "\"Timing\".\"timing\","
  "\"Timing\".\"type\","
  "\"Timing\".\"cycle\","
  "\"Timing\".\"offset\","
  "\"Timing\".\"phases\","
  "\"Timing\".\"phase\","
  "\"Timing\".\"barrier\","
  "\"Timing\".\"ring\","
  "\"Timing\".\"position\","
  "\"Timing\".\"minimum\","
  "\"Timing\".\"maximum\","
  "\"Timing\".\"extend\","
  "\"Timing\".\"yellow\","
  "\"Timing\".\"red\""
  " FROM \"Timing\""
  " LEFT JOIN \"Signal\" AS \"signal\" ON \"signal\".\"signal\"=\"Timing\".\"signal\""
  " ";

  const char access::object_traits< ::pio::Timing >::erase_query_statement[] =
  "DELETE FROM \"Timing\""
  " ";

  const char access::object_traits< ::pio::Timing >::table_name[] =
  "\"Timing\"";

  void access::object_traits< ::pio::Timing >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Timing >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Timing >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Timing >::pointer_type
  access::object_traits< ::pio::Timing >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Timing >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Timing >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Timing >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Timing >::object_type >
  access::object_traits< ::pio::Timing >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Timing >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Timing >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Timing\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Timing\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"signal\" INTEGER,\n"
                      "  \"timing\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"cycle\" INTEGER NOT NULL,\n"
                      "  \"offset\" INTEGER NOT NULL,\n"
                      "  \"phases\" INTEGER NOT NULL,\n"
                      "  \"phase\" INTEGER NOT NULL,\n"
                      "  \"barrier\" INTEGER NOT NULL,\n"
                      "  \"ring\" INTEGER NOT NULL,\n"
                      "  \"position\" INTEGER NOT NULL,\n"
                      "  \"minimum\" INTEGER NOT NULL,\n"
                      "  \"maximum\" INTEGER NOT NULL,\n"
                      "  \"extend\" INTEGER NOT NULL,\n"
                      "  \"yellow\" INTEGER NOT NULL,\n"
                      "  \"red\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"signal_fk\"\n"
                      "    FOREIGN KEY (\"signal\")\n"
                      "    REFERENCES \"Signal\" (\"signal\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Timing_ (
    "",
    &access::object_traits< ::pio::Timing >::create_schema);

  // Phasing
  //

  access::object_traits< ::pio::Phasing >::id_type
  access::object_traits< ::pio::Phasing >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Phasing >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // signal
    //
    t[1UL] = false;

    // phasing
    //
    t[2UL] = false;

    // phase
    //
    t[3UL] = false;

    // detectors
    //
    if (t[4UL])
    {
      i.detectors_value.capacity (i.detectors_size);
      grew = true;
    }

    // movements
    //
    t[5UL] = false;

    // movement
    //
    if (t[6UL])
    {
      i.movement_value.capacity (i.movement_size);
      grew = true;
    }

    // link
    //
    t[7UL] = false;

    // dir
    //
    t[8UL] = false;

    // to_link
    //
    t[9UL] = false;

    // protect
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Phasing >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // signal
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signal_value;
    b[n].is_null = &i.signal_null;
    n++;

    // phasing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phasing_value;
    b[n].is_null = &i.phasing_null;
    n++;

    // phase
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phase_value;
    b[n].is_null = &i.phase_null;
    n++;

    // detectors
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.detectors_value.data ();
    b[n].size = &i.detectors_size;
    b[n].capacity = i.detectors_value.capacity ();
    b[n].is_null = &i.detectors_null;
    n++;

    // movements
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.movements_value;
    b[n].is_null = &i.movements_null;
    n++;

    // movement
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.movement_value.data ();
    b[n].size = &i.movement_size;
    b[n].capacity = i.movement_value.capacity ();
    b[n].is_null = &i.movement_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // protect
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.protect_value;
    b[n].is_null = &i.protect_null;
    n++;
  }

  void access::object_traits< ::pio::Phasing >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Phasing >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::pio::Signal > const& v =
        o.signal;

      typedef object_traits< ::pio::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Signal > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.signal_value,
          is_null,
          id);
        i.signal_null = is_null;
      }
      else
        i.signal_null = true;
    }

    // phasing
    //
    {
      int const& v =
        o.phasing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phasing_value,
        is_null,
        v);
      i.phasing_null = is_null;
    }

    // phase
    //
    {
      int const& v =
        o.phase;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phase_value,
        is_null,
        v);
      i.phase_null = is_null;
    }

    // detectors
    //
    {
      ::std::string const& v =
        o.detectors;

      bool is_null (false);
      std::size_t cap (i.detectors_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.detectors_value,
        i.detectors_size,
        is_null,
        v);
      i.detectors_null = is_null;
      grew = grew || (cap != i.detectors_value.capacity ());
    }

    // movements
    //
    {
      int const& v =
        o.movements;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.movements_value,
        is_null,
        v);
      i.movements_null = is_null;
    }

    // movement
    //
    {
      ::std::string const& v =
        o.movement;

      bool is_null (false);
      std::size_t cap (i.movement_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.movement_value,
        i.movement_size,
        is_null,
        v);
      i.movement_null = is_null;
      grew = grew || (cap != i.movement_value.capacity ());
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // protect
    //
    {
      int const& v =
        o.protect;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.protect_value,
        is_null,
        v);
      i.protect_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Phasing >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::pio::Signal >& v =
        o.signal;

      typedef object_traits< ::pio::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Signal > > ptr_traits;

      if (i.signal_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.signal_value,
          i.signal_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // phasing
    //
    {
      int& v =
        o.phasing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phasing_value,
        i.phasing_null);
    }

    // phase
    //
    {
      int& v =
        o.phase;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phase_value,
        i.phase_null);
    }

    // detectors
    //
    {
      ::std::string& v =
        o.detectors;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.detectors_value,
        i.detectors_size,
        i.detectors_null);
    }

    // movements
    //
    {
      int& v =
        o.movements;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.movements_value,
        i.movements_null);
    }

    // movement
    //
    {
      ::std::string& v =
        o.movement;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.movement_value,
        i.movement_size,
        i.movement_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.to_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // protect
    //
    {
      int& v =
        o.protect;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.protect_value,
        i.protect_null);
    }
  }

  void access::object_traits< ::pio::Phasing >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Phasing >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Phasing >::persist_statement[] =
  "INSERT INTO \"Phasing\" ("
  "\"auto_id\","
  "\"signal\","
  "\"phasing\","
  "\"phase\","
  "\"detectors\","
  "\"movements\","
  "\"movement\","
  "\"link\","
  "\"dir\","
  "\"to_link\","
  "\"protect\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Phasing >::find_statement[] =
  "SELECT "
  "\"Phasing\".\"auto_id\","
  "\"Phasing\".\"signal\","
  "\"Phasing\".\"phasing\","
  "\"Phasing\".\"phase\","
  "\"Phasing\".\"detectors\","
  "\"Phasing\".\"movements\","
  "\"Phasing\".\"movement\","
  "\"Phasing\".\"link\","
  "\"Phasing\".\"dir\","
  "\"Phasing\".\"to_link\","
  "\"Phasing\".\"protect\""
  " FROM \"Phasing\""
  " WHERE \"Phasing\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Phasing >::update_statement[] =
  "UPDATE \"Phasing\" SET "
  "\"signal\"=?,"
  "\"phasing\"=?,"
  "\"phase\"=?,"
  "\"detectors\"=?,"
  "\"movements\"=?,"
  "\"movement\"=?,"
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"to_link\"=?,"
  "\"protect\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Phasing >::erase_statement[] =
  "DELETE FROM \"Phasing\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Phasing >::query_statement[] =
  "SELECT "
  "\"Phasing\".\"auto_id\","
  "\"Phasing\".\"signal\","
  "\"Phasing\".\"phasing\","
  "\"Phasing\".\"phase\","
  "\"Phasing\".\"detectors\","
  "\"Phasing\".\"movements\","
  "\"Phasing\".\"movement\","
  "\"Phasing\".\"link\","
  "\"Phasing\".\"dir\","
  "\"Phasing\".\"to_link\","
  "\"Phasing\".\"protect\""
  " FROM \"Phasing\""
  " LEFT JOIN \"Signal\" AS \"signal\" ON \"signal\".\"signal\"=\"Phasing\".\"signal\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Phasing\".\"link\""
  " LEFT JOIN \"Link\" AS \"to_link\" ON \"to_link\".\"link\"=\"Phasing\".\"to_link\""
  " ";

  const char access::object_traits< ::pio::Phasing >::erase_query_statement[] =
  "DELETE FROM \"Phasing\""
  " ";

  const char access::object_traits< ::pio::Phasing >::table_name[] =
  "\"Phasing\"";

  void access::object_traits< ::pio::Phasing >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Phasing >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Phasing >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Phasing >::pointer_type
  access::object_traits< ::pio::Phasing >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Phasing >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Phasing >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Phasing >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Phasing >::object_type >
  access::object_traits< ::pio::Phasing >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Phasing >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Phasing >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Phasing\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Phasing\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"signal\" INTEGER,\n"
                      "  \"phasing\" INTEGER NOT NULL,\n"
                      "  \"phase\" INTEGER NOT NULL,\n"
                      "  \"detectors\" TEXT NOT NULL,\n"
                      "  \"movements\" INTEGER NOT NULL,\n"
                      "  \"movement\" TEXT NOT NULL,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"to_link\" INTEGER,\n"
                      "  \"protect\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"signal_fk\"\n"
                      "    FOREIGN KEY (\"signal\")\n"
                      "    REFERENCES \"Signal\" (\"signal\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"to_link_fk\"\n"
                      "    FOREIGN KEY (\"to_link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Phasing_ (
    "",
    &access::object_traits< ::pio::Phasing >::create_schema);

  // Detector
  //

  access::object_traits< ::pio::Detector >::id_type
  access::object_traits< ::pio::Detector >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.detector_value,
        i.detector_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Detector >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // detector
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // length
    //
    t[4UL] = false;

    // lanes
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // use
    //
    t[7UL] = false;

    // low
    //
    t[8UL] = false;

    // high
    //
    t[9UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Detector >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // detector
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.detector_value;
      b[n].is_null = &i.detector_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // low
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.low_value;
    b[n].is_null = &i.low_null;
    n++;

    // high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.high_value;
    b[n].is_null = &i.high_null;
    n++;
  }

  void access::object_traits< ::pio::Detector >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Detector >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // detector
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.detector;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.detector_value,
        is_null,
        v);
      i.detector_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // low
    //
    {
      int const& v =
        o.low;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.low_value,
        is_null,
        v);
      i.low_null = is_null;
    }

    // high
    //
    {
      int const& v =
        o.high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.high_value,
        is_null,
        v);
      i.high_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Detector >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // detector
    //
    {
      int& v =
        o.detector;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.detector_value,
        i.detector_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // low
    //
    {
      int& v =
        o.low;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.low_value,
        i.low_null);
    }

    // high
    //
    {
      int& v =
        o.high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.high_value,
        i.high_null);
    }
  }

  void access::object_traits< ::pio::Detector >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Detector >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Detector >::persist_statement[] =
  "INSERT INTO \"Detector\" ("
  "\"detector\","
  "\"link\","
  "\"dir\","
  "\"offset\","
  "\"length\","
  "\"lanes\","
  "\"type\","
  "\"use\","
  "\"low\","
  "\"high\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Detector >::find_statement[] =
  "SELECT "
  "\"Detector\".\"detector\","
  "\"Detector\".\"link\","
  "\"Detector\".\"dir\","
  "\"Detector\".\"offset\","
  "\"Detector\".\"length\","
  "\"Detector\".\"lanes\","
  "\"Detector\".\"type\","
  "\"Detector\".\"use\","
  "\"Detector\".\"low\","
  "\"Detector\".\"high\""
  " FROM \"Detector\""
  " WHERE \"Detector\".\"detector\"=?";

  const char access::object_traits< ::pio::Detector >::update_statement[] =
  "UPDATE \"Detector\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"offset\"=?,"
  "\"length\"=?,"
  "\"lanes\"=?,"
  "\"type\"=?,"
  "\"use\"=?,"
  "\"low\"=?,"
  "\"high\"=?"
  " WHERE \"detector\"=?";

  const char access::object_traits< ::pio::Detector >::erase_statement[] =
  "DELETE FROM \"Detector\""
  " WHERE \"detector\"=?";

  const char access::object_traits< ::pio::Detector >::query_statement[] =
  "SELECT "
  "\"Detector\".\"detector\","
  "\"Detector\".\"link\","
  "\"Detector\".\"dir\","
  "\"Detector\".\"offset\","
  "\"Detector\".\"length\","
  "\"Detector\".\"lanes\","
  "\"Detector\".\"type\","
  "\"Detector\".\"use\","
  "\"Detector\".\"low\","
  "\"Detector\".\"high\""
  " FROM \"Detector\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Detector\".\"link\""
  " ";

  const char access::object_traits< ::pio::Detector >::erase_query_statement[] =
  "DELETE FROM \"Detector\""
  " ";

  const char access::object_traits< ::pio::Detector >::table_name[] =
  "\"Detector\"";

  void access::object_traits< ::pio::Detector >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Detector >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.detector);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Detector >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Detector >::pointer_type
  access::object_traits< ::pio::Detector >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Detector >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Detector >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.detector);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Detector >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Detector >::object_type >
  access::object_traits< ::pio::Detector >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Detector >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Detector >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Detector\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Detector\" (\n"
                      "  \"detector\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"length\" REAL,\n"
                      "  \"lanes\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"low\" INTEGER NOT NULL,\n"
                      "  \"high\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Detector_ (
    "",
    &access::object_traits< ::pio::Detector >::create_schema);

  // Stop
  //

  access::object_traits< ::pio::Stop >::id_type
  access::object_traits< ::pio::Stop >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.stop_value,
        i.stop_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Stop >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // stop
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // link
    //
    t[2UL] = false;

    // dir
    //
    t[3UL] = false;

    // offset
    //
    t[4UL] = false;

    // use
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // space
    //
    t[7UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Stop >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // stop
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.stop_value;
      b[n].is_null = &i.stop_null;
      n++;
    }

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // space
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.space_value;
    b[n].is_null = &i.space_null;
    n++;
  }

  void access::object_traits< ::pio::Stop >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Stop >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // stop
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.stop;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.stop_value,
        is_null,
        v);
      i.stop_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // space
    //
    {
      int const& v =
        o.space;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.space_value,
        is_null,
        v);
      i.space_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Stop >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // stop
    //
    {
      int& v =
        o.stop;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.stop_value,
        i.stop_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // space
    //
    {
      int& v =
        o.space;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.space_value,
        i.space_null);
    }
  }

  void access::object_traits< ::pio::Stop >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Stop >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Stop >::persist_statement[] =
  "INSERT INTO \"Stop\" ("
  "\"stop\","
  "\"name\","
  "\"link\","
  "\"dir\","
  "\"offset\","
  "\"use\","
  "\"type\","
  "\"space\")"
  " VALUES (?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Stop >::find_statement[] =
  "SELECT "
  "\"Stop\".\"stop\","
  "\"Stop\".\"name\","
  "\"Stop\".\"link\","
  "\"Stop\".\"dir\","
  "\"Stop\".\"offset\","
  "\"Stop\".\"use\","
  "\"Stop\".\"type\","
  "\"Stop\".\"space\""
  " FROM \"Stop\""
  " WHERE \"Stop\".\"stop\"=?";

  const char access::object_traits< ::pio::Stop >::update_statement[] =
  "UPDATE \"Stop\" SET "
  "\"name\"=?,"
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"offset\"=?,"
  "\"use\"=?,"
  "\"type\"=?,"
  "\"space\"=?"
  " WHERE \"stop\"=?";

  const char access::object_traits< ::pio::Stop >::erase_statement[] =
  "DELETE FROM \"Stop\""
  " WHERE \"stop\"=?";

  const char access::object_traits< ::pio::Stop >::query_statement[] =
  "SELECT "
  "\"Stop\".\"stop\","
  "\"Stop\".\"name\","
  "\"Stop\".\"link\","
  "\"Stop\".\"dir\","
  "\"Stop\".\"offset\","
  "\"Stop\".\"use\","
  "\"Stop\".\"type\","
  "\"Stop\".\"space\""
  " FROM \"Stop\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Stop\".\"link\""
  " ";

  const char access::object_traits< ::pio::Stop >::erase_query_statement[] =
  "DELETE FROM \"Stop\""
  " ";

  const char access::object_traits< ::pio::Stop >::table_name[] =
  "\"Stop\"";

  void access::object_traits< ::pio::Stop >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Stop >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.stop);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Stop >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Stop >::pointer_type
  access::object_traits< ::pio::Stop >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Stop >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Stop >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.stop);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Stop >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Stop >::object_type >
  access::object_traits< ::pio::Stop >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Stop >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Stop >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Stop\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Stop\" (\n"
                      "  \"stop\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"space\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Stop_ (
    "",
    &access::object_traits< ::pio::Stop >::create_schema);

  // Fare
  //

  access::object_traits< ::pio::Fare >::id_type
  access::object_traits< ::pio::Fare >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.fare_value,
        i.fare_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Fare >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // from_zone
    //
    t[0UL] = false;

    // to_zone
    //
    t[1UL] = false;

    // from_mode
    //
    t[2UL] = false;

    // to_mode
    //
    t[3UL] = false;

    // period
    //
    t[4UL] = false;

    // type
    //
    t[5UL] = false;

    // fare
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Fare >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // from_zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_zone_value;
    b[n].is_null = &i.from_zone_null;
    n++;

    // to_zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_zone_value;
    b[n].is_null = &i.to_zone_null;
    n++;

    // from_mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_mode_value;
    b[n].is_null = &i.from_mode_null;
    n++;

    // to_mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_mode_value;
    b[n].is_null = &i.to_mode_null;
    n++;

    // period
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.period_value;
    b[n].is_null = &i.period_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // fare
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.fare_value;
      b[n].is_null = &i.fare_null;
      n++;
    }
  }

  void access::object_traits< ::pio::Fare >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Fare >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // from_zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone > const& v =
        o.from_zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.from_zone_value,
          is_null,
          id);
        i.from_zone_null = is_null;
      }
      else
        i.from_zone_null = true;
    }

    // to_zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone > const& v =
        o.to_zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_zone_value,
          is_null,
          id);
        i.to_zone_null = is_null;
      }
      else
        i.to_zone_null = true;
    }

    // from_mode
    //
    {
      int const& v =
        o.from_mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_mode_value,
        is_null,
        v);
      i.from_mode_null = is_null;
    }

    // to_mode
    //
    {
      int const& v =
        o.to_mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_mode_value,
        is_null,
        v);
      i.to_mode_null = is_null;
    }

    // period
    //
    {
      int const& v =
        o.period;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.period_value,
        is_null,
        v);
      i.period_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // fare
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.fare;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.fare_value,
        is_null,
        v);
      i.fare_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Fare >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // from_zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone >& v =
        o.from_zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      if (i.from_zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.from_zone_value,
          i.from_zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // to_zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone >& v =
        o.to_zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      if (i.to_zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_zone_value,
          i.to_zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // from_mode
    //
    {
      int& v =
        o.from_mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_mode_value,
        i.from_mode_null);
    }

    // to_mode
    //
    {
      int& v =
        o.to_mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_mode_value,
        i.to_mode_null);
    }

    // period
    //
    {
      int& v =
        o.period;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.period_value,
        i.period_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // fare
    //
    {
      int& v =
        o.fare;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.fare_value,
        i.fare_null);
    }
  }

  void access::object_traits< ::pio::Fare >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Fare >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Fare >::persist_statement[] =
  "INSERT INTO \"Fare\" ("
  "\"from_zone\","
  "\"to_zone\","
  "\"from_mode\","
  "\"to_mode\","
  "\"period\","
  "\"type\","
  "\"fare\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Fare >::find_statement[] =
  "SELECT "
  "\"Fare\".\"from_zone\","
  "\"Fare\".\"to_zone\","
  "\"Fare\".\"from_mode\","
  "\"Fare\".\"to_mode\","
  "\"Fare\".\"period\","
  "\"Fare\".\"type\","
  "\"Fare\".\"fare\""
  " FROM \"Fare\""
  " WHERE \"Fare\".\"fare\"=?";

  const char access::object_traits< ::pio::Fare >::update_statement[] =
  "UPDATE \"Fare\" SET "
  "\"from_zone\"=?,"
  "\"to_zone\"=?,"
  "\"from_mode\"=?,"
  "\"to_mode\"=?,"
  "\"period\"=?,"
  "\"type\"=?"
  " WHERE \"fare\"=?";

  const char access::object_traits< ::pio::Fare >::erase_statement[] =
  "DELETE FROM \"Fare\""
  " WHERE \"fare\"=?";

  const char access::object_traits< ::pio::Fare >::query_statement[] =
  "SELECT "
  "\"Fare\".\"from_zone\","
  "\"Fare\".\"to_zone\","
  "\"Fare\".\"from_mode\","
  "\"Fare\".\"to_mode\","
  "\"Fare\".\"period\","
  "\"Fare\".\"type\","
  "\"Fare\".\"fare\""
  " FROM \"Fare\""
  " LEFT JOIN \"Zone\" AS \"from_zone\" ON \"from_zone\".\"zone\"=\"Fare\".\"from_zone\""
  " LEFT JOIN \"Zone\" AS \"to_zone\" ON \"to_zone\".\"zone\"=\"Fare\".\"to_zone\""
  " ";

  const char access::object_traits< ::pio::Fare >::erase_query_statement[] =
  "DELETE FROM \"Fare\""
  " ";

  const char access::object_traits< ::pio::Fare >::table_name[] =
  "\"Fare\"";

  void access::object_traits< ::pio::Fare >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Fare >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.fare);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Fare >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Fare >::pointer_type
  access::object_traits< ::pio::Fare >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Fare >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Fare >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.fare);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Fare >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Fare >::object_type >
  access::object_traits< ::pio::Fare >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Fare >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Fare >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Fare\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Fare\" (\n"
                      "  \"from_zone\" INTEGER,\n"
                      "  \"to_zone\" INTEGER,\n"
                      "  \"from_mode\" INTEGER NOT NULL,\n"
                      "  \"to_mode\" INTEGER NOT NULL,\n"
                      "  \"period\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"fare\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  CONSTRAINT \"from_zone_fk\"\n"
                      "    FOREIGN KEY (\"from_zone\")\n"
                      "    REFERENCES \"Zone\" (\"zone\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"to_zone_fk\"\n"
                      "    FOREIGN KEY (\"to_zone\")\n"
                      "    REFERENCES \"Zone\" (\"zone\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Fare_ (
    "",
    &access::object_traits< ::pio::Fare >::create_schema);

  // Line
  //

  access::object_traits< ::pio::Line >::id_type
  access::object_traits< ::pio::Line >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Line >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // stops
    //
    t[2UL] = false;

    // mode
    //
    t[3UL] = false;

    // type
    //
    t[4UL] = false;

    // name
    //
    if (t[5UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // stop
    //
    t[6UL] = false;

    // zone
    //
    t[7UL] = false;

    // flag
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Line >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // stops
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stops_value;
    b[n].is_null = &i.stops_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;

    // zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.zone_value;
    b[n].is_null = &i.zone_null;
    n++;

    // flag
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.flag_value;
    b[n].is_null = &i.flag_null;
    n++;
  }

  void access::object_traits< ::pio::Line >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Line >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stops;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stops_value,
          is_null,
          id);
        i.stops_null = is_null;
      }
      else
        i.stops_null = true;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone > const& v =
        o.zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.zone_value,
          is_null,
          id);
        i.zone_null = is_null;
      }
      else
        i.zone_null = true;
    }

    // flag
    //
    {
      int const& v =
        o.flag;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.flag_value,
        is_null,
        v);
      i.flag_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Line >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stops;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stops_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stops_value,
          i.stops_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::pio::Zone >& v =
        o.zone;

      typedef object_traits< ::pio::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Zone > > ptr_traits;

      if (i.zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.zone_value,
          i.zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // flag
    //
    {
      int& v =
        o.flag;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.flag_value,
        i.flag_null);
    }
  }

  void access::object_traits< ::pio::Line >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Line >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Line >::persist_statement[] =
  "INSERT INTO \"Line\" ("
  "\"auto_id\","
  "\"route\","
  "\"stops\","
  "\"mode\","
  "\"type\","
  "\"name\","
  "\"stop\","
  "\"zone\","
  "\"flag\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Line >::find_statement[] =
  "SELECT "
  "\"Line\".\"auto_id\","
  "\"Line\".\"route\","
  "\"Line\".\"stops\","
  "\"Line\".\"mode\","
  "\"Line\".\"type\","
  "\"Line\".\"name\","
  "\"Line\".\"stop\","
  "\"Line\".\"zone\","
  "\"Line\".\"flag\""
  " FROM \"Line\""
  " WHERE \"Line\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Line >::update_statement[] =
  "UPDATE \"Line\" SET "
  "\"route\"=?,"
  "\"stops\"=?,"
  "\"mode\"=?,"
  "\"type\"=?,"
  "\"name\"=?,"
  "\"stop\"=?,"
  "\"zone\"=?,"
  "\"flag\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Line >::erase_statement[] =
  "DELETE FROM \"Line\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Line >::query_statement[] =
  "SELECT "
  "\"Line\".\"auto_id\","
  "\"Line\".\"route\","
  "\"Line\".\"stops\","
  "\"Line\".\"mode\","
  "\"Line\".\"type\","
  "\"Line\".\"name\","
  "\"Line\".\"stop\","
  "\"Line\".\"zone\","
  "\"Line\".\"flag\""
  " FROM \"Line\""
  " LEFT JOIN \"Stop\" AS \"stops\" ON \"stops\".\"stop\"=\"Line\".\"stops\""
  " LEFT JOIN \"Stop\" AS \"stop\" ON \"stop\".\"stop\"=\"Line\".\"stop\""
  " LEFT JOIN \"Zone\" AS \"zone\" ON \"zone\".\"zone\"=\"Line\".\"zone\""
  " ";

  const char access::object_traits< ::pio::Line >::erase_query_statement[] =
  "DELETE FROM \"Line\""
  " ";

  const char access::object_traits< ::pio::Line >::table_name[] =
  "\"Line\"";

  void access::object_traits< ::pio::Line >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Line >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Line >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Line >::pointer_type
  access::object_traits< ::pio::Line >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Line >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Line >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Line >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Line >::object_type >
  access::object_traits< ::pio::Line >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Line >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Line >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Line\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Line\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"stops\" INTEGER,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"stop\" INTEGER,\n"
                      "  \"zone\" INTEGER,\n"
                      "  \"flag\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"stops_fk\"\n"
                      "    FOREIGN KEY (\"stops\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"stop_fk\"\n"
                      "    FOREIGN KEY (\"stop\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"zone_fk\"\n"
                      "    FOREIGN KEY (\"zone\")\n"
                      "    REFERENCES \"Zone\" (\"zone\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Line_ (
    "",
    &access::object_traits< ::pio::Line >::create_schema);

  // Schedule
  //

  access::object_traits< ::pio::Schedule >::id_type
  access::object_traits< ::pio::Schedule >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Schedule >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // stops
    //
    t[2UL] = false;

    // stop
    //
    t[3UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Schedule >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // stops
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stops_value;
    b[n].is_null = &i.stops_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;
  }

  void access::object_traits< ::pio::Schedule >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Schedule >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stops;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stops_value,
          is_null,
          id);
        i.stops_null = is_null;
      }
      else
        i.stops_null = true;
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    return grew;
  }

  void access::object_traits< ::pio::Schedule >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stops;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stops_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stops_value,
          i.stops_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits< ::pio::Schedule >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Schedule >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Schedule >::persist_statement[] =
  "INSERT INTO \"Schedule\" ("
  "\"auto_id\","
  "\"route\","
  "\"stops\","
  "\"stop\")"
  " VALUES (?,?,?,?)";

  const char access::object_traits< ::pio::Schedule >::find_statement[] =
  "SELECT "
  "\"Schedule\".\"auto_id\","
  "\"Schedule\".\"route\","
  "\"Schedule\".\"stops\","
  "\"Schedule\".\"stop\""
  " FROM \"Schedule\""
  " WHERE \"Schedule\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Schedule >::update_statement[] =
  "UPDATE \"Schedule\" SET "
  "\"route\"=?,"
  "\"stops\"=?,"
  "\"stop\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Schedule >::erase_statement[] =
  "DELETE FROM \"Schedule\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Schedule >::query_statement[] =
  "SELECT "
  "\"Schedule\".\"auto_id\","
  "\"Schedule\".\"route\","
  "\"Schedule\".\"stops\","
  "\"Schedule\".\"stop\""
  " FROM \"Schedule\""
  " LEFT JOIN \"Stop\" AS \"stops\" ON \"stops\".\"stop\"=\"Schedule\".\"stops\""
  " LEFT JOIN \"Stop\" AS \"stop\" ON \"stop\".\"stop\"=\"Schedule\".\"stop\""
  " ";

  const char access::object_traits< ::pio::Schedule >::erase_query_statement[] =
  "DELETE FROM \"Schedule\""
  " ";

  const char access::object_traits< ::pio::Schedule >::table_name[] =
  "\"Schedule\"";

  void access::object_traits< ::pio::Schedule >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Schedule >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Schedule >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Schedule >::pointer_type
  access::object_traits< ::pio::Schedule >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Schedule >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Schedule >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Schedule >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Schedule >::object_type >
  access::object_traits< ::pio::Schedule >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Schedule >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Schedule >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Schedule\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Schedule\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"stops\" INTEGER,\n"
                      "  \"stop\" INTEGER,\n"
                      "  CONSTRAINT \"stops_fk\"\n"
                      "    FOREIGN KEY (\"stops\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"stop_fk\"\n"
                      "    FOREIGN KEY (\"stop\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Schedule_ (
    "",
    &access::object_traits< ::pio::Schedule >::create_schema);

  // Driver
  //

  access::object_traits< ::pio::Driver >::id_type
  access::object_traits< ::pio::Driver >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Driver >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // links
    //
    t[2UL] = false;

    // type
    //
    t[3UL] = false;

    // subtype
    //
    t[4UL] = false;

    // link
    //
    t[5UL] = false;

    // dir
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Driver >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // links
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.links_value;
    b[n].is_null = &i.links_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // subtype
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subtype_value;
    b[n].is_null = &i.subtype_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;
  }

  void access::object_traits< ::pio::Driver >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Driver >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // links
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.links;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.links_value,
          is_null,
          id);
        i.links_null = is_null;
      }
      else
        i.links_null = true;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // subtype
    //
    {
      int const& v =
        o.subtype;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subtype_value,
        is_null,
        v);
      i.subtype_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Driver >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // links
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.links;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.links_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.links_value,
          i.links_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // subtype
    //
    {
      int& v =
        o.subtype;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subtype_value,
        i.subtype_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }
  }

  void access::object_traits< ::pio::Driver >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Driver >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Driver >::persist_statement[] =
  "INSERT INTO \"Driver\" ("
  "\"auto_id\","
  "\"route\","
  "\"links\","
  "\"type\","
  "\"subtype\","
  "\"link\","
  "\"dir\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Driver >::find_statement[] =
  "SELECT "
  "\"Driver\".\"auto_id\","
  "\"Driver\".\"route\","
  "\"Driver\".\"links\","
  "\"Driver\".\"type\","
  "\"Driver\".\"subtype\","
  "\"Driver\".\"link\","
  "\"Driver\".\"dir\""
  " FROM \"Driver\""
  " WHERE \"Driver\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Driver >::update_statement[] =
  "UPDATE \"Driver\" SET "
  "\"route\"=?,"
  "\"links\"=?,"
  "\"type\"=?,"
  "\"subtype\"=?,"
  "\"link\"=?,"
  "\"dir\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Driver >::erase_statement[] =
  "DELETE FROM \"Driver\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Driver >::query_statement[] =
  "SELECT "
  "\"Driver\".\"auto_id\","
  "\"Driver\".\"route\","
  "\"Driver\".\"links\","
  "\"Driver\".\"type\","
  "\"Driver\".\"subtype\","
  "\"Driver\".\"link\","
  "\"Driver\".\"dir\""
  " FROM \"Driver\""
  " LEFT JOIN \"Link\" AS \"links\" ON \"links\".\"link\"=\"Driver\".\"links\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Driver\".\"link\""
  " ";

  const char access::object_traits< ::pio::Driver >::erase_query_statement[] =
  "DELETE FROM \"Driver\""
  " ";

  const char access::object_traits< ::pio::Driver >::table_name[] =
  "\"Driver\"";

  void access::object_traits< ::pio::Driver >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Driver >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Driver >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Driver >::pointer_type
  access::object_traits< ::pio::Driver >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Driver >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Driver >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Driver >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Driver >::object_type >
  access::object_traits< ::pio::Driver >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Driver >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Driver >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Driver\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Driver\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"links\" INTEGER,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"subtype\" INTEGER NOT NULL,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"links_fk\"\n"
                      "    FOREIGN KEY (\"links\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Driver_ (
    "",
    &access::object_traits< ::pio::Driver >::create_schema);

  // Route_Nodes
  //

  access::object_traits< ::pio::Route_Nodes >::id_type
  access::object_traits< ::pio::Route_Nodes >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // mode
    //
    t[2UL] = false;

    // veh_type
    //
    t[3UL] = false;

    // nodes
    //
    t[4UL] = false;

    // name
    //
    if (t[5UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // node
    //
    t[6UL] = false;

    // type
    //
    t[7UL] = false;

    // dwell
    //
    t[8UL] = false;

    // time
    //
    t[9UL] = false;

    // speed
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Route_Nodes >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // veh_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.veh_type_value;
    b[n].is_null = &i.veh_type_null;
    n++;

    // nodes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.nodes_value;
    b[n].is_null = &i.nodes_null;
    n++;

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_value;
    b[n].is_null = &i.node_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.dwell_value;
    b[n].is_null = &i.dwell_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;
  }

  void access::object_traits< ::pio::Route_Nodes >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // veh_type
    //
    {
      ::std::tr1::shared_ptr< ::pio::Veh_Type > const& v =
        o.veh_type;

      typedef object_traits< ::pio::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Veh_Type > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.veh_type_value,
          is_null,
          id);
        i.veh_type_null = is_null;
      }
      else
        i.veh_type_null = true;
    }

    // nodes
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.nodes;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.nodes_value,
          is_null,
          id);
        i.nodes_null = is_null;
      }
      else
        i.nodes_null = true;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node > const& v =
        o.node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_value,
          is_null,
          id);
        i.node_null = is_null;
      }
      else
        i.node_null = true;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // dwell
    //
    {
      double const& v =
        o.dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.dwell_value,
        is_null,
        v);
      i.dwell_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Route_Nodes >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // veh_type
    //
    {
      ::std::tr1::shared_ptr< ::pio::Veh_Type >& v =
        o.veh_type;

      typedef object_traits< ::pio::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Veh_Type > > ptr_traits;

      if (i.veh_type_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.veh_type_value,
          i.veh_type_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // nodes
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.nodes;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.nodes_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.nodes_value,
          i.nodes_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // node
    //
    {
      ::std::tr1::shared_ptr< ::pio::Node >& v =
        o.node;

      typedef object_traits< ::pio::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Node > > ptr_traits;

      if (i.node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_value,
          i.node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // dwell
    //
    {
      double& v =
        o.dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.dwell_value,
        i.dwell_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }
  }

  void access::object_traits< ::pio::Route_Nodes >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Route_Nodes >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Route_Nodes >::persist_statement[] =
  "INSERT INTO \"Route_Nodes\" ("
  "\"auto_id\","
  "\"route\","
  "\"mode\","
  "\"veh_type\","
  "\"nodes\","
  "\"name\","
  "\"node\","
  "\"type\","
  "\"dwell\","
  "\"time\","
  "\"speed\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Route_Nodes >::find_statement[] =
  "SELECT "
  "\"Route_Nodes\".\"auto_id\","
  "\"Route_Nodes\".\"route\","
  "\"Route_Nodes\".\"mode\","
  "\"Route_Nodes\".\"veh_type\","
  "\"Route_Nodes\".\"nodes\","
  "\"Route_Nodes\".\"name\","
  "\"Route_Nodes\".\"node\","
  "\"Route_Nodes\".\"type\","
  "\"Route_Nodes\".\"dwell\","
  "\"Route_Nodes\".\"time\","
  "\"Route_Nodes\".\"speed\""
  " FROM \"Route_Nodes\""
  " WHERE \"Route_Nodes\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Route_Nodes >::update_statement[] =
  "UPDATE \"Route_Nodes\" SET "
  "\"route\"=?,"
  "\"mode\"=?,"
  "\"veh_type\"=?,"
  "\"nodes\"=?,"
  "\"name\"=?,"
  "\"node\"=?,"
  "\"type\"=?,"
  "\"dwell\"=?,"
  "\"time\"=?,"
  "\"speed\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Route_Nodes >::erase_statement[] =
  "DELETE FROM \"Route_Nodes\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Route_Nodes >::query_statement[] =
  "SELECT "
  "\"Route_Nodes\".\"auto_id\","
  "\"Route_Nodes\".\"route\","
  "\"Route_Nodes\".\"mode\","
  "\"Route_Nodes\".\"veh_type\","
  "\"Route_Nodes\".\"nodes\","
  "\"Route_Nodes\".\"name\","
  "\"Route_Nodes\".\"node\","
  "\"Route_Nodes\".\"type\","
  "\"Route_Nodes\".\"dwell\","
  "\"Route_Nodes\".\"time\","
  "\"Route_Nodes\".\"speed\""
  " FROM \"Route_Nodes\""
  " LEFT JOIN \"Veh_Type\" AS \"veh_type\" ON \"veh_type\".\"type\"=\"Route_Nodes\".\"veh_type\""
  " LEFT JOIN \"Node\" AS \"nodes\" ON \"nodes\".\"node\"=\"Route_Nodes\".\"nodes\""
  " LEFT JOIN \"Node\" AS \"node\" ON \"node\".\"node\"=\"Route_Nodes\".\"node\""
  " ";

  const char access::object_traits< ::pio::Route_Nodes >::erase_query_statement[] =
  "DELETE FROM \"Route_Nodes\""
  " ";

  const char access::object_traits< ::pio::Route_Nodes >::table_name[] =
  "\"Route_Nodes\"";

  void access::object_traits< ::pio::Route_Nodes >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Route_Nodes >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Route_Nodes >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Route_Nodes >::pointer_type
  access::object_traits< ::pio::Route_Nodes >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Route_Nodes >::object_type >
  access::object_traits< ::pio::Route_Nodes >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Route_Nodes >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Route_Nodes >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Route_Nodes\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Route_Nodes\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"veh_type\" INTEGER,\n"
                      "  \"nodes\" INTEGER,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"node\" INTEGER,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"dwell\" REAL,\n"
                      "  \"time\" REAL,\n"
                      "  \"speed\" REAL,\n"
                      "  CONSTRAINT \"veh_type_fk\"\n"
                      "    FOREIGN KEY (\"veh_type\")\n"
                      "    REFERENCES \"Veh_Type\" (\"type\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"nodes_fk\"\n"
                      "    FOREIGN KEY (\"nodes\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"node_fk\"\n"
                      "    FOREIGN KEY (\"node\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Route_Nodes_ (
    "",
    &access::object_traits< ::pio::Route_Nodes >::create_schema);

  // Selection
  //

  access::object_traits< ::pio::Selection >::id_type
  access::object_traits< ::pio::Selection >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Selection >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // type
    //
    t[5UL] = false;

    // partition
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Selection >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;
  }

  void access::object_traits< ::pio::Selection >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Selection >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Selection >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }
  }

  void access::object_traits< ::pio::Selection >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Selection >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Selection >::persist_statement[] =
  "INSERT INTO \"Selection\" ("
  "\"auto_id\","
  "\"hhold\","
  "\"person\","
  "\"tour\","
  "\"trip\","
  "\"type\","
  "\"partition\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Selection >::find_statement[] =
  "SELECT "
  "\"Selection\".\"auto_id\","
  "\"Selection\".\"hhold\","
  "\"Selection\".\"person\","
  "\"Selection\".\"tour\","
  "\"Selection\".\"trip\","
  "\"Selection\".\"type\","
  "\"Selection\".\"partition\""
  " FROM \"Selection\""
  " WHERE \"Selection\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Selection >::update_statement[] =
  "UPDATE \"Selection\" SET "
  "\"hhold\"=?,"
  "\"person\"=?,"
  "\"tour\"=?,"
  "\"trip\"=?,"
  "\"type\"=?,"
  "\"partition\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Selection >::erase_statement[] =
  "DELETE FROM \"Selection\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Selection >::query_statement[] =
  "SELECT "
  "\"Selection\".\"auto_id\","
  "\"Selection\".\"hhold\","
  "\"Selection\".\"person\","
  "\"Selection\".\"tour\","
  "\"Selection\".\"trip\","
  "\"Selection\".\"type\","
  "\"Selection\".\"partition\""
  " FROM \"Selection\""
  " ";

  const char access::object_traits< ::pio::Selection >::erase_query_statement[] =
  "DELETE FROM \"Selection\""
  " ";

  const char access::object_traits< ::pio::Selection >::table_name[] =
  "\"Selection\"";

  void access::object_traits< ::pio::Selection >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Selection >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Selection >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Selection >::pointer_type
  access::object_traits< ::pio::Selection >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Selection >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Selection >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Selection >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Selection >::object_type >
  access::object_traits< ::pio::Selection >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Selection >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Selection >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Selection\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Selection\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"hhold\" INTEGER NOT NULL,\n"
                      "  \"person\" INTEGER NOT NULL,\n"
                      "  \"tour\" INTEGER NOT NULL,\n"
                      "  \"trip\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"partition\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Selection_ (
    "",
    &access::object_traits< ::pio::Selection >::create_schema);

  // Household
  //

  access::object_traits< ::pio::Household >::id_type
  access::object_traits< ::pio::Household >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Household >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // location
    //
    t[2UL] = false;

    // persons
    //
    t[3UL] = false;

    // workers
    //
    t[4UL] = false;

    // vehicles
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // partition
    //
    t[7UL] = false;

    // person
    //
    t[8UL] = false;

    // age
    //
    t[9UL] = false;

    // relate
    //
    t[10UL] = false;

    // gender
    //
    t[11UL] = false;

    // work
    //
    t[12UL] = false;

    // drive
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Household >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // location
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.location_value;
    b[n].is_null = &i.location_null;
    n++;

    // persons
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.persons_value;
    b[n].is_null = &i.persons_null;
    n++;

    // workers
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.workers_value;
    b[n].is_null = &i.workers_null;
    n++;

    // vehicles
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.vehicles_value;
    b[n].is_null = &i.vehicles_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // age
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.age_value;
    b[n].is_null = &i.age_null;
    n++;

    // relate
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.relate_value;
    b[n].is_null = &i.relate_null;
    n++;

    // gender
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.gender_value;
    b[n].is_null = &i.gender_null;
    n++;

    // work
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.work_value;
    b[n].is_null = &i.work_null;
    n++;

    // drive
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.drive_value;
    b[n].is_null = &i.drive_null;
    n++;
  }

  void access::object_traits< ::pio::Household >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Household >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // location
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location > const& v =
        o.location;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.location_value,
          is_null,
          id);
        i.location_null = is_null;
      }
      else
        i.location_null = true;
    }

    // persons
    //
    {
      int const& v =
        o.persons;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.persons_value,
        is_null,
        v);
      i.persons_null = is_null;
    }

    // workers
    //
    {
      int const& v =
        o.workers;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.workers_value,
        is_null,
        v);
      i.workers_null = is_null;
    }

    // vehicles
    //
    {
      int const& v =
        o.vehicles;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.vehicles_value,
        is_null,
        v);
      i.vehicles_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // age
    //
    {
      int const& v =
        o.age;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.age_value,
        is_null,
        v);
      i.age_null = is_null;
    }

    // relate
    //
    {
      int const& v =
        o.relate;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.relate_value,
        is_null,
        v);
      i.relate_null = is_null;
    }

    // gender
    //
    {
      int const& v =
        o.gender;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.gender_value,
        is_null,
        v);
      i.gender_null = is_null;
    }

    // work
    //
    {
      int const& v =
        o.work;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.work_value,
        is_null,
        v);
      i.work_null = is_null;
    }

    // drive
    //
    {
      int const& v =
        o.drive;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.drive_value,
        is_null,
        v);
      i.drive_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Household >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // location
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location >& v =
        o.location;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      if (i.location_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.location_value,
          i.location_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // persons
    //
    {
      int& v =
        o.persons;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.persons_value,
        i.persons_null);
    }

    // workers
    //
    {
      int& v =
        o.workers;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.workers_value,
        i.workers_null);
    }

    // vehicles
    //
    {
      int& v =
        o.vehicles;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.vehicles_value,
        i.vehicles_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // age
    //
    {
      int& v =
        o.age;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.age_value,
        i.age_null);
    }

    // relate
    //
    {
      int& v =
        o.relate;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.relate_value,
        i.relate_null);
    }

    // gender
    //
    {
      int& v =
        o.gender;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.gender_value,
        i.gender_null);
    }

    // work
    //
    {
      int& v =
        o.work;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.work_value,
        i.work_null);
    }

    // drive
    //
    {
      int& v =
        o.drive;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.drive_value,
        i.drive_null);
    }
  }

  void access::object_traits< ::pio::Household >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Household >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Household >::persist_statement[] =
  "INSERT INTO \"Household\" ("
  "\"auto_id\","
  "\"hhold\","
  "\"location\","
  "\"persons\","
  "\"workers\","
  "\"vehicles\","
  "\"type\","
  "\"partition\","
  "\"person\","
  "\"age\","
  "\"relate\","
  "\"gender\","
  "\"work\","
  "\"drive\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Household >::find_statement[] =
  "SELECT "
  "\"Household\".\"auto_id\","
  "\"Household\".\"hhold\","
  "\"Household\".\"location\","
  "\"Household\".\"persons\","
  "\"Household\".\"workers\","
  "\"Household\".\"vehicles\","
  "\"Household\".\"type\","
  "\"Household\".\"partition\","
  "\"Household\".\"person\","
  "\"Household\".\"age\","
  "\"Household\".\"relate\","
  "\"Household\".\"gender\","
  "\"Household\".\"work\","
  "\"Household\".\"drive\""
  " FROM \"Household\""
  " WHERE \"Household\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Household >::update_statement[] =
  "UPDATE \"Household\" SET "
  "\"hhold\"=?,"
  "\"location\"=?,"
  "\"persons\"=?,"
  "\"workers\"=?,"
  "\"vehicles\"=?,"
  "\"type\"=?,"
  "\"partition\"=?,"
  "\"person\"=?,"
  "\"age\"=?,"
  "\"relate\"=?,"
  "\"gender\"=?,"
  "\"work\"=?,"
  "\"drive\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Household >::erase_statement[] =
  "DELETE FROM \"Household\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Household >::query_statement[] =
  "SELECT "
  "\"Household\".\"auto_id\","
  "\"Household\".\"hhold\","
  "\"Household\".\"location\","
  "\"Household\".\"persons\","
  "\"Household\".\"workers\","
  "\"Household\".\"vehicles\","
  "\"Household\".\"type\","
  "\"Household\".\"partition\","
  "\"Household\".\"person\","
  "\"Household\".\"age\","
  "\"Household\".\"relate\","
  "\"Household\".\"gender\","
  "\"Household\".\"work\","
  "\"Household\".\"drive\""
  " FROM \"Household\""
  " LEFT JOIN \"Location\" AS \"location\" ON \"location\".\"location\"=\"Household\".\"location\""
  " ";

  const char access::object_traits< ::pio::Household >::erase_query_statement[] =
  "DELETE FROM \"Household\""
  " ";

  const char access::object_traits< ::pio::Household >::table_name[] =
  "\"Household\"";

  void access::object_traits< ::pio::Household >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Household >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Household >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Household >::pointer_type
  access::object_traits< ::pio::Household >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Household >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Household >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Household >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Household >::object_type >
  access::object_traits< ::pio::Household >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Household >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Household >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Household\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Household\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"hhold\" INTEGER NOT NULL,\n"
                      "  \"location\" INTEGER,\n"
                      "  \"persons\" INTEGER NOT NULL,\n"
                      "  \"workers\" INTEGER NOT NULL,\n"
                      "  \"vehicles\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"partition\" INTEGER NOT NULL,\n"
                      "  \"person\" INTEGER NOT NULL,\n"
                      "  \"age\" INTEGER NOT NULL,\n"
                      "  \"relate\" INTEGER NOT NULL,\n"
                      "  \"gender\" INTEGER NOT NULL,\n"
                      "  \"work\" INTEGER NOT NULL,\n"
                      "  \"drive\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"location_fk\"\n"
                      "    FOREIGN KEY (\"location\")\n"
                      "    REFERENCES \"Location\" (\"location\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Household_ (
    "",
    &access::object_traits< ::pio::Household >::create_schema);

  // Link_Delay
  //

  access::object_traits< ::pio::Link_Delay >::id_type
  access::object_traits< ::pio::Link_Delay >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // type
    //
    t[3UL] = false;

    // start
    //
    t[4UL] = false;

    // end
    //
    t[5UL] = false;

    // flow
    //
    t[6UL] = false;

    // time
    //
    t[7UL] = false;

    // out_link
    //
    t[8UL] = false;

    // out_flow
    //
    t[9UL] = false;

    // out_time
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Link_Delay >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // flow
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.flow_value;
    b[n].is_null = &i.flow_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // out_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.out_link_value;
    b[n].is_null = &i.out_link_null;
    n++;

    // out_flow
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.out_flow_value;
    b[n].is_null = &i.out_flow_null;
    n++;

    // out_time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.out_time_value;
    b[n].is_null = &i.out_time_null;
    n++;
  }

  void access::object_traits< ::pio::Link_Delay >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // flow
    //
    {
      double const& v =
        o.flow;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.flow_value,
        is_null,
        v);
      i.flow_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // out_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.out_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.out_link_value,
          is_null,
          id);
        i.out_link_null = is_null;
      }
      else
        i.out_link_null = true;
    }

    // out_flow
    //
    {
      double const& v =
        o.out_flow;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.out_flow_value,
        is_null,
        v);
      i.out_flow_null = is_null;
    }

    // out_time
    //
    {
      double const& v =
        o.out_time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.out_time_value,
        is_null,
        v);
      i.out_time_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Link_Delay >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // flow
    //
    {
      double& v =
        o.flow;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.flow_value,
        i.flow_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // out_link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.out_link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.out_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.out_link_value,
          i.out_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // out_flow
    //
    {
      double& v =
        o.out_flow;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.out_flow_value,
        i.out_flow_null);
    }

    // out_time
    //
    {
      double& v =
        o.out_time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.out_time_value,
        i.out_time_null);
    }
  }

  void access::object_traits< ::pio::Link_Delay >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Link_Delay >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Link_Delay >::persist_statement[] =
  "INSERT INTO \"Link_Delay\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"type\","
  "\"start\","
  "\"end\","
  "\"flow\","
  "\"time\","
  "\"out_link\","
  "\"out_flow\","
  "\"out_time\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Link_Delay >::find_statement[] =
  "SELECT "
  "\"Link_Delay\".\"auto_id\","
  "\"Link_Delay\".\"link\","
  "\"Link_Delay\".\"dir\","
  "\"Link_Delay\".\"type\","
  "\"Link_Delay\".\"start\","
  "\"Link_Delay\".\"end\","
  "\"Link_Delay\".\"flow\","
  "\"Link_Delay\".\"time\","
  "\"Link_Delay\".\"out_link\","
  "\"Link_Delay\".\"out_flow\","
  "\"Link_Delay\".\"out_time\""
  " FROM \"Link_Delay\""
  " WHERE \"Link_Delay\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Link_Delay >::update_statement[] =
  "UPDATE \"Link_Delay\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"type\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"flow\"=?,"
  "\"time\"=?,"
  "\"out_link\"=?,"
  "\"out_flow\"=?,"
  "\"out_time\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Link_Delay >::erase_statement[] =
  "DELETE FROM \"Link_Delay\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Link_Delay >::query_statement[] =
  "SELECT "
  "\"Link_Delay\".\"auto_id\","
  "\"Link_Delay\".\"link\","
  "\"Link_Delay\".\"dir\","
  "\"Link_Delay\".\"type\","
  "\"Link_Delay\".\"start\","
  "\"Link_Delay\".\"end\","
  "\"Link_Delay\".\"flow\","
  "\"Link_Delay\".\"time\","
  "\"Link_Delay\".\"out_link\","
  "\"Link_Delay\".\"out_flow\","
  "\"Link_Delay\".\"out_time\""
  " FROM \"Link_Delay\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Link_Delay\".\"link\""
  " LEFT JOIN \"Link\" AS \"out_link\" ON \"out_link\".\"link\"=\"Link_Delay\".\"out_link\""
  " ";

  const char access::object_traits< ::pio::Link_Delay >::erase_query_statement[] =
  "DELETE FROM \"Link_Delay\""
  " ";

  const char access::object_traits< ::pio::Link_Delay >::table_name[] =
  "\"Link_Delay\"";

  void access::object_traits< ::pio::Link_Delay >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Link_Delay >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Link_Delay >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Link_Delay >::pointer_type
  access::object_traits< ::pio::Link_Delay >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Link_Delay >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Link_Delay >::object_type >
  access::object_traits< ::pio::Link_Delay >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Link_Delay >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Link_Delay >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Link_Delay\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Link_Delay\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"flow\" REAL,\n"
                      "  \"time\" REAL,\n"
                      "  \"out_link\" INTEGER,\n"
                      "  \"out_flow\" REAL,\n"
                      "  \"out_time\" REAL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"out_link_fk\"\n"
                      "    FOREIGN KEY (\"out_link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Link_Delay_ (
    "",
    &access::object_traits< ::pio::Link_Delay >::create_schema);

  // Performance
  //

  access::object_traits< ::pio::Performance >::id_type
  access::object_traits< ::pio::Performance >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Performance >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // speed
    //
    t[1UL] = false;

    // delay
    //
    t[2UL] = false;

    // density
    //
    t[3UL] = false;

    // max_den
    //
    t[4UL] = false;

    // ratio
    //
    t[5UL] = false;

    // queue
    //
    t[6UL] = false;

    // max_que
    //
    t[7UL] = false;

    // fail
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Performance >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;

    // delay
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.delay_value;
    b[n].is_null = &i.delay_null;
    n++;

    // density
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.density_value;
    b[n].is_null = &i.density_null;
    n++;

    // max_den
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_den_value;
    b[n].is_null = &i.max_den_null;
    n++;

    // ratio
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.ratio_value;
    b[n].is_null = &i.ratio_null;
    n++;

    // queue
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.queue_value;
    b[n].is_null = &i.queue_null;
    n++;

    // max_que
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_que_value;
    b[n].is_null = &i.max_que_null;
    n++;

    // fail
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.fail_value;
    b[n].is_null = &i.fail_null;
    n++;
  }

  void access::object_traits< ::pio::Performance >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Performance >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    // delay
    //
    {
      double const& v =
        o.delay;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.delay_value,
        is_null,
        v);
      i.delay_null = is_null;
    }

    // density
    //
    {
      double const& v =
        o.density;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.density_value,
        is_null,
        v);
      i.density_null = is_null;
    }

    // max_den
    //
    {
      double const& v =
        o.max_den;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_den_value,
        is_null,
        v);
      i.max_den_null = is_null;
    }

    // ratio
    //
    {
      double const& v =
        o.ratio;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.ratio_value,
        is_null,
        v);
      i.ratio_null = is_null;
    }

    // queue
    //
    {
      double const& v =
        o.queue;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.queue_value,
        is_null,
        v);
      i.queue_null = is_null;
    }

    // max_que
    //
    {
      int const& v =
        o.max_que;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_que_value,
        is_null,
        v);
      i.max_que_null = is_null;
    }

    // fail
    //
    {
      int const& v =
        o.fail;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.fail_value,
        is_null,
        v);
      i.fail_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Performance >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }

    // delay
    //
    {
      double& v =
        o.delay;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.delay_value,
        i.delay_null);
    }

    // density
    //
    {
      double& v =
        o.density;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.density_value,
        i.density_null);
    }

    // max_den
    //
    {
      double& v =
        o.max_den;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_den_value,
        i.max_den_null);
    }

    // ratio
    //
    {
      double& v =
        o.ratio;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.ratio_value,
        i.ratio_null);
    }

    // queue
    //
    {
      double& v =
        o.queue;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.queue_value,
        i.queue_null);
    }

    // max_que
    //
    {
      int& v =
        o.max_que;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_que_value,
        i.max_que_null);
    }

    // fail
    //
    {
      int& v =
        o.fail;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.fail_value,
        i.fail_null);
    }
  }

  void access::object_traits< ::pio::Performance >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Performance >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Performance >::persist_statement[] =
  "INSERT INTO \"Performance\" ("
  "\"auto_id\","
  "\"speed\","
  "\"delay\","
  "\"density\","
  "\"max_den\","
  "\"ratio\","
  "\"queue\","
  "\"max_que\","
  "\"fail\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Performance >::find_statement[] =
  "SELECT "
  "\"Performance\".\"auto_id\","
  "\"Performance\".\"speed\","
  "\"Performance\".\"delay\","
  "\"Performance\".\"density\","
  "\"Performance\".\"max_den\","
  "\"Performance\".\"ratio\","
  "\"Performance\".\"queue\","
  "\"Performance\".\"max_que\","
  "\"Performance\".\"fail\""
  " FROM \"Performance\""
  " WHERE \"Performance\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Performance >::update_statement[] =
  "UPDATE \"Performance\" SET "
  "\"speed\"=?,"
  "\"delay\"=?,"
  "\"density\"=?,"
  "\"max_den\"=?,"
  "\"ratio\"=?,"
  "\"queue\"=?,"
  "\"max_que\"=?,"
  "\"fail\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Performance >::erase_statement[] =
  "DELETE FROM \"Performance\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Performance >::query_statement[] =
  "SELECT "
  "\"Performance\".\"auto_id\","
  "\"Performance\".\"speed\","
  "\"Performance\".\"delay\","
  "\"Performance\".\"density\","
  "\"Performance\".\"max_den\","
  "\"Performance\".\"ratio\","
  "\"Performance\".\"queue\","
  "\"Performance\".\"max_que\","
  "\"Performance\".\"fail\""
  " FROM \"Performance\""
  " ";

  const char access::object_traits< ::pio::Performance >::erase_query_statement[] =
  "DELETE FROM \"Performance\""
  " ";

  const char access::object_traits< ::pio::Performance >::table_name[] =
  "\"Performance\"";

  void access::object_traits< ::pio::Performance >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Performance >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Performance >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Performance >::pointer_type
  access::object_traits< ::pio::Performance >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Performance >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Performance >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Performance >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Performance >::object_type >
  access::object_traits< ::pio::Performance >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Performance >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Performance >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Performance\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Performance\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"speed\" REAL,\n"
                      "  \"delay\" REAL,\n"
                      "  \"density\" REAL,\n"
                      "  \"max_den\" REAL,\n"
                      "  \"ratio\" REAL,\n"
                      "  \"queue\" REAL,\n"
                      "  \"max_que\" INTEGER NOT NULL,\n"
                      "  \"fail\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Performance_ (
    "",
    &access::object_traits< ::pio::Performance >::create_schema);

  // Ridership
  //

  access::object_traits< ::pio::Ridership >::id_type
  access::object_traits< ::pio::Ridership >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Ridership >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // mode
    //
    t[1UL] = false;

    // route
    //
    t[2UL] = false;

    // run
    //
    t[3UL] = false;

    // stop
    //
    t[4UL] = false;

    // schedule
    //
    t[5UL] = false;

    // time
    //
    t[6UL] = false;

    // board
    //
    t[7UL] = false;

    // alight
    //
    t[8UL] = false;

    // load
    //
    t[9UL] = false;

    // factor
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Ridership >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // run
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.run_value;
    b[n].is_null = &i.run_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;

    // schedule
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.schedule_value;
    b[n].is_null = &i.schedule_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // board
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.board_value;
    b[n].is_null = &i.board_null;
    n++;

    // alight
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.alight_value;
    b[n].is_null = &i.alight_null;
    n++;

    // load
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.load_value;
    b[n].is_null = &i.load_null;
    n++;

    // factor
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.factor_value;
    b[n].is_null = &i.factor_null;
    n++;
  }

  void access::object_traits< ::pio::Ridership >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Ridership >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // run
    //
    {
      int const& v =
        o.run;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.run_value,
        is_null,
        v);
      i.run_null = is_null;
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop > const& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    // schedule
    //
    {
      double const& v =
        o.schedule;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.schedule_value,
        is_null,
        v);
      i.schedule_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // board
    //
    {
      int const& v =
        o.board;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.board_value,
        is_null,
        v);
      i.board_null = is_null;
    }

    // alight
    //
    {
      int const& v =
        o.alight;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.alight_value,
        is_null,
        v);
      i.alight_null = is_null;
    }

    // load
    //
    {
      int const& v =
        o.load;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.load_value,
        is_null,
        v);
      i.load_null = is_null;
    }

    // factor
    //
    {
      double const& v =
        o.factor;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.factor_value,
        is_null,
        v);
      i.factor_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Ridership >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // run
    //
    {
      int& v =
        o.run;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.run_value,
        i.run_null);
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::pio::Stop >& v =
        o.stop;

      typedef object_traits< ::pio::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // schedule
    //
    {
      double& v =
        o.schedule;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.schedule_value,
        i.schedule_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // board
    //
    {
      int& v =
        o.board;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.board_value,
        i.board_null);
    }

    // alight
    //
    {
      int& v =
        o.alight;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.alight_value,
        i.alight_null);
    }

    // load
    //
    {
      int& v =
        o.load;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.load_value,
        i.load_null);
    }

    // factor
    //
    {
      double& v =
        o.factor;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.factor_value,
        i.factor_null);
    }
  }

  void access::object_traits< ::pio::Ridership >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Ridership >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Ridership >::persist_statement[] =
  "INSERT INTO \"Ridership\" ("
  "\"auto_id\","
  "\"mode\","
  "\"route\","
  "\"run\","
  "\"stop\","
  "\"schedule\","
  "\"time\","
  "\"board\","
  "\"alight\","
  "\"load\","
  "\"factor\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Ridership >::find_statement[] =
  "SELECT "
  "\"Ridership\".\"auto_id\","
  "\"Ridership\".\"mode\","
  "\"Ridership\".\"route\","
  "\"Ridership\".\"run\","
  "\"Ridership\".\"stop\","
  "\"Ridership\".\"schedule\","
  "\"Ridership\".\"time\","
  "\"Ridership\".\"board\","
  "\"Ridership\".\"alight\","
  "\"Ridership\".\"load\","
  "\"Ridership\".\"factor\""
  " FROM \"Ridership\""
  " WHERE \"Ridership\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Ridership >::update_statement[] =
  "UPDATE \"Ridership\" SET "
  "\"mode\"=?,"
  "\"route\"=?,"
  "\"run\"=?,"
  "\"stop\"=?,"
  "\"schedule\"=?,"
  "\"time\"=?,"
  "\"board\"=?,"
  "\"alight\"=?,"
  "\"load\"=?,"
  "\"factor\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Ridership >::erase_statement[] =
  "DELETE FROM \"Ridership\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Ridership >::query_statement[] =
  "SELECT "
  "\"Ridership\".\"auto_id\","
  "\"Ridership\".\"mode\","
  "\"Ridership\".\"route\","
  "\"Ridership\".\"run\","
  "\"Ridership\".\"stop\","
  "\"Ridership\".\"schedule\","
  "\"Ridership\".\"time\","
  "\"Ridership\".\"board\","
  "\"Ridership\".\"alight\","
  "\"Ridership\".\"load\","
  "\"Ridership\".\"factor\""
  " FROM \"Ridership\""
  " LEFT JOIN \"Stop\" AS \"stop\" ON \"stop\".\"stop\"=\"Ridership\".\"stop\""
  " ";

  const char access::object_traits< ::pio::Ridership >::erase_query_statement[] =
  "DELETE FROM \"Ridership\""
  " ";

  const char access::object_traits< ::pio::Ridership >::table_name[] =
  "\"Ridership\"";

  void access::object_traits< ::pio::Ridership >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Ridership >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Ridership >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Ridership >::pointer_type
  access::object_traits< ::pio::Ridership >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Ridership >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Ridership >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Ridership >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Ridership >::object_type >
  access::object_traits< ::pio::Ridership >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Ridership >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Ridership >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Ridership\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Ridership\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"run\" INTEGER NOT NULL,\n"
                      "  \"stop\" INTEGER,\n"
                      "  \"schedule\" REAL,\n"
                      "  \"time\" REAL,\n"
                      "  \"board\" INTEGER NOT NULL,\n"
                      "  \"alight\" INTEGER NOT NULL,\n"
                      "  \"load\" INTEGER NOT NULL,\n"
                      "  \"factor\" REAL,\n"
                      "  CONSTRAINT \"stop_fk\"\n"
                      "    FOREIGN KEY (\"stop\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Ridership_ (
    "",
    &access::object_traits< ::pio::Ridership >::create_schema);

  // Veh_Type
  //

  access::object_traits< ::pio::Veh_Type >::id_type
  access::object_traits< ::pio::Veh_Type >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.type_value,
        i.type_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // type
    //
    t[0UL] = false;

    // length
    //
    t[1UL] = false;

    // max_speed
    //
    t[2UL] = false;

    // max_accel
    //
    t[3UL] = false;

    // max_decel
    //
    t[4UL] = false;

    // op_cost
    //
    t[5UL] = false;

    // use
    //
    t[6UL] = false;

    // capacity
    //
    t[7UL] = false;

    // load
    //
    t[8UL] = false;

    // unload
    //
    t[9UL] = false;

    // method
    //
    t[10UL] = false;

    // min_dwell
    //
    t[11UL] = false;

    // max_dwell
    //
    t[12UL] = false;

    // subtype
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Veh_Type >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // type
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.type_value;
      b[n].is_null = &i.type_null;
      n++;
    }

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // max_speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_speed_value;
    b[n].is_null = &i.max_speed_null;
    n++;

    // max_accel
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_accel_value;
    b[n].is_null = &i.max_accel_null;
    n++;

    // max_decel
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_decel_value;
    b[n].is_null = &i.max_decel_null;
    n++;

    // op_cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.op_cost_value;
    b[n].is_null = &i.op_cost_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // capacity
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.capacity_value;
    b[n].is_null = &i.capacity_null;
    n++;

    // load
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.load_value;
    b[n].is_null = &i.load_null;
    n++;

    // unload
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.unload_value;
    b[n].is_null = &i.unload_null;
    n++;

    // method
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.method_value;
    b[n].is_null = &i.method_null;
    n++;

    // min_dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_dwell_value;
    b[n].is_null = &i.min_dwell_null;
    n++;

    // max_dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_dwell_value;
    b[n].is_null = &i.max_dwell_null;
    n++;

    // subtype
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subtype_value;
    b[n].is_null = &i.subtype_null;
    n++;
  }

  void access::object_traits< ::pio::Veh_Type >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // type
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // max_speed
    //
    {
      double const& v =
        o.max_speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_speed_value,
        is_null,
        v);
      i.max_speed_null = is_null;
    }

    // max_accel
    //
    {
      double const& v =
        o.max_accel;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_accel_value,
        is_null,
        v);
      i.max_accel_null = is_null;
    }

    // max_decel
    //
    {
      double const& v =
        o.max_decel;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_decel_value,
        is_null,
        v);
      i.max_decel_null = is_null;
    }

    // op_cost
    //
    {
      double const& v =
        o.op_cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.op_cost_value,
        is_null,
        v);
      i.op_cost_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // capacity
    //
    {
      int const& v =
        o.capacity;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.capacity_value,
        is_null,
        v);
      i.capacity_null = is_null;
    }

    // load
    //
    {
      double const& v =
        o.load;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.load_value,
        is_null,
        v);
      i.load_null = is_null;
    }

    // unload
    //
    {
      double const& v =
        o.unload;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.unload_value,
        is_null,
        v);
      i.unload_null = is_null;
    }

    // method
    //
    {
      int const& v =
        o.method;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.method_value,
        is_null,
        v);
      i.method_null = is_null;
    }

    // min_dwell
    //
    {
      double const& v =
        o.min_dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_dwell_value,
        is_null,
        v);
      i.min_dwell_null = is_null;
    }

    // max_dwell
    //
    {
      double const& v =
        o.max_dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_dwell_value,
        is_null,
        v);
      i.max_dwell_null = is_null;
    }

    // subtype
    //
    {
      int const& v =
        o.subtype;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subtype_value,
        is_null,
        v);
      i.subtype_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Veh_Type >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // max_speed
    //
    {
      double& v =
        o.max_speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_speed_value,
        i.max_speed_null);
    }

    // max_accel
    //
    {
      double& v =
        o.max_accel;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_accel_value,
        i.max_accel_null);
    }

    // max_decel
    //
    {
      double& v =
        o.max_decel;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_decel_value,
        i.max_decel_null);
    }

    // op_cost
    //
    {
      double& v =
        o.op_cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.op_cost_value,
        i.op_cost_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // capacity
    //
    {
      int& v =
        o.capacity;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.capacity_value,
        i.capacity_null);
    }

    // load
    //
    {
      double& v =
        o.load;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.load_value,
        i.load_null);
    }

    // unload
    //
    {
      double& v =
        o.unload;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.unload_value,
        i.unload_null);
    }

    // method
    //
    {
      int& v =
        o.method;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.method_value,
        i.method_null);
    }

    // min_dwell
    //
    {
      double& v =
        o.min_dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_dwell_value,
        i.min_dwell_null);
    }

    // max_dwell
    //
    {
      double& v =
        o.max_dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_dwell_value,
        i.max_dwell_null);
    }

    // subtype
    //
    {
      int& v =
        o.subtype;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subtype_value,
        i.subtype_null);
    }
  }

  void access::object_traits< ::pio::Veh_Type >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Veh_Type >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Veh_Type >::persist_statement[] =
  "INSERT INTO \"Veh_Type\" ("
  "\"type\","
  "\"length\","
  "\"max_speed\","
  "\"max_accel\","
  "\"max_decel\","
  "\"op_cost\","
  "\"use\","
  "\"capacity\","
  "\"load\","
  "\"unload\","
  "\"method\","
  "\"min_dwell\","
  "\"max_dwell\","
  "\"subtype\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Veh_Type >::find_statement[] =
  "SELECT "
  "\"Veh_Type\".\"type\","
  "\"Veh_Type\".\"length\","
  "\"Veh_Type\".\"max_speed\","
  "\"Veh_Type\".\"max_accel\","
  "\"Veh_Type\".\"max_decel\","
  "\"Veh_Type\".\"op_cost\","
  "\"Veh_Type\".\"use\","
  "\"Veh_Type\".\"capacity\","
  "\"Veh_Type\".\"load\","
  "\"Veh_Type\".\"unload\","
  "\"Veh_Type\".\"method\","
  "\"Veh_Type\".\"min_dwell\","
  "\"Veh_Type\".\"max_dwell\","
  "\"Veh_Type\".\"subtype\""
  " FROM \"Veh_Type\""
  " WHERE \"Veh_Type\".\"type\"=?";

  const char access::object_traits< ::pio::Veh_Type >::update_statement[] =
  "UPDATE \"Veh_Type\" SET "
  "\"length\"=?,"
  "\"max_speed\"=?,"
  "\"max_accel\"=?,"
  "\"max_decel\"=?,"
  "\"op_cost\"=?,"
  "\"use\"=?,"
  "\"capacity\"=?,"
  "\"load\"=?,"
  "\"unload\"=?,"
  "\"method\"=?,"
  "\"min_dwell\"=?,"
  "\"max_dwell\"=?,"
  "\"subtype\"=?"
  " WHERE \"type\"=?";

  const char access::object_traits< ::pio::Veh_Type >::erase_statement[] =
  "DELETE FROM \"Veh_Type\""
  " WHERE \"type\"=?";

  const char access::object_traits< ::pio::Veh_Type >::query_statement[] =
  "SELECT "
  "\"Veh_Type\".\"type\","
  "\"Veh_Type\".\"length\","
  "\"Veh_Type\".\"max_speed\","
  "\"Veh_Type\".\"max_accel\","
  "\"Veh_Type\".\"max_decel\","
  "\"Veh_Type\".\"op_cost\","
  "\"Veh_Type\".\"use\","
  "\"Veh_Type\".\"capacity\","
  "\"Veh_Type\".\"load\","
  "\"Veh_Type\".\"unload\","
  "\"Veh_Type\".\"method\","
  "\"Veh_Type\".\"min_dwell\","
  "\"Veh_Type\".\"max_dwell\","
  "\"Veh_Type\".\"subtype\""
  " FROM \"Veh_Type\""
  " ";

  const char access::object_traits< ::pio::Veh_Type >::erase_query_statement[] =
  "DELETE FROM \"Veh_Type\""
  " ";

  const char access::object_traits< ::pio::Veh_Type >::table_name[] =
  "\"Veh_Type\"";

  void access::object_traits< ::pio::Veh_Type >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Veh_Type >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.type);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Veh_Type >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Veh_Type >::pointer_type
  access::object_traits< ::pio::Veh_Type >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.type);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Veh_Type >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Veh_Type >::object_type >
  access::object_traits< ::pio::Veh_Type >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Veh_Type >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Veh_Type >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Veh_Type\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Veh_Type\" (\n"
                      "  \"type\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"length\" REAL,\n"
                      "  \"max_speed\" REAL,\n"
                      "  \"max_accel\" REAL,\n"
                      "  \"max_decel\" REAL,\n"
                      "  \"op_cost\" REAL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"capacity\" INTEGER NOT NULL,\n"
                      "  \"load\" REAL,\n"
                      "  \"unload\" REAL,\n"
                      "  \"method\" INTEGER NOT NULL,\n"
                      "  \"min_dwell\" REAL,\n"
                      "  \"max_dwell\" REAL,\n"
                      "  \"subtype\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Veh_Type_ (
    "",
    &access::object_traits< ::pio::Veh_Type >::create_schema);

  // Vehicle
  //

  access::object_traits< ::pio::Vehicle >::id_type
  access::object_traits< ::pio::Vehicle >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Vehicle >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // vehicle
    //
    t[2UL] = false;

    // parking
    //
    t[3UL] = false;

    // type
    //
    t[4UL] = false;

    // subtype
    //
    t[5UL] = false;

    // partition
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Vehicle >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // vehicle
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.vehicle_value;
    b[n].is_null = &i.vehicle_null;
    n++;

    // parking
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.parking_value;
    b[n].is_null = &i.parking_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // subtype
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subtype_value;
    b[n].is_null = &i.subtype_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;
  }

  void access::object_traits< ::pio::Vehicle >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Vehicle >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // vehicle
    //
    {
      int const& v =
        o.vehicle;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.vehicle_value,
        is_null,
        v);
      i.vehicle_null = is_null;
    }

    // parking
    //
    {
      ::std::tr1::shared_ptr< ::pio::Parking > const& v =
        o.parking;

      typedef object_traits< ::pio::Parking > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Parking > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.parking_value,
          is_null,
          id);
        i.parking_null = is_null;
      }
      else
        i.parking_null = true;
    }

    // type
    //
    {
      ::std::tr1::shared_ptr< ::pio::Veh_Type > const& v =
        o.type;

      typedef object_traits< ::pio::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Veh_Type > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.type_value,
          is_null,
          id);
        i.type_null = is_null;
      }
      else
        i.type_null = true;
    }

    // subtype
    //
    {
      int const& v =
        o.subtype;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subtype_value,
        is_null,
        v);
      i.subtype_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Vehicle >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // vehicle
    //
    {
      int& v =
        o.vehicle;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.vehicle_value,
        i.vehicle_null);
    }

    // parking
    //
    {
      ::std::tr1::shared_ptr< ::pio::Parking >& v =
        o.parking;

      typedef object_traits< ::pio::Parking > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Parking > > ptr_traits;

      if (i.parking_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.parking_value,
          i.parking_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      ::std::tr1::shared_ptr< ::pio::Veh_Type >& v =
        o.type;

      typedef object_traits< ::pio::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Veh_Type > > ptr_traits;

      if (i.type_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.type_value,
          i.type_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // subtype
    //
    {
      int& v =
        o.subtype;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subtype_value,
        i.subtype_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }
  }

  void access::object_traits< ::pio::Vehicle >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Vehicle >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Vehicle >::persist_statement[] =
  "INSERT INTO \"Vehicle\" ("
  "\"auto_id\","
  "\"hhold\","
  "\"vehicle\","
  "\"parking\","
  "\"type\","
  "\"subtype\","
  "\"partition\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Vehicle >::find_statement[] =
  "SELECT "
  "\"Vehicle\".\"auto_id\","
  "\"Vehicle\".\"hhold\","
  "\"Vehicle\".\"vehicle\","
  "\"Vehicle\".\"parking\","
  "\"Vehicle\".\"type\","
  "\"Vehicle\".\"subtype\","
  "\"Vehicle\".\"partition\""
  " FROM \"Vehicle\""
  " WHERE \"Vehicle\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Vehicle >::update_statement[] =
  "UPDATE \"Vehicle\" SET "
  "\"hhold\"=?,"
  "\"vehicle\"=?,"
  "\"parking\"=?,"
  "\"type\"=?,"
  "\"subtype\"=?,"
  "\"partition\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Vehicle >::erase_statement[] =
  "DELETE FROM \"Vehicle\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Vehicle >::query_statement[] =
  "SELECT "
  "\"Vehicle\".\"auto_id\","
  "\"Vehicle\".\"hhold\","
  "\"Vehicle\".\"vehicle\","
  "\"Vehicle\".\"parking\","
  "\"Vehicle\".\"type\","
  "\"Vehicle\".\"subtype\","
  "\"Vehicle\".\"partition\""
  " FROM \"Vehicle\""
  " LEFT JOIN \"Parking\" AS \"parking\" ON \"parking\".\"parking\"=\"Vehicle\".\"parking\""
  " LEFT JOIN \"Veh_Type\" AS \"type\" ON \"type\".\"type\"=\"Vehicle\".\"type\""
  " ";

  const char access::object_traits< ::pio::Vehicle >::erase_query_statement[] =
  "DELETE FROM \"Vehicle\""
  " ";

  const char access::object_traits< ::pio::Vehicle >::table_name[] =
  "\"Vehicle\"";

  void access::object_traits< ::pio::Vehicle >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Vehicle >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Vehicle >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Vehicle >::pointer_type
  access::object_traits< ::pio::Vehicle >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Vehicle >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Vehicle >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Vehicle >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Vehicle >::object_type >
  access::object_traits< ::pio::Vehicle >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Vehicle >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Vehicle >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Vehicle\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Vehicle\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"hhold\" INTEGER NOT NULL,\n"
                      "  \"vehicle\" INTEGER NOT NULL,\n"
                      "  \"parking\" INTEGER,\n"
                      "  \"type\" INTEGER,\n"
                      "  \"subtype\" INTEGER NOT NULL,\n"
                      "  \"partition\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"parking_fk\"\n"
                      "    FOREIGN KEY (\"parking\")\n"
                      "    REFERENCES \"Parking\" (\"parking\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"type_fk\"\n"
                      "    FOREIGN KEY (\"type\")\n"
                      "    REFERENCES \"Veh_Type\" (\"type\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Vehicle_ (
    "",
    &access::object_traits< ::pio::Vehicle >::create_schema);

  // Trip
  //

  access::object_traits< ::pio::Trip >::id_type
  access::object_traits< ::pio::Trip >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Trip >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // start
    //
    t[5UL] = false;

    // end
    //
    t[6UL] = false;

    // duration
    //
    t[7UL] = false;

    // origin
    //
    t[8UL] = false;

    // destination
    //
    t[9UL] = false;

    // purpose
    //
    t[10UL] = false;

    // mode
    //
    t[11UL] = false;

    // constraint
    //
    t[12UL] = false;

    // priority
    //
    t[13UL] = false;

    // vehicle
    //
    t[14UL] = false;

    // passengers
    //
    t[15UL] = false;

    // type
    //
    t[16UL] = false;

    // partition
    //
    t[17UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Trip >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // duration
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.duration_value;
    b[n].is_null = &i.duration_null;
    n++;

    // origin
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.origin_value;
    b[n].is_null = &i.origin_null;
    n++;

    // destination
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.destination_value;
    b[n].is_null = &i.destination_null;
    n++;

    // purpose
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.purpose_value;
    b[n].is_null = &i.purpose_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // constraint
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.constraint_value;
    b[n].is_null = &i.constraint_null;
    n++;

    // priority
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.priority_value;
    b[n].is_null = &i.priority_null;
    n++;

    // vehicle
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.vehicle_value;
    b[n].is_null = &i.vehicle_null;
    n++;

    // passengers
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.passengers_value;
    b[n].is_null = &i.passengers_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // partition
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.partition_value;
    b[n].is_null = &i.partition_null;
    n++;
  }

  void access::object_traits< ::pio::Trip >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Trip >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // duration
    //
    {
      double const& v =
        o.duration;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.duration_value,
        is_null,
        v);
      i.duration_null = is_null;
    }

    // origin
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location > const& v =
        o.origin;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.origin_value,
          is_null,
          id);
        i.origin_null = is_null;
      }
      else
        i.origin_null = true;
    }

    // destination
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location > const& v =
        o.destination;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.destination_value,
          is_null,
          id);
        i.destination_null = is_null;
      }
      else
        i.destination_null = true;
    }

    // purpose
    //
    {
      int const& v =
        o.purpose;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.purpose_value,
        is_null,
        v);
      i.purpose_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // constraint
    //
    {
      int const& v =
        o.constraint;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.constraint_value,
        is_null,
        v);
      i.constraint_null = is_null;
    }

    // priority
    //
    {
      int const& v =
        o.priority;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.priority_value,
        is_null,
        v);
      i.priority_null = is_null;
    }

    // vehicle
    //
    {
      int const& v =
        o.vehicle;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.vehicle_value,
        is_null,
        v);
      i.vehicle_null = is_null;
    }

    // passengers
    //
    {
      int const& v =
        o.passengers;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.passengers_value,
        is_null,
        v);
      i.passengers_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // partition
    //
    {
      int const& v =
        o.partition;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.partition_value,
        is_null,
        v);
      i.partition_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Trip >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // duration
    //
    {
      double& v =
        o.duration;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.duration_value,
        i.duration_null);
    }

    // origin
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location >& v =
        o.origin;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      if (i.origin_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.origin_value,
          i.origin_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // destination
    //
    {
      ::std::tr1::shared_ptr< ::pio::Location >& v =
        o.destination;

      typedef object_traits< ::pio::Location > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Location > > ptr_traits;

      if (i.destination_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.destination_value,
          i.destination_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // purpose
    //
    {
      int& v =
        o.purpose;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.purpose_value,
        i.purpose_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // constraint
    //
    {
      int& v =
        o.constraint;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.constraint_value,
        i.constraint_null);
    }

    // priority
    //
    {
      int& v =
        o.priority;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.priority_value,
        i.priority_null);
    }

    // vehicle
    //
    {
      int& v =
        o.vehicle;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.vehicle_value,
        i.vehicle_null);
    }

    // passengers
    //
    {
      int& v =
        o.passengers;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.passengers_value,
        i.passengers_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // partition
    //
    {
      int& v =
        o.partition;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.partition_value,
        i.partition_null);
    }
  }

  void access::object_traits< ::pio::Trip >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Trip >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Trip >::persist_statement[] =
  "INSERT INTO \"Trip\" ("
  "\"auto_id\","
  "\"hhold\","
  "\"person\","
  "\"tour\","
  "\"trip\","
  "\"start\","
  "\"end\","
  "\"duration\","
  "\"origin\","
  "\"destination\","
  "\"purpose\","
  "\"mode\","
  "\"constraint\","
  "\"priority\","
  "\"vehicle\","
  "\"passengers\","
  "\"type\","
  "\"partition\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Trip >::find_statement[] =
  "SELECT "
  "\"Trip\".\"auto_id\","
  "\"Trip\".\"hhold\","
  "\"Trip\".\"person\","
  "\"Trip\".\"tour\","
  "\"Trip\".\"trip\","
  "\"Trip\".\"start\","
  "\"Trip\".\"end\","
  "\"Trip\".\"duration\","
  "\"Trip\".\"origin\","
  "\"Trip\".\"destination\","
  "\"Trip\".\"purpose\","
  "\"Trip\".\"mode\","
  "\"Trip\".\"constraint\","
  "\"Trip\".\"priority\","
  "\"Trip\".\"vehicle\","
  "\"Trip\".\"passengers\","
  "\"Trip\".\"type\","
  "\"Trip\".\"partition\""
  " FROM \"Trip\""
  " WHERE \"Trip\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Trip >::update_statement[] =
  "UPDATE \"Trip\" SET "
  "\"hhold\"=?,"
  "\"person\"=?,"
  "\"tour\"=?,"
  "\"trip\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"duration\"=?,"
  "\"origin\"=?,"
  "\"destination\"=?,"
  "\"purpose\"=?,"
  "\"mode\"=?,"
  "\"constraint\"=?,"
  "\"priority\"=?,"
  "\"vehicle\"=?,"
  "\"passengers\"=?,"
  "\"type\"=?,"
  "\"partition\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Trip >::erase_statement[] =
  "DELETE FROM \"Trip\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Trip >::query_statement[] =
  "SELECT "
  "\"Trip\".\"auto_id\","
  "\"Trip\".\"hhold\","
  "\"Trip\".\"person\","
  "\"Trip\".\"tour\","
  "\"Trip\".\"trip\","
  "\"Trip\".\"start\","
  "\"Trip\".\"end\","
  "\"Trip\".\"duration\","
  "\"Trip\".\"origin\","
  "\"Trip\".\"destination\","
  "\"Trip\".\"purpose\","
  "\"Trip\".\"mode\","
  "\"Trip\".\"constraint\","
  "\"Trip\".\"priority\","
  "\"Trip\".\"vehicle\","
  "\"Trip\".\"passengers\","
  "\"Trip\".\"type\","
  "\"Trip\".\"partition\""
  " FROM \"Trip\""
  " LEFT JOIN \"Location\" AS \"origin\" ON \"origin\".\"location\"=\"Trip\".\"origin\""
  " LEFT JOIN \"Location\" AS \"destination\" ON \"destination\".\"location\"=\"Trip\".\"destination\""
  " ";

  const char access::object_traits< ::pio::Trip >::erase_query_statement[] =
  "DELETE FROM \"Trip\""
  " ";

  const char access::object_traits< ::pio::Trip >::table_name[] =
  "\"Trip\"";

  void access::object_traits< ::pio::Trip >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Trip >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Trip >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Trip >::pointer_type
  access::object_traits< ::pio::Trip >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Trip >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Trip >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Trip >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Trip >::object_type >
  access::object_traits< ::pio::Trip >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Trip >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Trip >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Trip\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Trip\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"hhold\" INTEGER NOT NULL,\n"
                      "  \"person\" INTEGER NOT NULL,\n"
                      "  \"tour\" INTEGER NOT NULL,\n"
                      "  \"trip\" INTEGER NOT NULL,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"duration\" REAL,\n"
                      "  \"origin\" INTEGER,\n"
                      "  \"destination\" INTEGER,\n"
                      "  \"purpose\" INTEGER NOT NULL,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"constraint\" INTEGER NOT NULL,\n"
                      "  \"priority\" INTEGER NOT NULL,\n"
                      "  \"vehicle\" INTEGER NOT NULL,\n"
                      "  \"passengers\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"partition\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"origin_fk\"\n"
                      "    FOREIGN KEY (\"origin\")\n"
                      "    REFERENCES \"Location\" (\"location\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"destination_fk\"\n"
                      "    FOREIGN KEY (\"destination\")\n"
                      "    REFERENCES \"Location\" (\"location\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Trip_ (
    "",
    &access::object_traits< ::pio::Trip >::create_schema);

  // Problem
  //

  access::object_traits< ::pio::Problem >::id_type
  access::object_traits< ::pio::Problem >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.problem_value,
        i.problem_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Problem >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // problem
    //
    t[0UL] = false;

    // time
    //
    t[1UL] = false;

    // link
    //
    t[2UL] = false;

    // dir
    //
    t[3UL] = false;

    // lane
    //
    t[4UL] = false;

    // offset
    //
    t[5UL] = false;

    // route
    //
    t[6UL] = false;

    // survey
    //
    t[7UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Problem >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // problem
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.problem_value;
      b[n].is_null = &i.problem_null;
      n++;
    }

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lane
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lane_value;
    b[n].is_null = &i.lane_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // survey
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.survey_value;
    b[n].is_null = &i.survey_null;
    n++;
  }

  void access::object_traits< ::pio::Problem >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Problem >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // problem
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.problem;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.problem_value,
        is_null,
        v);
      i.problem_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lane
    //
    {
      int const& v =
        o.lane;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lane_value,
        is_null,
        v);
      i.lane_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // survey
    //
    {
      int const& v =
        o.survey;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.survey_value,
        is_null,
        v);
      i.survey_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Problem >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // problem
    //
    {
      int& v =
        o.problem;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.problem_value,
        i.problem_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lane
    //
    {
      int& v =
        o.lane;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lane_value,
        i.lane_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // survey
    //
    {
      int& v =
        o.survey;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.survey_value,
        i.survey_null);
    }
  }

  void access::object_traits< ::pio::Problem >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Problem >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Problem >::persist_statement[] =
  "INSERT INTO \"Problem\" ("
  "\"problem\","
  "\"time\","
  "\"link\","
  "\"dir\","
  "\"lane\","
  "\"offset\","
  "\"route\","
  "\"survey\")"
  " VALUES (?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Problem >::find_statement[] =
  "SELECT "
  "\"Problem\".\"problem\","
  "\"Problem\".\"time\","
  "\"Problem\".\"link\","
  "\"Problem\".\"dir\","
  "\"Problem\".\"lane\","
  "\"Problem\".\"offset\","
  "\"Problem\".\"route\","
  "\"Problem\".\"survey\""
  " FROM \"Problem\""
  " WHERE \"Problem\".\"problem\"=?";

  const char access::object_traits< ::pio::Problem >::update_statement[] =
  "UPDATE \"Problem\" SET "
  "\"time\"=?,"
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"lane\"=?,"
  "\"offset\"=?,"
  "\"route\"=?,"
  "\"survey\"=?"
  " WHERE \"problem\"=?";

  const char access::object_traits< ::pio::Problem >::erase_statement[] =
  "DELETE FROM \"Problem\""
  " WHERE \"problem\"=?";

  const char access::object_traits< ::pio::Problem >::query_statement[] =
  "SELECT "
  "\"Problem\".\"problem\","
  "\"Problem\".\"time\","
  "\"Problem\".\"link\","
  "\"Problem\".\"dir\","
  "\"Problem\".\"lane\","
  "\"Problem\".\"offset\","
  "\"Problem\".\"route\","
  "\"Problem\".\"survey\""
  " FROM \"Problem\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Problem\".\"link\""
  " ";

  const char access::object_traits< ::pio::Problem >::erase_query_statement[] =
  "DELETE FROM \"Problem\""
  " ";

  const char access::object_traits< ::pio::Problem >::table_name[] =
  "\"Problem\"";

  void access::object_traits< ::pio::Problem >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Problem >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.problem);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Problem >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Problem >::pointer_type
  access::object_traits< ::pio::Problem >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Problem >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Problem >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.problem);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Problem >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Problem >::object_type >
  access::object_traits< ::pio::Problem >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Problem >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Problem >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Problem\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Problem\" (\n"
                      "  \"problem\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"time\" REAL,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"lane\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"survey\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Problem_ (
    "",
    &access::object_traits< ::pio::Problem >::create_schema);

  // Plan
  //

  access::object_traits< ::pio::Plan >::id_type
  access::object_traits< ::pio::Plan >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Plan >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // depart
    //
    t[1UL] = false;

    // arrive
    //
    t[2UL] = false;

    // activity
    //
    t[3UL] = false;

    // walk
    //
    t[4UL] = false;

    // drive
    //
    t[5UL] = false;

    // transit
    //
    t[6UL] = false;

    // wait
    //
    t[7UL] = false;

    // other
    //
    t[8UL] = false;

    // length
    //
    t[9UL] = false;

    // cost
    //
    t[10UL] = false;

    // impedance
    //
    t[11UL] = false;

    // leg_mode
    //
    t[12UL] = false;

    // leg_type
    //
    t[13UL] = false;

    // leg_id
    //
    t[14UL] = false;

    // leg_time
    //
    t[15UL] = false;

    // leg_length
    //
    t[16UL] = false;

    // leg_cost
    //
    t[17UL] = false;

    // leg_imp
    //
    t[18UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Plan >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // depart
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.depart_value;
    b[n].is_null = &i.depart_null;
    n++;

    // arrive
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.arrive_value;
    b[n].is_null = &i.arrive_null;
    n++;

    // activity
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.activity_value;
    b[n].is_null = &i.activity_null;
    n++;

    // walk
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.walk_value;
    b[n].is_null = &i.walk_null;
    n++;

    // drive
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.drive_value;
    b[n].is_null = &i.drive_null;
    n++;

    // transit
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.transit_value;
    b[n].is_null = &i.transit_null;
    n++;

    // wait
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.wait_value;
    b[n].is_null = &i.wait_null;
    n++;

    // other
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.other_value;
    b[n].is_null = &i.other_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.cost_value;
    b[n].is_null = &i.cost_null;
    n++;

    // impedance
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.impedance_value;
    b[n].is_null = &i.impedance_null;
    n++;

    // leg_mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.leg_mode_value;
    b[n].is_null = &i.leg_mode_null;
    n++;

    // leg_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.leg_type_value;
    b[n].is_null = &i.leg_type_null;
    n++;

    // leg_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.leg_id_value;
    b[n].is_null = &i.leg_id_null;
    n++;

    // leg_time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.leg_time_value;
    b[n].is_null = &i.leg_time_null;
    n++;

    // leg_length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.leg_length_value;
    b[n].is_null = &i.leg_length_null;
    n++;

    // leg_cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.leg_cost_value;
    b[n].is_null = &i.leg_cost_null;
    n++;

    // leg_imp
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.leg_imp_value;
    b[n].is_null = &i.leg_imp_null;
    n++;
  }

  void access::object_traits< ::pio::Plan >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Plan >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // depart
    //
    {
      double const& v =
        o.depart;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.depart_value,
        is_null,
        v);
      i.depart_null = is_null;
    }

    // arrive
    //
    {
      double const& v =
        o.arrive;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.arrive_value,
        is_null,
        v);
      i.arrive_null = is_null;
    }

    // activity
    //
    {
      double const& v =
        o.activity;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.activity_value,
        is_null,
        v);
      i.activity_null = is_null;
    }

    // walk
    //
    {
      double const& v =
        o.walk;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.walk_value,
        is_null,
        v);
      i.walk_null = is_null;
    }

    // drive
    //
    {
      double const& v =
        o.drive;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.drive_value,
        is_null,
        v);
      i.drive_null = is_null;
    }

    // transit
    //
    {
      double const& v =
        o.transit;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.transit_value,
        is_null,
        v);
      i.transit_null = is_null;
    }

    // wait
    //
    {
      double const& v =
        o.wait;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.wait_value,
        is_null,
        v);
      i.wait_null = is_null;
    }

    // other
    //
    {
      double const& v =
        o.other;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.other_value,
        is_null,
        v);
      i.other_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // cost
    //
    {
      double const& v =
        o.cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.cost_value,
        is_null,
        v);
      i.cost_null = is_null;
    }

    // impedance
    //
    {
      int const& v =
        o.impedance;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.impedance_value,
        is_null,
        v);
      i.impedance_null = is_null;
    }

    // leg_mode
    //
    {
      int const& v =
        o.leg_mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.leg_mode_value,
        is_null,
        v);
      i.leg_mode_null = is_null;
    }

    // leg_type
    //
    {
      int const& v =
        o.leg_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.leg_type_value,
        is_null,
        v);
      i.leg_type_null = is_null;
    }

    // leg_id
    //
    {
      int const& v =
        o.leg_id;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.leg_id_value,
        is_null,
        v);
      i.leg_id_null = is_null;
    }

    // leg_time
    //
    {
      double const& v =
        o.leg_time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.leg_time_value,
        is_null,
        v);
      i.leg_time_null = is_null;
    }

    // leg_length
    //
    {
      double const& v =
        o.leg_length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.leg_length_value,
        is_null,
        v);
      i.leg_length_null = is_null;
    }

    // leg_cost
    //
    {
      double const& v =
        o.leg_cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.leg_cost_value,
        is_null,
        v);
      i.leg_cost_null = is_null;
    }

    // leg_imp
    //
    {
      int const& v =
        o.leg_imp;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.leg_imp_value,
        is_null,
        v);
      i.leg_imp_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Plan >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // depart
    //
    {
      double& v =
        o.depart;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.depart_value,
        i.depart_null);
    }

    // arrive
    //
    {
      double& v =
        o.arrive;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.arrive_value,
        i.arrive_null);
    }

    // activity
    //
    {
      double& v =
        o.activity;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.activity_value,
        i.activity_null);
    }

    // walk
    //
    {
      double& v =
        o.walk;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.walk_value,
        i.walk_null);
    }

    // drive
    //
    {
      double& v =
        o.drive;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.drive_value,
        i.drive_null);
    }

    // transit
    //
    {
      double& v =
        o.transit;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.transit_value,
        i.transit_null);
    }

    // wait
    //
    {
      double& v =
        o.wait;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.wait_value,
        i.wait_null);
    }

    // other
    //
    {
      double& v =
        o.other;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.other_value,
        i.other_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // cost
    //
    {
      double& v =
        o.cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.cost_value,
        i.cost_null);
    }

    // impedance
    //
    {
      int& v =
        o.impedance;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.impedance_value,
        i.impedance_null);
    }

    // leg_mode
    //
    {
      int& v =
        o.leg_mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.leg_mode_value,
        i.leg_mode_null);
    }

    // leg_type
    //
    {
      int& v =
        o.leg_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.leg_type_value,
        i.leg_type_null);
    }

    // leg_id
    //
    {
      int& v =
        o.leg_id;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.leg_id_value,
        i.leg_id_null);
    }

    // leg_time
    //
    {
      double& v =
        o.leg_time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.leg_time_value,
        i.leg_time_null);
    }

    // leg_length
    //
    {
      double& v =
        o.leg_length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.leg_length_value,
        i.leg_length_null);
    }

    // leg_cost
    //
    {
      double& v =
        o.leg_cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.leg_cost_value,
        i.leg_cost_null);
    }

    // leg_imp
    //
    {
      int& v =
        o.leg_imp;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.leg_imp_value,
        i.leg_imp_null);
    }
  }

  void access::object_traits< ::pio::Plan >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Plan >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Plan >::persist_statement[] =
  "INSERT INTO \"Plan\" ("
  "\"auto_id\","
  "\"depart\","
  "\"arrive\","
  "\"activity\","
  "\"walk\","
  "\"drive\","
  "\"transit\","
  "\"wait\","
  "\"other\","
  "\"length\","
  "\"cost\","
  "\"impedance\","
  "\"leg_mode\","
  "\"leg_type\","
  "\"leg_id\","
  "\"leg_time\","
  "\"leg_length\","
  "\"leg_cost\","
  "\"leg_imp\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Plan >::find_statement[] =
  "SELECT "
  "\"Plan\".\"auto_id\","
  "\"Plan\".\"depart\","
  "\"Plan\".\"arrive\","
  "\"Plan\".\"activity\","
  "\"Plan\".\"walk\","
  "\"Plan\".\"drive\","
  "\"Plan\".\"transit\","
  "\"Plan\".\"wait\","
  "\"Plan\".\"other\","
  "\"Plan\".\"length\","
  "\"Plan\".\"cost\","
  "\"Plan\".\"impedance\","
  "\"Plan\".\"leg_mode\","
  "\"Plan\".\"leg_type\","
  "\"Plan\".\"leg_id\","
  "\"Plan\".\"leg_time\","
  "\"Plan\".\"leg_length\","
  "\"Plan\".\"leg_cost\","
  "\"Plan\".\"leg_imp\""
  " FROM \"Plan\""
  " WHERE \"Plan\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Plan >::update_statement[] =
  "UPDATE \"Plan\" SET "
  "\"depart\"=?,"
  "\"arrive\"=?,"
  "\"activity\"=?,"
  "\"walk\"=?,"
  "\"drive\"=?,"
  "\"transit\"=?,"
  "\"wait\"=?,"
  "\"other\"=?,"
  "\"length\"=?,"
  "\"cost\"=?,"
  "\"impedance\"=?,"
  "\"leg_mode\"=?,"
  "\"leg_type\"=?,"
  "\"leg_id\"=?,"
  "\"leg_time\"=?,"
  "\"leg_length\"=?,"
  "\"leg_cost\"=?,"
  "\"leg_imp\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Plan >::erase_statement[] =
  "DELETE FROM \"Plan\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Plan >::query_statement[] =
  "SELECT "
  "\"Plan\".\"auto_id\","
  "\"Plan\".\"depart\","
  "\"Plan\".\"arrive\","
  "\"Plan\".\"activity\","
  "\"Plan\".\"walk\","
  "\"Plan\".\"drive\","
  "\"Plan\".\"transit\","
  "\"Plan\".\"wait\","
  "\"Plan\".\"other\","
  "\"Plan\".\"length\","
  "\"Plan\".\"cost\","
  "\"Plan\".\"impedance\","
  "\"Plan\".\"leg_mode\","
  "\"Plan\".\"leg_type\","
  "\"Plan\".\"leg_id\","
  "\"Plan\".\"leg_time\","
  "\"Plan\".\"leg_length\","
  "\"Plan\".\"leg_cost\","
  "\"Plan\".\"leg_imp\""
  " FROM \"Plan\""
  " ";

  const char access::object_traits< ::pio::Plan >::erase_query_statement[] =
  "DELETE FROM \"Plan\""
  " ";

  const char access::object_traits< ::pio::Plan >::table_name[] =
  "\"Plan\"";

  void access::object_traits< ::pio::Plan >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Plan >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Plan >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Plan >::pointer_type
  access::object_traits< ::pio::Plan >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Plan >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Plan >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Plan >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Plan >::object_type >
  access::object_traits< ::pio::Plan >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Plan >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Plan >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Plan\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Plan\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"depart\" REAL,\n"
                      "  \"arrive\" REAL,\n"
                      "  \"activity\" REAL,\n"
                      "  \"walk\" REAL,\n"
                      "  \"drive\" REAL,\n"
                      "  \"transit\" REAL,\n"
                      "  \"wait\" REAL,\n"
                      "  \"other\" REAL,\n"
                      "  \"length\" REAL,\n"
                      "  \"cost\" REAL,\n"
                      "  \"impedance\" INTEGER NOT NULL,\n"
                      "  \"leg_mode\" INTEGER NOT NULL,\n"
                      "  \"leg_type\" INTEGER NOT NULL,\n"
                      "  \"leg_id\" INTEGER NOT NULL,\n"
                      "  \"leg_time\" REAL,\n"
                      "  \"leg_length\" REAL,\n"
                      "  \"leg_cost\" REAL,\n"
                      "  \"leg_imp\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Plan_ (
    "",
    &access::object_traits< ::pio::Plan >::create_schema);

  // Skim
  //

  access::object_traits< ::pio::Skim >::id_type
  access::object_traits< ::pio::Skim >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Skim >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // time
    //
    t[1UL] = false;

    // walk
    //
    t[2UL] = false;

    // drive
    //
    t[3UL] = false;

    // transit
    //
    t[4UL] = false;

    // wait
    //
    t[5UL] = false;

    // other
    //
    t[6UL] = false;

    // length
    //
    t[7UL] = false;

    // cost
    //
    t[8UL] = false;

    // impedance
    //
    t[9UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Skim >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // walk
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.walk_value;
    b[n].is_null = &i.walk_null;
    n++;

    // drive
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.drive_value;
    b[n].is_null = &i.drive_null;
    n++;

    // transit
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.transit_value;
    b[n].is_null = &i.transit_null;
    n++;

    // wait
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.wait_value;
    b[n].is_null = &i.wait_null;
    n++;

    // other
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.other_value;
    b[n].is_null = &i.other_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.cost_value;
    b[n].is_null = &i.cost_null;
    n++;

    // impedance
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.impedance_value;
    b[n].is_null = &i.impedance_null;
    n++;
  }

  void access::object_traits< ::pio::Skim >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Skim >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // walk
    //
    {
      double const& v =
        o.walk;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.walk_value,
        is_null,
        v);
      i.walk_null = is_null;
    }

    // drive
    //
    {
      double const& v =
        o.drive;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.drive_value,
        is_null,
        v);
      i.drive_null = is_null;
    }

    // transit
    //
    {
      double const& v =
        o.transit;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.transit_value,
        is_null,
        v);
      i.transit_null = is_null;
    }

    // wait
    //
    {
      double const& v =
        o.wait;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.wait_value,
        is_null,
        v);
      i.wait_null = is_null;
    }

    // other
    //
    {
      double const& v =
        o.other;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.other_value,
        is_null,
        v);
      i.other_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // cost
    //
    {
      double const& v =
        o.cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.cost_value,
        is_null,
        v);
      i.cost_null = is_null;
    }

    // impedance
    //
    {
      int const& v =
        o.impedance;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.impedance_value,
        is_null,
        v);
      i.impedance_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Skim >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // walk
    //
    {
      double& v =
        o.walk;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.walk_value,
        i.walk_null);
    }

    // drive
    //
    {
      double& v =
        o.drive;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.drive_value,
        i.drive_null);
    }

    // transit
    //
    {
      double& v =
        o.transit;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.transit_value,
        i.transit_null);
    }

    // wait
    //
    {
      double& v =
        o.wait;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.wait_value,
        i.wait_null);
    }

    // other
    //
    {
      double& v =
        o.other;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.other_value,
        i.other_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // cost
    //
    {
      double& v =
        o.cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.cost_value,
        i.cost_null);
    }

    // impedance
    //
    {
      int& v =
        o.impedance;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.impedance_value,
        i.impedance_null);
    }
  }

  void access::object_traits< ::pio::Skim >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Skim >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Skim >::persist_statement[] =
  "INSERT INTO \"Skim\" ("
  "\"auto_id\","
  "\"time\","
  "\"walk\","
  "\"drive\","
  "\"transit\","
  "\"wait\","
  "\"other\","
  "\"length\","
  "\"cost\","
  "\"impedance\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Skim >::find_statement[] =
  "SELECT "
  "\"Skim\".\"auto_id\","
  "\"Skim\".\"time\","
  "\"Skim\".\"walk\","
  "\"Skim\".\"drive\","
  "\"Skim\".\"transit\","
  "\"Skim\".\"wait\","
  "\"Skim\".\"other\","
  "\"Skim\".\"length\","
  "\"Skim\".\"cost\","
  "\"Skim\".\"impedance\""
  " FROM \"Skim\""
  " WHERE \"Skim\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Skim >::update_statement[] =
  "UPDATE \"Skim\" SET "
  "\"time\"=?,"
  "\"walk\"=?,"
  "\"drive\"=?,"
  "\"transit\"=?,"
  "\"wait\"=?,"
  "\"other\"=?,"
  "\"length\"=?,"
  "\"cost\"=?,"
  "\"impedance\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Skim >::erase_statement[] =
  "DELETE FROM \"Skim\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Skim >::query_statement[] =
  "SELECT "
  "\"Skim\".\"auto_id\","
  "\"Skim\".\"time\","
  "\"Skim\".\"walk\","
  "\"Skim\".\"drive\","
  "\"Skim\".\"transit\","
  "\"Skim\".\"wait\","
  "\"Skim\".\"other\","
  "\"Skim\".\"length\","
  "\"Skim\".\"cost\","
  "\"Skim\".\"impedance\""
  " FROM \"Skim\""
  " ";

  const char access::object_traits< ::pio::Skim >::erase_query_statement[] =
  "DELETE FROM \"Skim\""
  " ";

  const char access::object_traits< ::pio::Skim >::table_name[] =
  "\"Skim\"";

  void access::object_traits< ::pio::Skim >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Skim >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Skim >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Skim >::pointer_type
  access::object_traits< ::pio::Skim >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Skim >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Skim >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Skim >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Skim >::object_type >
  access::object_traits< ::pio::Skim >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Skim >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Skim >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Skim\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Skim\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"time\" REAL,\n"
                      "  \"walk\" REAL,\n"
                      "  \"drive\" REAL,\n"
                      "  \"transit\" REAL,\n"
                      "  \"wait\" REAL,\n"
                      "  \"other\" REAL,\n"
                      "  \"length\" REAL,\n"
                      "  \"cost\" REAL,\n"
                      "  \"impedance\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Skim_ (
    "",
    &access::object_traits< ::pio::Skim >::create_schema);

  // Event
  //

  access::object_traits< ::pio::Event >::id_type
  access::object_traits< ::pio::Event >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Event >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // mode
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // schedule
    //
    t[7UL] = false;

    // actual
    //
    t[8UL] = false;

    // link
    //
    t[9UL] = false;

    // dir
    //
    t[10UL] = false;

    // lane
    //
    t[11UL] = false;

    // offset
    //
    t[12UL] = false;

    // route
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Event >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // schedule
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.schedule_value;
    b[n].is_null = &i.schedule_null;
    n++;

    // actual
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.actual_value;
    b[n].is_null = &i.actual_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lane
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lane_value;
    b[n].is_null = &i.lane_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;
  }

  void access::object_traits< ::pio::Event >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Event >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // schedule
    //
    {
      double const& v =
        o.schedule;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.schedule_value,
        is_null,
        v);
      i.schedule_null = is_null;
    }

    // actual
    //
    {
      double const& v =
        o.actual;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.actual_value,
        is_null,
        v);
      i.actual_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lane
    //
    {
      int const& v =
        o.lane;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lane_value,
        is_null,
        v);
      i.lane_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Event >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // schedule
    //
    {
      double& v =
        o.schedule;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.schedule_value,
        i.schedule_null);
    }

    // actual
    //
    {
      double& v =
        o.actual;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.actual_value,
        i.actual_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lane
    //
    {
      int& v =
        o.lane;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lane_value,
        i.lane_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }
  }

  void access::object_traits< ::pio::Event >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Event >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Event >::persist_statement[] =
  "INSERT INTO \"Event\" ("
  "\"auto_id\","
  "\"hhold\","
  "\"person\","
  "\"tour\","
  "\"trip\","
  "\"mode\","
  "\"type\","
  "\"schedule\","
  "\"actual\","
  "\"link\","
  "\"dir\","
  "\"lane\","
  "\"offset\","
  "\"route\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Event >::find_statement[] =
  "SELECT "
  "\"Event\".\"auto_id\","
  "\"Event\".\"hhold\","
  "\"Event\".\"person\","
  "\"Event\".\"tour\","
  "\"Event\".\"trip\","
  "\"Event\".\"mode\","
  "\"Event\".\"type\","
  "\"Event\".\"schedule\","
  "\"Event\".\"actual\","
  "\"Event\".\"link\","
  "\"Event\".\"dir\","
  "\"Event\".\"lane\","
  "\"Event\".\"offset\","
  "\"Event\".\"route\""
  " FROM \"Event\""
  " WHERE \"Event\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Event >::update_statement[] =
  "UPDATE \"Event\" SET "
  "\"hhold\"=?,"
  "\"person\"=?,"
  "\"tour\"=?,"
  "\"trip\"=?,"
  "\"mode\"=?,"
  "\"type\"=?,"
  "\"schedule\"=?,"
  "\"actual\"=?,"
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"lane\"=?,"
  "\"offset\"=?,"
  "\"route\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Event >::erase_statement[] =
  "DELETE FROM \"Event\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Event >::query_statement[] =
  "SELECT "
  "\"Event\".\"auto_id\","
  "\"Event\".\"hhold\","
  "\"Event\".\"person\","
  "\"Event\".\"tour\","
  "\"Event\".\"trip\","
  "\"Event\".\"mode\","
  "\"Event\".\"type\","
  "\"Event\".\"schedule\","
  "\"Event\".\"actual\","
  "\"Event\".\"link\","
  "\"Event\".\"dir\","
  "\"Event\".\"lane\","
  "\"Event\".\"offset\","
  "\"Event\".\"route\""
  " FROM \"Event\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Event\".\"link\""
  " ";

  const char access::object_traits< ::pio::Event >::erase_query_statement[] =
  "DELETE FROM \"Event\""
  " ";

  const char access::object_traits< ::pio::Event >::table_name[] =
  "\"Event\"";

  void access::object_traits< ::pio::Event >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Event >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Event >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Event >::pointer_type
  access::object_traits< ::pio::Event >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Event >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Event >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Event >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Event >::object_type >
  access::object_traits< ::pio::Event >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Event >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Event >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Event\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Event\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"hhold\" INTEGER NOT NULL,\n"
                      "  \"person\" INTEGER NOT NULL,\n"
                      "  \"tour\" INTEGER NOT NULL,\n"
                      "  \"trip\" INTEGER NOT NULL,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"schedule\" REAL,\n"
                      "  \"actual\" REAL,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"lane\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Event_ (
    "",
    &access::object_traits< ::pio::Event >::create_schema);

  // Traveler
  //

  access::object_traits< ::pio::Traveler >::id_type
  access::object_traits< ::pio::Traveler >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits< ::pio::Traveler >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // hhold
    //
    t[1UL] = false;

    // person
    //
    t[2UL] = false;

    // tour
    //
    t[3UL] = false;

    // trip
    //
    t[4UL] = false;

    // mode
    //
    t[5UL] = false;

    // time
    //
    t[6UL] = false;

    // distance
    //
    t[7UL] = false;

    // speed
    //
    t[8UL] = false;

    // link
    //
    t[9UL] = false;

    // dir
    //
    t[10UL] = false;

    // lane
    //
    t[11UL] = false;

    // offset
    //
    t[12UL] = false;

    // route
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits< ::pio::Traveler >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // hhold
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hhold_value;
    b[n].is_null = &i.hhold_null;
    n++;

    // person
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.person_value;
    b[n].is_null = &i.person_null;
    n++;

    // tour
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tour_value;
    b[n].is_null = &i.tour_null;
    n++;

    // trip
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.trip_value;
    b[n].is_null = &i.trip_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // distance
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.distance_value;
    b[n].is_null = &i.distance_null;
    n++;

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lane
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lane_value;
    b[n].is_null = &i.lane_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;
  }

  void access::object_traits< ::pio::Traveler >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::pio::Traveler >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // hhold
    //
    {
      int const& v =
        o.hhold;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hhold_value,
        is_null,
        v);
      i.hhold_null = is_null;
    }

    // person
    //
    {
      int const& v =
        o.person;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.person_value,
        is_null,
        v);
      i.person_null = is_null;
    }

    // tour
    //
    {
      int const& v =
        o.tour;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.tour_value,
        is_null,
        v);
      i.tour_null = is_null;
    }

    // trip
    //
    {
      int const& v =
        o.trip;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.trip_value,
        is_null,
        v);
      i.trip_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // distance
    //
    {
      double const& v =
        o.distance;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.distance_value,
        is_null,
        v);
      i.distance_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link > const& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lane
    //
    {
      int const& v =
        o.lane;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lane_value,
        is_null,
        v);
      i.lane_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::pio::Traveler >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // hhold
    //
    {
      int& v =
        o.hhold;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hhold_value,
        i.hhold_null);
    }

    // person
    //
    {
      int& v =
        o.person;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.person_value,
        i.person_null);
    }

    // tour
    //
    {
      int& v =
        o.tour;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.tour_value,
        i.tour_null);
    }

    // trip
    //
    {
      int& v =
        o.trip;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.trip_value,
        i.trip_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // distance
    //
    {
      double& v =
        o.distance;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.distance_value,
        i.distance_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::pio::Link >& v =
        o.link;

      typedef object_traits< ::pio::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::pio::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lane
    //
    {
      int& v =
        o.lane;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lane_value,
        i.lane_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }
  }

  void access::object_traits< ::pio::Traveler >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::pio::Traveler >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::pio::Traveler >::persist_statement[] =
  "INSERT INTO \"Traveler\" ("
  "\"auto_id\","
  "\"hhold\","
  "\"person\","
  "\"tour\","
  "\"trip\","
  "\"mode\","
  "\"time\","
  "\"distance\","
  "\"speed\","
  "\"link\","
  "\"dir\","
  "\"lane\","
  "\"offset\","
  "\"route\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::pio::Traveler >::find_statement[] =
  "SELECT "
  "\"Traveler\".\"auto_id\","
  "\"Traveler\".\"hhold\","
  "\"Traveler\".\"person\","
  "\"Traveler\".\"tour\","
  "\"Traveler\".\"trip\","
  "\"Traveler\".\"mode\","
  "\"Traveler\".\"time\","
  "\"Traveler\".\"distance\","
  "\"Traveler\".\"speed\","
  "\"Traveler\".\"link\","
  "\"Traveler\".\"dir\","
  "\"Traveler\".\"lane\","
  "\"Traveler\".\"offset\","
  "\"Traveler\".\"route\""
  " FROM \"Traveler\""
  " WHERE \"Traveler\".\"auto_id\"=?";

  const char access::object_traits< ::pio::Traveler >::update_statement[] =
  "UPDATE \"Traveler\" SET "
  "\"hhold\"=?,"
  "\"person\"=?,"
  "\"tour\"=?,"
  "\"trip\"=?,"
  "\"mode\"=?,"
  "\"time\"=?,"
  "\"distance\"=?,"
  "\"speed\"=?,"
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"lane\"=?,"
  "\"offset\"=?,"
  "\"route\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Traveler >::erase_statement[] =
  "DELETE FROM \"Traveler\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits< ::pio::Traveler >::query_statement[] =
  "SELECT "
  "\"Traveler\".\"auto_id\","
  "\"Traveler\".\"hhold\","
  "\"Traveler\".\"person\","
  "\"Traveler\".\"tour\","
  "\"Traveler\".\"trip\","
  "\"Traveler\".\"mode\","
  "\"Traveler\".\"time\","
  "\"Traveler\".\"distance\","
  "\"Traveler\".\"speed\","
  "\"Traveler\".\"link\","
  "\"Traveler\".\"dir\","
  "\"Traveler\".\"lane\","
  "\"Traveler\".\"offset\","
  "\"Traveler\".\"route\""
  " FROM \"Traveler\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Traveler\".\"link\""
  " ";

  const char access::object_traits< ::pio::Traveler >::erase_query_statement[] =
  "DELETE FROM \"Traveler\""
  " ";

  const char access::object_traits< ::pio::Traveler >::table_name[] =
  "\"Traveler\"";

  void access::object_traits< ::pio::Traveler >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits< ::pio::Traveler >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::pio::Traveler >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::pio::Traveler >::pointer_type
  access::object_traits< ::pio::Traveler >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::pio::Traveler >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::pio::Traveler >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::pio::Traveler >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::pio::Traveler >::object_type >
  access::object_traits< ::pio::Traveler >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::pio::Traveler >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::pio::Traveler >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Traveler\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Traveler\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"hhold\" INTEGER NOT NULL,\n"
                      "  \"person\" INTEGER NOT NULL,\n"
                      "  \"tour\" INTEGER NOT NULL,\n"
                      "  \"trip\" INTEGER NOT NULL,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"time\" REAL,\n"
                      "  \"distance\" REAL,\n"
                      "  \"speed\" REAL,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"lane\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_pio_Traveler_ (
    "",
    &access::object_traits< ::pio::Traveler >::create_schema);
}

#include <odb/post.hxx>
