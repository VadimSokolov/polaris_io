// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include "Supply-odb.hxx"

#include <cassert>
#include <cstring>  // std::memcpy

#include <odb/schema-catalog-impl.hxx>

#include <odb/sqlite/traits.hxx>
#include <odb/sqlite/database.hxx>
#include <odb/sqlite/transaction.hxx>
#include <odb/sqlite/connection.hxx>
#include <odb/sqlite/statement.hxx>
#include <odb/sqlite/statement-cache.hxx>
#include <odb/sqlite/simple-object-statements.hxx>
#include <odb/sqlite/container-statements.hxx>
#include <odb/sqlite/exceptions.hxx>
#include <odb/sqlite/simple-object-result.hxx>

namespace odb
{
  // timing_phase
  //

  bool access::composite_value_traits< ::polaris::io::timing_phase, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // phase
    //
    t[0UL] = false;

    // barrier
    //
    t[1UL] = false;

    // ring
    //
    t[2UL] = false;

    // position
    //
    t[3UL] = false;

    // minimum
    //
    t[4UL] = false;

    // maximum
    //
    t[5UL] = false;

    // extend
    //
    t[6UL] = false;

    // yellow
    //
    t[7UL] = false;

    // red
    //
    t[8UL] = false;

    return grew;
  }

  void access::composite_value_traits< ::polaris::io::timing_phase, id_sqlite >::
  bind (sqlite::bind* b, image_type& i, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // phase
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phase_value;
    b[n].is_null = &i.phase_null;
    n++;

    // barrier
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.barrier_value;
    b[n].is_null = &i.barrier_null;
    n++;

    // ring
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.ring_value;
    b[n].is_null = &i.ring_null;
    n++;

    // position
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.position_value;
    b[n].is_null = &i.position_null;
    n++;

    // minimum
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.minimum_value;
    b[n].is_null = &i.minimum_null;
    n++;

    // maximum
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.maximum_value;
    b[n].is_null = &i.maximum_null;
    n++;

    // extend
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.extend_value;
    b[n].is_null = &i.extend_null;
    n++;

    // yellow
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.yellow_value;
    b[n].is_null = &i.yellow_null;
    n++;

    // red
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.red_value;
    b[n].is_null = &i.red_null;
    n++;
  }

  bool access::composite_value_traits< ::polaris::io::timing_phase, id_sqlite >::
  init (image_type& i, const value_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // phase
    //
    {
      int const& v =
        o.phase;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phase_value,
        is_null,
        v);
      i.phase_null = is_null;
    }

    // barrier
    //
    {
      int const& v =
        o.barrier;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.barrier_value,
        is_null,
        v);
      i.barrier_null = is_null;
    }

    // ring
    //
    {
      int const& v =
        o.ring;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.ring_value,
        is_null,
        v);
      i.ring_null = is_null;
    }

    // position
    //
    {
      int const& v =
        o.position;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.position_value,
        is_null,
        v);
      i.position_null = is_null;
    }

    // minimum
    //
    {
      int const& v =
        o.minimum;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.minimum_value,
        is_null,
        v);
      i.minimum_null = is_null;
    }

    // maximum
    //
    {
      int const& v =
        o.maximum;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.maximum_value,
        is_null,
        v);
      i.maximum_null = is_null;
    }

    // extend
    //
    {
      int const& v =
        o.extend;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.extend_value,
        is_null,
        v);
      i.extend_null = is_null;
    }

    // yellow
    //
    {
      int const& v =
        o.yellow;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.yellow_value,
        is_null,
        v);
      i.yellow_null = is_null;
    }

    // red
    //
    {
      int const& v =
        o.red;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.red_value,
        is_null,
        v);
      i.red_null = is_null;
    }

    return grew;
  }

  void access::composite_value_traits< ::polaris::io::timing_phase, id_sqlite >::
  init (value_type& o, const image_type&  i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // phase
    //
    {
      int& v =
        o.phase;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phase_value,
        i.phase_null);
    }

    // barrier
    //
    {
      int& v =
        o.barrier;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.barrier_value,
        i.barrier_null);
    }

    // ring
    //
    {
      int& v =
        o.ring;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.ring_value,
        i.ring_null);
    }

    // position
    //
    {
      int& v =
        o.position;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.position_value,
        i.position_null);
    }

    // minimum
    //
    {
      int& v =
        o.minimum;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.minimum_value,
        i.minimum_null);
    }

    // maximum
    //
    {
      int& v =
        o.maximum;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.maximum_value,
        i.maximum_null);
    }

    // extend
    //
    {
      int& v =
        o.extend;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.extend_value,
        i.extend_null);
    }

    // yellow
    //
    {
      int& v =
        o.yellow;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.yellow_value,
        i.yellow_null);
    }

    // red
    //
    {
      int& v =
        o.red;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.red_value,
        i.red_null);
    }
  }

  // shape_geometry
  //

  bool access::composite_value_traits< ::polaris::io::shape_geometry, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // x
    //
    t[0UL] = false;

    // y
    //
    t[1UL] = false;

    // z
    //
    t[2UL] = false;

    return grew;
  }

  void access::composite_value_traits< ::polaris::io::shape_geometry, id_sqlite >::
  bind (sqlite::bind* b, image_type& i, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;
  }

  bool access::composite_value_traits< ::polaris::io::shape_geometry, id_sqlite >::
  init (image_type& i, const value_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    return grew;
  }

  void access::composite_value_traits< ::polaris::io::shape_geometry, id_sqlite >::
  init (value_type& o, const image_type&  i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }
  }

  // signal_time
  //

  bool access::composite_value_traits< ::polaris::io::signal_time, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // start
    //
    t[0UL] = false;

    // end
    //
    t[1UL] = false;

    // timing
    //
    t[2UL] = false;

    // phasing
    //
    t[3UL] = false;

    return grew;
  }

  void access::composite_value_traits< ::polaris::io::signal_time, id_sqlite >::
  bind (sqlite::bind* b, image_type& i, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // timing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timing_value;
    b[n].is_null = &i.timing_null;
    n++;

    // phasing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phasing_value;
    b[n].is_null = &i.phasing_null;
    n++;
  }

  bool access::composite_value_traits< ::polaris::io::signal_time, id_sqlite >::
  init (image_type& i, const value_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // timing
    //
    {
      int const& v =
        o.timing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.timing_value,
        is_null,
        v);
      i.timing_null = is_null;
    }

    // phasing
    //
    {
      int const& v =
        o.phasing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phasing_value,
        is_null,
        v);
      i.phasing_null = is_null;
    }

    return grew;
  }

  void access::composite_value_traits< ::polaris::io::signal_time, id_sqlite >::
  init (value_type& o, const image_type&  i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // timing
    //
    {
      int& v =
        o.timing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.timing_value,
        i.timing_null);
    }

    // phasing
    //
    {
      int& v =
        o.phasing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phasing_value,
        i.phasing_null);
    }
  }

  // phase_movement
  //

  bool access::composite_value_traits< ::polaris::io::phase_movement, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // movement
    //
    if (t[0UL])
    {
      i.movement_value.capacity (i.movement_size);
      grew = true;
    }

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // to_link
    //
    t[3UL] = false;

    // protect
    //
    if (t[4UL])
    {
      i.protect_value.capacity (i.protect_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::polaris::io::phase_movement, id_sqlite >::
  bind (sqlite::bind* b, image_type& i, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // movement
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.movement_value.data ();
    b[n].size = &i.movement_size;
    b[n].capacity = i.movement_value.capacity ();
    b[n].is_null = &i.movement_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // protect
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.protect_value.data ();
    b[n].size = &i.protect_size;
    b[n].capacity = i.protect_value.capacity ();
    b[n].is_null = &i.protect_null;
    n++;
  }

  bool access::composite_value_traits< ::polaris::io::phase_movement, id_sqlite >::
  init (image_type& i, const value_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // movement
    //
    {
      ::std::string const& v =
        o.movement;

      bool is_null (false);
      std::size_t cap (i.movement_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.movement_value,
        i.movement_size,
        is_null,
        v);
      i.movement_null = is_null;
      grew = grew || (cap != i.movement_value.capacity ());
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.to_link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // protect
    //
    {
      ::std::string const& v =
        o.protect;

      bool is_null (false);
      std::size_t cap (i.protect_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.protect_value,
        i.protect_size,
        is_null,
        v);
      i.protect_null = is_null;
      grew = grew || (cap != i.protect_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::polaris::io::phase_movement, id_sqlite >::
  init (value_type& o, const image_type&  i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // movement
    //
    {
      ::std::string& v =
        o.movement;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.movement_value,
        i.movement_size,
        i.movement_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.to_link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // protect
    //
    {
      ::std::string& v =
        o.protect;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.protect_value,
        i.protect_size,
        i.protect_null);
    }
  }

  // MetaData
  //

  access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        id,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      i.key_value.capacity (i.key_size);
      grew = true;
    }

    // value
    //
    if (t[1UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // key
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::image_traits<
        ::std::string,
        sqlite::id_text>::bind_value;
      b[n].buffer = i.key_value.data ();
      b[n].size = &i.key_size;
      b[n].capacity = i.key_value.capacity ();
      b[n].is_null = &i.key_null;
      n++;
    }

    // value
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.value_value.data ();
    b[n].size = &i.value_size;
    b[n].capacity = i.value_value.capacity ();
    b[n].is_null = &i.value_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.id_value.data ();
    b[n].size = &i.id_size;
    b[n].capacity = i.id_value.capacity ();
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // key
    //
    if (sk == statement_insert)
    {
      ::std::string const& v =
        o.key;

      bool is_null (false);
      std::size_t cap (i.key_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.key_value,
        i.key_size,
        is_null,
        v);
      i.key_null = is_null;
      grew = grew || (cap != i.key_value.capacity ());
    }

    // value
    //
    {
      ::std::string const& v =
        o.value;

      bool is_null (false);
      std::size_t cap (i.value_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.value_value,
        i.value_size,
        is_null,
        v);
      i.value_null = is_null;
      grew = grew || (cap != i.value_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      ::std::string& v =
        o.key;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      ::std::string& v =
        o.value;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    bool grew (false);
    {
      bool is_null (false);
      std::size_t cap (i.id_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.id_value,
        i.id_size,
        is_null,
        id);
      i.id_null = is_null;
      grew = grew || (cap != i.id_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  struct access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::persist_statement[] =
  "INSERT INTO \"MetaData\" ("
  "\"key\","
  "\"value\")"
  " VALUES (?,?)";

  const char access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::find_statement[] =
  "SELECT "
  "\"MetaData\".\"key\","
  "\"MetaData\".\"value\""
  " FROM \"MetaData\""
  " WHERE \"MetaData\".\"key\"=?";

  const char access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::update_statement[] =
  "UPDATE \"MetaData\" SET "
  "\"value\"=?"
  " WHERE \"key\"=?";

  const char access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::erase_statement[] =
  "DELETE FROM \"MetaData\""
  " WHERE \"key\"=?";

  const char access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::query_statement[] =
  "SELECT "
  "\"MetaData\".\"key\","
  "\"MetaData\".\"value\""
  " FROM \"MetaData\""
  " ";

  const char access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"MetaData\""
  " ";

  const char access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::table_name[] =
  "\"MetaData\"";

  void access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.key);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.key);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"MetaData\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"MetaData\" (\n"
                      "  \"key\" TEXT NOT NULL PRIMARY KEY,\n"
                      "  \"value\" TEXT NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_MetaData_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::MetaData, id_sqlite >::create_schema);

  // Node
  //

  access::object_traits_impl< ::polaris::io::Node, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.node_value,
        i.node_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // node
    //
    t[0UL] = false;

    // x
    //
    t[1UL] = false;

    // y
    //
    t[2UL] = false;

    // z
    //
    t[3UL] = false;

    // subarea
    //
    t[4UL] = false;

    // part
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // node
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.node_value;
      b[n].is_null = &i.node_null;
      n++;
    }

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;

    // subarea
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subarea_value;
    b[n].is_null = &i.subarea_null;
    n++;

    // part
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.part_value;
    b[n].is_null = &i.part_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // node
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.node;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.node_value,
        is_null,
        v);
      i.node_null = is_null;
    }

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    // subarea
    //
    {
      int const& v =
        o.subarea;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subarea_value,
        is_null,
        v);
      i.subarea_null = is_null;
    }

    // part
    //
    {
      int const& v =
        o.part;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.part_value,
        is_null,
        v);
      i.part_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // node
    //
    {
      int& v =
        o.node;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.node_value,
        i.node_null);
    }

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }

    // subarea
    //
    {
      int& v =
        o.subarea;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subarea_value,
        i.subarea_null);
    }

    // part
    //
    {
      int& v =
        o.part;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.part_value,
        i.part_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Node, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Node, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Node\" ("
  "\"node\","
  "\"x\","
  "\"y\","
  "\"z\","
  "\"subarea\","
  "\"part\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Node, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Node\".\"node\","
  "\"Node\".\"x\","
  "\"Node\".\"y\","
  "\"Node\".\"z\","
  "\"Node\".\"subarea\","
  "\"Node\".\"part\""
  " FROM \"Node\""
  " WHERE \"Node\".\"node\"=?";

  const char access::object_traits_impl< ::polaris::io::Node, id_sqlite >::update_statement[] =
  "UPDATE \"Node\" SET "
  "\"x\"=?,"
  "\"y\"=?,"
  "\"z\"=?,"
  "\"subarea\"=?,"
  "\"part\"=?"
  " WHERE \"node\"=?";

  const char access::object_traits_impl< ::polaris::io::Node, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Node\""
  " WHERE \"node\"=?";

  const char access::object_traits_impl< ::polaris::io::Node, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Node\".\"node\","
  "\"Node\".\"x\","
  "\"Node\".\"y\","
  "\"Node\".\"z\","
  "\"Node\".\"subarea\","
  "\"Node\".\"part\""
  " FROM \"Node\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Node, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Node\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Node, id_sqlite >::table_name[] =
  "\"Node\"";

  void access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.node);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Node, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.node);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Node, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Node, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Node\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Node\" (\n"
                      "  \"node\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"x\" REAL,\n"
                      "  \"y\" REAL,\n"
                      "  \"z\" REAL,\n"
                      "  \"subarea\" INTEGER NOT NULL,\n"
                      "  \"part\" INTEGER NOT NULL)");
          db.execute ("CREATE INDEX \"Node_node_i\"\n"
                      "  ON \"Node\" (\"node\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Node_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Node, id_sqlite >::create_schema);

  // Zone
  //

  const char alias_traits<  ::polaris::io::Area_Type,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::area_tag>::
  table_name[] = "\"area\"";

  access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.zone_value,
        i.zone_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // zone
    //
    t[0UL] = false;

    // x
    //
    t[1UL] = false;

    // y
    //
    t[2UL] = false;

    // z
    //
    t[3UL] = false;

    // area
    //
    t[4UL] = false;

    // min_x
    //
    t[5UL] = false;

    // min_y
    //
    t[6UL] = false;

    // max_x
    //
    t[7UL] = false;

    // max_y
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // zone
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.zone_value;
      b[n].is_null = &i.zone_null;
      n++;
    }

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;

    // area
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.area_value;
    b[n].is_null = &i.area_null;
    n++;

    // min_x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_x_value;
    b[n].is_null = &i.min_x_null;
    n++;

    // min_y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_y_value;
    b[n].is_null = &i.min_y_null;
    n++;

    // max_x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_x_value;
    b[n].is_null = &i.max_x_null;
    n++;

    // max_y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_y_value;
    b[n].is_null = &i.max_y_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // zone
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.zone;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.zone_value,
        is_null,
        v);
      i.zone_null = is_null;
    }

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    // area
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Area_Type > const& v =
        o.area;

      typedef object_traits< ::polaris::io::Area_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Area_Type > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.area_value,
          is_null,
          id);
        i.area_null = is_null;
      }
      else
        i.area_null = true;
    }

    // min_x
    //
    {
      double const& v =
        o.min_x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_x_value,
        is_null,
        v);
      i.min_x_null = is_null;
    }

    // min_y
    //
    {
      double const& v =
        o.min_y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_y_value,
        is_null,
        v);
      i.min_y_null = is_null;
    }

    // max_x
    //
    {
      double const& v =
        o.max_x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_x_value,
        is_null,
        v);
      i.max_x_null = is_null;
    }

    // max_y
    //
    {
      double const& v =
        o.max_y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_y_value,
        is_null,
        v);
      i.max_y_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // zone
    //
    {
      int& v =
        o.zone;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.zone_value,
        i.zone_null);
    }

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }

    // area
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Area_Type >& v =
        o.area;

      typedef object_traits< ::polaris::io::Area_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Area_Type > > ptr_traits;

      if (i.area_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.area_value,
          i.area_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // min_x
    //
    {
      double& v =
        o.min_x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_x_value,
        i.min_x_null);
    }

    // min_y
    //
    {
      double& v =
        o.min_y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_y_value,
        i.min_y_null);
    }

    // max_x
    //
    {
      double& v =
        o.max_x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_x_value,
        i.max_x_null);
    }

    // max_y
    //
    {
      double& v =
        o.max_y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_y_value,
        i.max_y_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Zone\" ("
  "\"zone\","
  "\"x\","
  "\"y\","
  "\"z\","
  "\"area\","
  "\"min_x\","
  "\"min_y\","
  "\"max_x\","
  "\"max_y\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Zone\".\"zone\","
  "\"Zone\".\"x\","
  "\"Zone\".\"y\","
  "\"Zone\".\"z\","
  "\"Zone\".\"area\","
  "\"Zone\".\"min_x\","
  "\"Zone\".\"min_y\","
  "\"Zone\".\"max_x\","
  "\"Zone\".\"max_y\""
  " FROM \"Zone\""
  " WHERE \"Zone\".\"zone\"=?";

  const char access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::update_statement[] =
  "UPDATE \"Zone\" SET "
  "\"x\"=?,"
  "\"y\"=?,"
  "\"z\"=?,"
  "\"area\"=?,"
  "\"min_x\"=?,"
  "\"min_y\"=?,"
  "\"max_x\"=?,"
  "\"max_y\"=?"
  " WHERE \"zone\"=?";

  const char access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Zone\""
  " WHERE \"zone\"=?";

  const char access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Zone\".\"zone\","
  "\"Zone\".\"x\","
  "\"Zone\".\"y\","
  "\"Zone\".\"z\","
  "\"Zone\".\"area\","
  "\"Zone\".\"min_x\","
  "\"Zone\".\"min_y\","
  "\"Zone\".\"max_x\","
  "\"Zone\".\"max_y\""
  " FROM \"Zone\""
  " LEFT JOIN \"Area_Type\" AS \"area\" ON \"area\".\"area_type\"=\"Zone\".\"area\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Zone\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::table_name[] =
  "\"Zone\"";

  void access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.zone);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.zone);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Zone\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Zone\" (\n"
                      "  \"zone\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"x\" REAL,\n"
                      "  \"y\" REAL,\n"
                      "  \"z\" REAL,\n"
                      "  \"area\" INTEGER,\n"
                      "  \"min_x\" REAL,\n"
                      "  \"min_y\" REAL,\n"
                      "  \"max_x\" REAL,\n"
                      "  \"max_y\" REAL,\n"
                      "  CONSTRAINT \"area_fk\"\n"
                      "    FOREIGN KEY (\"area\")\n"
                      "    REFERENCES \"Area_Type\" (\"area_type\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Zone_zone_i\"\n"
                      "  ON \"Zone\" (\"zone\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Zone_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Zone, id_sqlite >::create_schema);

  // Shape
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  // nested_records
  //

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  select_statement[] =
  "SELECT "
  "\"Shape_nested_records\".\"index\","
  "\"Shape_nested_records\".\"value_x\","
  "\"Shape_nested_records\".\"value_y\","
  "\"Shape_nested_records\".\"value_z\""
  " FROM \"Shape_nested_records\""
  " WHERE \"Shape_nested_records\".\"object_id\"=?"
  " ORDER BY \"Shape_nested_records\".\"index\"";

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  insert_statement[] =
  "INSERT INTO \"Shape_nested_records\" ("
  "\"object_id\","
  "\"index\","
  "\"value_x\","
  "\"value_y\","
  "\"value_z\")"
  " VALUES (?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  delete_statement[] =
  "DELETE FROM \"Shape_nested_records\""
  " WHERE \"object_id\"=?";

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_sqlite >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  grow (data_image_type& i, bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    if (composite_value_traits< value_type, id_sqlite >::grow (
          i.value_value, t + 1UL))
    {
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  init (data_image_type& i, index_type* j, const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      composite_value_traits< value_type, id_sqlite >::init (
        i.value_value,
        v,
        sk);
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  init (index_type& j, value_type& v, const data_image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_sqlite >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());
    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  persist (const container_type& c, statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  load (container_type& c, statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  update (const container_type& c, statements_type& sts)
  {
    using namespace sqlite;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::nested_records_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // points
    //
    t[2UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // points
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.points_value;
    b[n].is_null = &i.points_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // points
    //
    {
      int const& v =
        o.points;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.points_value,
        is_null,
        v);
      i.points_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // points
    //
    {
      int& v =
        o.points;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.points_value,
        i.points_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::container_statement_cache_type
  {
    sqlite::container_statements_impl< nested_records_traits > nested_records;

    container_statement_cache_type (
      sqlite::connection& c,
      sqlite::binding& id)
    : nested_records (c, id)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Shape\" ("
  "\"auto_id\","
  "\"link\","
  "\"points\")"
  " VALUES (?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Shape\".\"auto_id\","
  "\"Shape\".\"link\","
  "\"Shape\".\"points\""
  " FROM \"Shape\""
  " WHERE \"Shape\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::update_statement[] =
  "UPDATE \"Shape\" SET "
  "\"link\"=?,"
  "\"points\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Shape\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Shape\".\"auto_id\","
  "\"Shape\".\"link\","
  "\"Shape\".\"points\""
  " FROM \"Shape\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Shape\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Shape\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::table_name[] =
  "\"Shape\"";

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    {
      ::std::vector< ::polaris::io::shape_geometry > const& v =
        obj.nested_records;

      nested_records_traits::persist (
        v,
        sts.container_statment_cache ().nested_records);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    // nested_records
    //
    {
      ::std::vector< ::polaris::io::shape_geometry > const& v =
        obj.nested_records;

      nested_records_traits::update (
        v,
        sts.container_statment_cache ().nested_records);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    nested_records_traits::erase (
      sts.container_statment_cache ().nested_records);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  load_ (statements_type& sts, object_type& obj)
  {
    // nested_records
    //
    {
      ::std::vector< ::polaris::io::shape_geometry >& v =
        obj.nested_records;

      nested_records_traits::load (
        v,
        sts.container_statment_cache ().nested_records);
    }
  }

  result< access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Shape_nested_records\"");
          db.execute ("DROP TABLE IF EXISTS \"Shape\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Shape\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"points\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"Shape_nested_records\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value_x\" REAL,\n"
                      "  \"value_y\" REAL,\n"
                      "  \"value_z\" REAL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"Shape\" (\"auto_id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"Shape_nested_records_object_id_i\"\n"
                      "  ON \"Shape_nested_records\" (\"object_id\")");
          db.execute ("CREATE INDEX \"Shape_nested_records_index_i\"\n"
                      "  ON \"Shape_nested_records\" (\"index\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Shape_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Shape, id_sqlite >::create_schema);

  // Link
  //

  const char alias_traits<  ::polaris::io::Node,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Link, id_sqlite >::node_a_tag>::
  table_name[] = "\"node_a\"";

  const char alias_traits<  ::polaris::io::Node,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Link, id_sqlite >::node_b_tag>::
  table_name[] = "\"node_b\"";

  const char alias_traits<  ::polaris::io::Link_Type,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Link, id_sqlite >::type_tag>::
  table_name[] = "\"type\"";

  const char alias_traits<  ::polaris::io::Area_Type,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Link, id_sqlite >::area_type_tag>::
  table_name[] = "\"area_type\"";

  access::object_traits_impl< ::polaris::io::Link, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.link_value,
        i.link_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // link
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // node_a
    //
    t[2UL] = false;

    // node_b
    //
    t[3UL] = false;

    // length
    //
    t[4UL] = false;

    // setback_a
    //
    t[5UL] = false;

    // setback_b
    //
    t[6UL] = false;

    // bearing_a
    //
    t[7UL] = false;

    // bearing_b
    //
    t[8UL] = false;

    // type
    //
    if (t[9UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // divided
    //
    t[10UL] = false;

    // area_type
    //
    t[11UL] = false;

    // use
    //
    t[12UL] = false;

    // grade
    //
    t[13UL] = false;

    // lanes_ab
    //
    t[14UL] = false;

    // speed_ab
    //
    t[15UL] = false;

    // fspd_ab
    //
    t[16UL] = false;

    // cap_ab
    //
    t[17UL] = false;

    // lanes_ba
    //
    t[18UL] = false;

    // speed_ba
    //
    t[19UL] = false;

    // fspd_ba
    //
    t[20UL] = false;

    // cap_ba
    //
    t[21UL] = false;

    // left_ab
    //
    t[22UL] = false;

    // right_ab
    //
    t[23UL] = false;

    // left_ba
    //
    t[24UL] = false;

    // right_ba
    //
    t[25UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // link
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.link_value;
      b[n].is_null = &i.link_null;
      n++;
    }

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // node_a
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_a_value;
    b[n].is_null = &i.node_a_null;
    n++;

    // node_b
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_b_value;
    b[n].is_null = &i.node_b_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // setback_a
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_a_value;
    b[n].is_null = &i.setback_a_null;
    n++;

    // setback_b
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_b_value;
    b[n].is_null = &i.setback_b_null;
    n++;

    // bearing_a
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bearing_a_value;
    b[n].is_null = &i.bearing_a_null;
    n++;

    // bearing_b
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bearing_b_value;
    b[n].is_null = &i.bearing_b_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // divided
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.divided_value;
    b[n].is_null = &i.divided_null;
    n++;

    // area_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.area_type_value;
    b[n].is_null = &i.area_type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // grade
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.grade_value;
    b[n].is_null = &i.grade_null;
    n++;

    // lanes_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_ab_value;
    b[n].is_null = &i.lanes_ab_null;
    n++;

    // speed_ab
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_ab_value;
    b[n].is_null = &i.speed_ab_null;
    n++;

    // fspd_ab
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.fspd_ab_value;
    b[n].is_null = &i.fspd_ab_null;
    n++;

    // cap_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cap_ab_value;
    b[n].is_null = &i.cap_ab_null;
    n++;

    // lanes_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_ba_value;
    b[n].is_null = &i.lanes_ba_null;
    n++;

    // speed_ba
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_ba_value;
    b[n].is_null = &i.speed_ba_null;
    n++;

    // fspd_ba
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.fspd_ba_value;
    b[n].is_null = &i.fspd_ba_null;
    n++;

    // cap_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cap_ba_value;
    b[n].is_null = &i.cap_ba_null;
    n++;

    // left_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.left_ab_value;
    b[n].is_null = &i.left_ab_null;
    n++;

    // right_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.right_ab_value;
    b[n].is_null = &i.right_ab_null;
    n++;

    // left_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.left_ba_value;
    b[n].is_null = &i.left_ba_null;
    n++;

    // right_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.right_ba_value;
    b[n].is_null = &i.right_ba_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // link
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.link;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.link_value,
        is_null,
        v);
      i.link_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // node_a
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node > const& v =
        o.node_a;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_a_value,
          is_null,
          id);
        i.node_a_null = is_null;
      }
      else
        i.node_a_null = true;
    }

    // node_b
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node > const& v =
        o.node_b;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_b_value,
          is_null,
          id);
        i.node_b_null = is_null;
      }
      else
        i.node_b_null = true;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // setback_a
    //
    {
      double const& v =
        o.setback_a;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_a_value,
        is_null,
        v);
      i.setback_a_null = is_null;
    }

    // setback_b
    //
    {
      double const& v =
        o.setback_b;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_b_value,
        is_null,
        v);
      i.setback_b_null = is_null;
    }

    // bearing_a
    //
    {
      int const& v =
        o.bearing_a;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.bearing_a_value,
        is_null,
        v);
      i.bearing_a_null = is_null;
    }

    // bearing_b
    //
    {
      int const& v =
        o.bearing_b;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.bearing_b_value,
        is_null,
        v);
      i.bearing_b_null = is_null;
    }

    // type
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link_Type > const& v =
        o.type;

      typedef object_traits< ::polaris::io::Link_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link_Type > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        std::size_t cap (i.type_value.capacity ());
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_text >::set_image (
          i.type_value,
          i.type_size,
          is_null,
          id);
        i.type_null = is_null;
        grew = grew || (cap != i.type_value.capacity ());
      }
      else
        i.type_null = true;
    }

    // divided
    //
    {
      int const& v =
        o.divided;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.divided_value,
        is_null,
        v);
      i.divided_null = is_null;
    }

    // area_type
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Area_Type > const& v =
        o.area_type;

      typedef object_traits< ::polaris::io::Area_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Area_Type > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.area_type_value,
          is_null,
          id);
        i.area_type_null = is_null;
      }
      else
        i.area_type_null = true;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // grade
    //
    {
      double const& v =
        o.grade;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.grade_value,
        is_null,
        v);
      i.grade_null = is_null;
    }

    // lanes_ab
    //
    {
      int const& v =
        o.lanes_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_ab_value,
        is_null,
        v);
      i.lanes_ab_null = is_null;
    }

    // speed_ab
    //
    {
      double const& v =
        o.speed_ab;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_ab_value,
        is_null,
        v);
      i.speed_ab_null = is_null;
    }

    // fspd_ab
    //
    {
      double const& v =
        o.fspd_ab;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.fspd_ab_value,
        is_null,
        v);
      i.fspd_ab_null = is_null;
    }

    // cap_ab
    //
    {
      int const& v =
        o.cap_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cap_ab_value,
        is_null,
        v);
      i.cap_ab_null = is_null;
    }

    // lanes_ba
    //
    {
      int const& v =
        o.lanes_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_ba_value,
        is_null,
        v);
      i.lanes_ba_null = is_null;
    }

    // speed_ba
    //
    {
      double const& v =
        o.speed_ba;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_ba_value,
        is_null,
        v);
      i.speed_ba_null = is_null;
    }

    // fspd_ba
    //
    {
      double const& v =
        o.fspd_ba;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.fspd_ba_value,
        is_null,
        v);
      i.fspd_ba_null = is_null;
    }

    // cap_ba
    //
    {
      int const& v =
        o.cap_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cap_ba_value,
        is_null,
        v);
      i.cap_ba_null = is_null;
    }

    // left_ab
    //
    {
      int const& v =
        o.left_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.left_ab_value,
        is_null,
        v);
      i.left_ab_null = is_null;
    }

    // right_ab
    //
    {
      int const& v =
        o.right_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.right_ab_value,
        is_null,
        v);
      i.right_ab_null = is_null;
    }

    // left_ba
    //
    {
      int const& v =
        o.left_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.left_ba_value,
        is_null,
        v);
      i.left_ba_null = is_null;
    }

    // right_ba
    //
    {
      int const& v =
        o.right_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.right_ba_value,
        is_null,
        v);
      i.right_ba_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // link
    //
    {
      int& v =
        o.link;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.link_value,
        i.link_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // node_a
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node >& v =
        o.node_a;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      if (i.node_a_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_a_value,
          i.node_a_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // node_b
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node >& v =
        o.node_b;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      if (i.node_b_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_b_value,
          i.node_b_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // setback_a
    //
    {
      double& v =
        o.setback_a;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_a_value,
        i.setback_a_null);
    }

    // setback_b
    //
    {
      double& v =
        o.setback_b;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_b_value,
        i.setback_b_null);
    }

    // bearing_a
    //
    {
      int& v =
        o.bearing_a;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.bearing_a_value,
        i.bearing_a_null);
    }

    // bearing_b
    //
    {
      int& v =
        o.bearing_b;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.bearing_b_value,
        i.bearing_b_null);
    }

    // type
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link_Type >& v =
        o.type;

      typedef object_traits< ::polaris::io::Link_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link_Type > > ptr_traits;

      if (i.type_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_text >::set_value (
          id,
          i.type_value,
          i.type_size,
          i.type_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // divided
    //
    {
      int& v =
        o.divided;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.divided_value,
        i.divided_null);
    }

    // area_type
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Area_Type >& v =
        o.area_type;

      typedef object_traits< ::polaris::io::Area_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Area_Type > > ptr_traits;

      if (i.area_type_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.area_type_value,
          i.area_type_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // grade
    //
    {
      double& v =
        o.grade;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.grade_value,
        i.grade_null);
    }

    // lanes_ab
    //
    {
      int& v =
        o.lanes_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_ab_value,
        i.lanes_ab_null);
    }

    // speed_ab
    //
    {
      double& v =
        o.speed_ab;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_ab_value,
        i.speed_ab_null);
    }

    // fspd_ab
    //
    {
      double& v =
        o.fspd_ab;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.fspd_ab_value,
        i.fspd_ab_null);
    }

    // cap_ab
    //
    {
      int& v =
        o.cap_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cap_ab_value,
        i.cap_ab_null);
    }

    // lanes_ba
    //
    {
      int& v =
        o.lanes_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_ba_value,
        i.lanes_ba_null);
    }

    // speed_ba
    //
    {
      double& v =
        o.speed_ba;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_ba_value,
        i.speed_ba_null);
    }

    // fspd_ba
    //
    {
      double& v =
        o.fspd_ba;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.fspd_ba_value,
        i.fspd_ba_null);
    }

    // cap_ba
    //
    {
      int& v =
        o.cap_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cap_ba_value,
        i.cap_ba_null);
    }

    // left_ab
    //
    {
      int& v =
        o.left_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.left_ab_value,
        i.left_ab_null);
    }

    // right_ab
    //
    {
      int& v =
        o.right_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.right_ab_value,
        i.right_ab_null);
    }

    // left_ba
    //
    {
      int& v =
        o.left_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.left_ba_value,
        i.left_ba_null);
    }

    // right_ba
    //
    {
      int& v =
        o.right_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.right_ba_value,
        i.right_ba_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Link, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Link, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Link\" ("
  "\"link\","
  "\"name\","
  "\"node_a\","
  "\"node_b\","
  "\"length\","
  "\"setback_a\","
  "\"setback_b\","
  "\"bearing_a\","
  "\"bearing_b\","
  "\"type\","
  "\"divided\","
  "\"area_type\","
  "\"use\","
  "\"grade\","
  "\"lanes_ab\","
  "\"speed_ab\","
  "\"fspd_ab\","
  "\"cap_ab\","
  "\"lanes_ba\","
  "\"speed_ba\","
  "\"fspd_ba\","
  "\"cap_ba\","
  "\"left_ab\","
  "\"right_ab\","
  "\"left_ba\","
  "\"right_ba\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Link, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Link\".\"link\","
  "\"Link\".\"name\","
  "\"Link\".\"node_a\","
  "\"Link\".\"node_b\","
  "\"Link\".\"length\","
  "\"Link\".\"setback_a\","
  "\"Link\".\"setback_b\","
  "\"Link\".\"bearing_a\","
  "\"Link\".\"bearing_b\","
  "\"Link\".\"type\","
  "\"Link\".\"divided\","
  "\"Link\".\"area_type\","
  "\"Link\".\"use\","
  "\"Link\".\"grade\","
  "\"Link\".\"lanes_ab\","
  "\"Link\".\"speed_ab\","
  "\"Link\".\"fspd_ab\","
  "\"Link\".\"cap_ab\","
  "\"Link\".\"lanes_ba\","
  "\"Link\".\"speed_ba\","
  "\"Link\".\"fspd_ba\","
  "\"Link\".\"cap_ba\","
  "\"Link\".\"left_ab\","
  "\"Link\".\"right_ab\","
  "\"Link\".\"left_ba\","
  "\"Link\".\"right_ba\""
  " FROM \"Link\""
  " WHERE \"Link\".\"link\"=?";

  const char access::object_traits_impl< ::polaris::io::Link, id_sqlite >::update_statement[] =
  "UPDATE \"Link\" SET "
  "\"name\"=?,"
  "\"node_a\"=?,"
  "\"node_b\"=?,"
  "\"length\"=?,"
  "\"setback_a\"=?,"
  "\"setback_b\"=?,"
  "\"bearing_a\"=?,"
  "\"bearing_b\"=?,"
  "\"type\"=?,"
  "\"divided\"=?,"
  "\"area_type\"=?,"
  "\"use\"=?,"
  "\"grade\"=?,"
  "\"lanes_ab\"=?,"
  "\"speed_ab\"=?,"
  "\"fspd_ab\"=?,"
  "\"cap_ab\"=?,"
  "\"lanes_ba\"=?,"
  "\"speed_ba\"=?,"
  "\"fspd_ba\"=?,"
  "\"cap_ba\"=?,"
  "\"left_ab\"=?,"
  "\"right_ab\"=?,"
  "\"left_ba\"=?,"
  "\"right_ba\"=?"
  " WHERE \"link\"=?";

  const char access::object_traits_impl< ::polaris::io::Link, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Link\""
  " WHERE \"link\"=?";

  const char access::object_traits_impl< ::polaris::io::Link, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Link\".\"link\","
  "\"Link\".\"name\","
  "\"Link\".\"node_a\","
  "\"Link\".\"node_b\","
  "\"Link\".\"length\","
  "\"Link\".\"setback_a\","
  "\"Link\".\"setback_b\","
  "\"Link\".\"bearing_a\","
  "\"Link\".\"bearing_b\","
  "\"Link\".\"type\","
  "\"Link\".\"divided\","
  "\"Link\".\"area_type\","
  "\"Link\".\"use\","
  "\"Link\".\"grade\","
  "\"Link\".\"lanes_ab\","
  "\"Link\".\"speed_ab\","
  "\"Link\".\"fspd_ab\","
  "\"Link\".\"cap_ab\","
  "\"Link\".\"lanes_ba\","
  "\"Link\".\"speed_ba\","
  "\"Link\".\"fspd_ba\","
  "\"Link\".\"cap_ba\","
  "\"Link\".\"left_ab\","
  "\"Link\".\"right_ab\","
  "\"Link\".\"left_ba\","
  "\"Link\".\"right_ba\""
  " FROM \"Link\""
  " LEFT JOIN \"Node\" AS \"node_a\" ON \"node_a\".\"node\"=\"Link\".\"node_a\""
  " LEFT JOIN \"Node\" AS \"node_b\" ON \"node_b\".\"node\"=\"Link\".\"node_b\""
  " LEFT JOIN \"Link_Type\" AS \"type\" ON \"type\".\"link_type\"=\"Link\".\"type\""
  " LEFT JOIN \"Area_Type\" AS \"area_type\" ON \"area_type\".\"area_type\"=\"Link\".\"area_type\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Link, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Link, id_sqlite >::table_name[] =
  "\"Link\"";

  void access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.link);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Link, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.link);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Link, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Link, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Link\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Link\" (\n"
                      "  \"link\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"node_a\" INTEGER,\n"
                      "  \"node_b\" INTEGER,\n"
                      "  \"length\" REAL,\n"
                      "  \"setback_a\" REAL,\n"
                      "  \"setback_b\" REAL,\n"
                      "  \"bearing_a\" INTEGER NOT NULL,\n"
                      "  \"bearing_b\" INTEGER NOT NULL,\n"
                      "  \"type\" TEXT,\n"
                      "  \"divided\" INTEGER NOT NULL,\n"
                      "  \"area_type\" INTEGER,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"grade\" REAL,\n"
                      "  \"lanes_ab\" INTEGER NOT NULL,\n"
                      "  \"speed_ab\" REAL,\n"
                      "  \"fspd_ab\" REAL,\n"
                      "  \"cap_ab\" INTEGER NOT NULL,\n"
                      "  \"lanes_ba\" INTEGER NOT NULL,\n"
                      "  \"speed_ba\" REAL,\n"
                      "  \"fspd_ba\" REAL,\n"
                      "  \"cap_ba\" INTEGER NOT NULL,\n"
                      "  \"left_ab\" INTEGER NOT NULL,\n"
                      "  \"right_ab\" INTEGER NOT NULL,\n"
                      "  \"left_ba\" INTEGER NOT NULL,\n"
                      "  \"right_ba\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"node_a_fk\"\n"
                      "    FOREIGN KEY (\"node_a\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"node_b_fk\"\n"
                      "    FOREIGN KEY (\"node_b\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"type_fk\"\n"
                      "    FOREIGN KEY (\"type\")\n"
                      "    REFERENCES \"Link_Type\" (\"link_type\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"area_type_fk\"\n"
                      "    FOREIGN KEY (\"area_type\")\n"
                      "    REFERENCES \"Area_Type\" (\"area_type\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Link_link_i\"\n"
                      "  ON \"Link\" (\"link\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Link_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Link, id_sqlite >::create_schema);

  // Pocket
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // type
    //
    if (t[3UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // lanes
    //
    t[4UL] = false;

    // length
    //
    t[5UL] = false;

    // offset
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Pocket\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"type\","
  "\"lanes\","
  "\"length\","
  "\"offset\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Pocket\".\"auto_id\","
  "\"Pocket\".\"link\","
  "\"Pocket\".\"dir\","
  "\"Pocket\".\"type\","
  "\"Pocket\".\"lanes\","
  "\"Pocket\".\"length\","
  "\"Pocket\".\"offset\""
  " FROM \"Pocket\""
  " WHERE \"Pocket\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::update_statement[] =
  "UPDATE \"Pocket\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"type\"=?,"
  "\"lanes\"=?,"
  "\"length\"=?,"
  "\"offset\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Pocket\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Pocket\".\"auto_id\","
  "\"Pocket\".\"link\","
  "\"Pocket\".\"dir\","
  "\"Pocket\".\"type\","
  "\"Pocket\".\"lanes\","
  "\"Pocket\".\"length\","
  "\"Pocket\".\"offset\""
  " FROM \"Pocket\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Pocket\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Pocket\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::table_name[] =
  "\"Pocket\"";

  void access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Pocket\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Pocket\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"type\" TEXT NOT NULL,\n"
                      "  \"lanes\" INTEGER NOT NULL,\n"
                      "  \"length\" REAL,\n"
                      "  \"offset\" REAL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Pocket_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Pocket, id_sqlite >::create_schema);

  // Lane_Use
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // lanes
    //
    t[3UL] = false;

    // use
    //
    t[4UL] = false;

    // type
    //
    t[5UL] = false;

    // min_type
    //
    t[6UL] = false;

    // max_type
    //
    t[7UL] = false;

    // min_trav
    //
    t[8UL] = false;

    // max_trav
    //
    t[9UL] = false;

    // start
    //
    t[10UL] = false;

    // end
    //
    t[11UL] = false;

    // offset
    //
    t[12UL] = false;

    // length
    //
    t[13UL] = false;

    // toll
    //
    t[14UL] = false;

    // rate
    //
    t[15UL] = false;

    // min_delay
    //
    t[16UL] = false;

    // max_delay
    //
    t[17UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // min_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_type_value;
    b[n].is_null = &i.min_type_null;
    n++;

    // max_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_type_value;
    b[n].is_null = &i.max_type_null;
    n++;

    // min_trav
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_trav_value;
    b[n].is_null = &i.min_trav_null;
    n++;

    // max_trav
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_trav_value;
    b[n].is_null = &i.max_trav_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // toll
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.toll_value;
    b[n].is_null = &i.toll_null;
    n++;

    // rate
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.rate_value;
    b[n].is_null = &i.rate_null;
    n++;

    // min_delay
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_delay_value;
    b[n].is_null = &i.min_delay_null;
    n++;

    // max_delay
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_delay_value;
    b[n].is_null = &i.max_delay_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // min_type
    //
    {
      int const& v =
        o.min_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_type_value,
        is_null,
        v);
      i.min_type_null = is_null;
    }

    // max_type
    //
    {
      int const& v =
        o.max_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_type_value,
        is_null,
        v);
      i.max_type_null = is_null;
    }

    // min_trav
    //
    {
      int const& v =
        o.min_trav;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_trav_value,
        is_null,
        v);
      i.min_trav_null = is_null;
    }

    // max_trav
    //
    {
      int const& v =
        o.max_trav;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_trav_value,
        is_null,
        v);
      i.max_trav_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // toll
    //
    {
      int const& v =
        o.toll;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.toll_value,
        is_null,
        v);
      i.toll_null = is_null;
    }

    // rate
    //
    {
      double const& v =
        o.rate;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.rate_value,
        is_null,
        v);
      i.rate_null = is_null;
    }

    // min_delay
    //
    {
      double const& v =
        o.min_delay;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_delay_value,
        is_null,
        v);
      i.min_delay_null = is_null;
    }

    // max_delay
    //
    {
      double const& v =
        o.max_delay;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_delay_value,
        is_null,
        v);
      i.max_delay_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // min_type
    //
    {
      int& v =
        o.min_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_type_value,
        i.min_type_null);
    }

    // max_type
    //
    {
      int& v =
        o.max_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_type_value,
        i.max_type_null);
    }

    // min_trav
    //
    {
      int& v =
        o.min_trav;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_trav_value,
        i.min_trav_null);
    }

    // max_trav
    //
    {
      int& v =
        o.max_trav;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_trav_value,
        i.max_trav_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // toll
    //
    {
      int& v =
        o.toll;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.toll_value,
        i.toll_null);
    }

    // rate
    //
    {
      double& v =
        o.rate;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.rate_value,
        i.rate_null);
    }

    // min_delay
    //
    {
      double& v =
        o.min_delay;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_delay_value,
        i.min_delay_null);
    }

    // max_delay
    //
    {
      double& v =
        o.max_delay;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_delay_value,
        i.max_delay_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Lane_Use\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"lanes\","
  "\"use\","
  "\"type\","
  "\"min_type\","
  "\"max_type\","
  "\"min_trav\","
  "\"max_trav\","
  "\"start\","
  "\"end\","
  "\"offset\","
  "\"length\","
  "\"toll\","
  "\"rate\","
  "\"min_delay\","
  "\"max_delay\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Lane_Use\".\"auto_id\","
  "\"Lane_Use\".\"link\","
  "\"Lane_Use\".\"dir\","
  "\"Lane_Use\".\"lanes\","
  "\"Lane_Use\".\"use\","
  "\"Lane_Use\".\"type\","
  "\"Lane_Use\".\"min_type\","
  "\"Lane_Use\".\"max_type\","
  "\"Lane_Use\".\"min_trav\","
  "\"Lane_Use\".\"max_trav\","
  "\"Lane_Use\".\"start\","
  "\"Lane_Use\".\"end\","
  "\"Lane_Use\".\"offset\","
  "\"Lane_Use\".\"length\","
  "\"Lane_Use\".\"toll\","
  "\"Lane_Use\".\"rate\","
  "\"Lane_Use\".\"min_delay\","
  "\"Lane_Use\".\"max_delay\""
  " FROM \"Lane_Use\""
  " WHERE \"Lane_Use\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::update_statement[] =
  "UPDATE \"Lane_Use\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"lanes\"=?,"
  "\"use\"=?,"
  "\"type\"=?,"
  "\"min_type\"=?,"
  "\"max_type\"=?,"
  "\"min_trav\"=?,"
  "\"max_trav\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"offset\"=?,"
  "\"length\"=?,"
  "\"toll\"=?,"
  "\"rate\"=?,"
  "\"min_delay\"=?,"
  "\"max_delay\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Lane_Use\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Lane_Use\".\"auto_id\","
  "\"Lane_Use\".\"link\","
  "\"Lane_Use\".\"dir\","
  "\"Lane_Use\".\"lanes\","
  "\"Lane_Use\".\"use\","
  "\"Lane_Use\".\"type\","
  "\"Lane_Use\".\"min_type\","
  "\"Lane_Use\".\"max_type\","
  "\"Lane_Use\".\"min_trav\","
  "\"Lane_Use\".\"max_trav\","
  "\"Lane_Use\".\"start\","
  "\"Lane_Use\".\"end\","
  "\"Lane_Use\".\"offset\","
  "\"Lane_Use\".\"length\","
  "\"Lane_Use\".\"toll\","
  "\"Lane_Use\".\"rate\","
  "\"Lane_Use\".\"min_delay\","
  "\"Lane_Use\".\"max_delay\""
  " FROM \"Lane_Use\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Lane_Use\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Lane_Use\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::table_name[] =
  "\"Lane_Use\"";

  void access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Lane_Use\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Lane_Use\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"lanes\" INTEGER NOT NULL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"min_type\" INTEGER NOT NULL,\n"
                      "  \"max_type\" INTEGER NOT NULL,\n"
                      "  \"min_trav\" INTEGER NOT NULL,\n"
                      "  \"max_trav\" INTEGER NOT NULL,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"length\" REAL,\n"
                      "  \"toll\" INTEGER NOT NULL,\n"
                      "  \"rate\" REAL,\n"
                      "  \"min_delay\" REAL,\n"
                      "  \"max_delay\" REAL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Lane_Use_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Lane_Use, id_sqlite >::create_schema);

  // Connect
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::to_link_tag>::
  table_name[] = "\"to_link\"";

  access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.conn_value,
        i.conn_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // conn
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // to_link
    //
    t[3UL] = false;

    // lanes
    //
    if (t[4UL])
    {
      i.lanes_value.capacity (i.lanes_size);
      grew = true;
    }

    // to_lanes
    //
    if (t[5UL])
    {
      i.to_lanes_value.capacity (i.to_lanes_size);
      grew = true;
    }

    // type
    //
    if (t[6UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // penalty
    //
    t[7UL] = false;

    // speed
    //
    t[8UL] = false;

    // capacity
    //
    t[9UL] = false;

    // in_high
    //
    t[10UL] = false;

    // out_high
    //
    t[11UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // conn
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.conn_value;
      b[n].is_null = &i.conn_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.lanes_value.data ();
    b[n].size = &i.lanes_size;
    b[n].capacity = i.lanes_value.capacity ();
    b[n].is_null = &i.lanes_null;
    n++;

    // to_lanes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.to_lanes_value.data ();
    b[n].size = &i.to_lanes_size;
    b[n].capacity = i.to_lanes_value.capacity ();
    b[n].is_null = &i.to_lanes_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // penalty
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.penalty_value;
    b[n].is_null = &i.penalty_null;
    n++;

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;

    // capacity
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.capacity_value;
    b[n].is_null = &i.capacity_null;
    n++;

    // in_high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.in_high_value;
    b[n].is_null = &i.in_high_null;
    n++;

    // out_high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.out_high_value;
    b[n].is_null = &i.out_high_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // conn
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.conn;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.conn_value,
        is_null,
        v);
      i.conn_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.to_link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // lanes
    //
    {
      ::std::string const& v =
        o.lanes;

      bool is_null (false);
      std::size_t cap (i.lanes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.lanes_value,
        i.lanes_size,
        is_null,
        v);
      i.lanes_null = is_null;
      grew = grew || (cap != i.lanes_value.capacity ());
    }

    // to_lanes
    //
    {
      ::std::string const& v =
        o.to_lanes;

      bool is_null (false);
      std::size_t cap (i.to_lanes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.to_lanes_value,
        i.to_lanes_size,
        is_null,
        v);
      i.to_lanes_null = is_null;
      grew = grew || (cap != i.to_lanes_value.capacity ());
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // penalty
    //
    {
      int const& v =
        o.penalty;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.penalty_value,
        is_null,
        v);
      i.penalty_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    // capacity
    //
    {
      int const& v =
        o.capacity;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.capacity_value,
        is_null,
        v);
      i.capacity_null = is_null;
    }

    // in_high
    //
    {
      int const& v =
        o.in_high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.in_high_value,
        is_null,
        v);
      i.in_high_null = is_null;
    }

    // out_high
    //
    {
      int const& v =
        o.out_high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.out_high_value,
        is_null,
        v);
      i.out_high_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // conn
    //
    {
      long unsigned int& v =
        o.conn;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.conn_value,
        i.conn_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.to_link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // lanes
    //
    {
      ::std::string& v =
        o.lanes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.lanes_value,
        i.lanes_size,
        i.lanes_null);
    }

    // to_lanes
    //
    {
      ::std::string& v =
        o.to_lanes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.to_lanes_value,
        i.to_lanes_size,
        i.to_lanes_null);
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // penalty
    //
    {
      int& v =
        o.penalty;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.penalty_value,
        i.penalty_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }

    // capacity
    //
    {
      int& v =
        o.capacity;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.capacity_value,
        i.capacity_null);
    }

    // in_high
    //
    {
      int& v =
        o.in_high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.in_high_value,
        i.in_high_null);
    }

    // out_high
    //
    {
      int& v =
        o.out_high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.out_high_value,
        i.out_high_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Connection\" ("
  "\"conn\","
  "\"link\","
  "\"dir\","
  "\"to_link\","
  "\"lanes\","
  "\"to_lanes\","
  "\"type\","
  "\"penalty\","
  "\"speed\","
  "\"capacity\","
  "\"in_high\","
  "\"out_high\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Connection\".\"conn\","
  "\"Connection\".\"link\","
  "\"Connection\".\"dir\","
  "\"Connection\".\"to_link\","
  "\"Connection\".\"lanes\","
  "\"Connection\".\"to_lanes\","
  "\"Connection\".\"type\","
  "\"Connection\".\"penalty\","
  "\"Connection\".\"speed\","
  "\"Connection\".\"capacity\","
  "\"Connection\".\"in_high\","
  "\"Connection\".\"out_high\""
  " FROM \"Connection\""
  " WHERE \"Connection\".\"conn\"=?";

  const char access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::update_statement[] =
  "UPDATE \"Connection\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"to_link\"=?,"
  "\"lanes\"=?,"
  "\"to_lanes\"=?,"
  "\"type\"=?,"
  "\"penalty\"=?,"
  "\"speed\"=?,"
  "\"capacity\"=?,"
  "\"in_high\"=?,"
  "\"out_high\"=?"
  " WHERE \"conn\"=?";

  const char access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Connection\""
  " WHERE \"conn\"=?";

  const char access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Connection\".\"conn\","
  "\"Connection\".\"link\","
  "\"Connection\".\"dir\","
  "\"Connection\".\"to_link\","
  "\"Connection\".\"lanes\","
  "\"Connection\".\"to_lanes\","
  "\"Connection\".\"type\","
  "\"Connection\".\"penalty\","
  "\"Connection\".\"speed\","
  "\"Connection\".\"capacity\","
  "\"Connection\".\"in_high\","
  "\"Connection\".\"out_high\""
  " FROM \"Connection\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Connection\".\"link\""
  " LEFT JOIN \"Link\" AS \"to_link\" ON \"to_link\".\"link\"=\"Connection\".\"to_link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Connection\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::table_name[] =
  "\"Connection\"";

  void access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.conn_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.conn = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.conn);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.conn);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Connection\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Connection\" (\n"
                      "  \"conn\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"to_link\" INTEGER,\n"
                      "  \"lanes\" TEXT NOT NULL,\n"
                      "  \"to_lanes\" TEXT NOT NULL,\n"
                      "  \"type\" TEXT NOT NULL,\n"
                      "  \"penalty\" INTEGER NOT NULL,\n"
                      "  \"speed\" REAL,\n"
                      "  \"capacity\" INTEGER NOT NULL,\n"
                      "  \"in_high\" INTEGER NOT NULL,\n"
                      "  \"out_high\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"to_link_fk\"\n"
                      "    FOREIGN KEY (\"to_link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Connect_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Connect, id_sqlite >::create_schema);

  // Turn_Pen
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::to_link_tag>::
  table_name[] = "\"to_link\"";

  const char alias_traits<  ::polaris::io::Node,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::in_node_tag>::
  table_name[] = "\"in_node\"";

  const char alias_traits<  ::polaris::io::Node,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::out_node_tag>::
  table_name[] = "\"out_node\"";

  access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // to_link
    //
    t[3UL] = false;

    // start
    //
    t[4UL] = false;

    // end
    //
    t[5UL] = false;

    // use
    //
    t[6UL] = false;

    // min_type
    //
    t[7UL] = false;

    // max_type
    //
    t[8UL] = false;

    // penalty
    //
    t[9UL] = false;

    // in_node
    //
    t[10UL] = false;

    // out_node
    //
    t[11UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // to_link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_link_value;
    b[n].is_null = &i.to_link_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // min_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.min_type_value;
    b[n].is_null = &i.min_type_null;
    n++;

    // max_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_type_value;
    b[n].is_null = &i.max_type_null;
    n++;

    // penalty
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.penalty_value;
    b[n].is_null = &i.penalty_null;
    n++;

    // in_node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.in_node_value;
    b[n].is_null = &i.in_node_null;
    n++;

    // out_node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.out_node_value;
    b[n].is_null = &i.out_node_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.to_link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_link_value,
          is_null,
          id);
        i.to_link_null = is_null;
      }
      else
        i.to_link_null = true;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // min_type
    //
    {
      int const& v =
        o.min_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.min_type_value,
        is_null,
        v);
      i.min_type_null = is_null;
    }

    // max_type
    //
    {
      int const& v =
        o.max_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.max_type_value,
        is_null,
        v);
      i.max_type_null = is_null;
    }

    // penalty
    //
    {
      int const& v =
        o.penalty;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.penalty_value,
        is_null,
        v);
      i.penalty_null = is_null;
    }

    // in_node
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node > const& v =
        o.in_node;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.in_node_value,
          is_null,
          id);
        i.in_node_null = is_null;
      }
      else
        i.in_node_null = true;
    }

    // out_node
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node > const& v =
        o.out_node;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.out_node_value,
          is_null,
          id);
        i.out_node_null = is_null;
      }
      else
        i.out_node_null = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // to_link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.to_link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.to_link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_link_value,
          i.to_link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // min_type
    //
    {
      int& v =
        o.min_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.min_type_value,
        i.min_type_null);
    }

    // max_type
    //
    {
      int& v =
        o.max_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.max_type_value,
        i.max_type_null);
    }

    // penalty
    //
    {
      int& v =
        o.penalty;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.penalty_value,
        i.penalty_null);
    }

    // in_node
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node >& v =
        o.in_node;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      if (i.in_node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.in_node_value,
          i.in_node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // out_node
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node >& v =
        o.out_node;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      if (i.out_node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.out_node_value,
          i.out_node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Turn_Pen\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"to_link\","
  "\"start\","
  "\"end\","
  "\"use\","
  "\"min_type\","
  "\"max_type\","
  "\"penalty\","
  "\"in_node\","
  "\"out_node\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Turn_Pen\".\"auto_id\","
  "\"Turn_Pen\".\"link\","
  "\"Turn_Pen\".\"dir\","
  "\"Turn_Pen\".\"to_link\","
  "\"Turn_Pen\".\"start\","
  "\"Turn_Pen\".\"end\","
  "\"Turn_Pen\".\"use\","
  "\"Turn_Pen\".\"min_type\","
  "\"Turn_Pen\".\"max_type\","
  "\"Turn_Pen\".\"penalty\","
  "\"Turn_Pen\".\"in_node\","
  "\"Turn_Pen\".\"out_node\""
  " FROM \"Turn_Pen\""
  " WHERE \"Turn_Pen\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::update_statement[] =
  "UPDATE \"Turn_Pen\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"to_link\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"use\"=?,"
  "\"min_type\"=?,"
  "\"max_type\"=?,"
  "\"penalty\"=?,"
  "\"in_node\"=?,"
  "\"out_node\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Turn_Pen\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Turn_Pen\".\"auto_id\","
  "\"Turn_Pen\".\"link\","
  "\"Turn_Pen\".\"dir\","
  "\"Turn_Pen\".\"to_link\","
  "\"Turn_Pen\".\"start\","
  "\"Turn_Pen\".\"end\","
  "\"Turn_Pen\".\"use\","
  "\"Turn_Pen\".\"min_type\","
  "\"Turn_Pen\".\"max_type\","
  "\"Turn_Pen\".\"penalty\","
  "\"Turn_Pen\".\"in_node\","
  "\"Turn_Pen\".\"out_node\""
  " FROM \"Turn_Pen\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Turn_Pen\".\"link\""
  " LEFT JOIN \"Link\" AS \"to_link\" ON \"to_link\".\"link\"=\"Turn_Pen\".\"to_link\""
  " LEFT JOIN \"Node\" AS \"in_node\" ON \"in_node\".\"node\"=\"Turn_Pen\".\"in_node\""
  " LEFT JOIN \"Node\" AS \"out_node\" ON \"out_node\".\"node\"=\"Turn_Pen\".\"out_node\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Turn_Pen\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::table_name[] =
  "\"Turn_Pen\"";

  void access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Turn_Pen\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Turn_Pen\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"to_link\" INTEGER,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"min_type\" INTEGER NOT NULL,\n"
                      "  \"max_type\" INTEGER NOT NULL,\n"
                      "  \"penalty\" INTEGER NOT NULL,\n"
                      "  \"in_node\" INTEGER,\n"
                      "  \"out_node\" INTEGER,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"to_link_fk\"\n"
                      "    FOREIGN KEY (\"to_link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"in_node_fk\"\n"
                      "    FOREIGN KEY (\"in_node\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"out_node_fk\"\n"
                      "    FOREIGN KEY (\"out_node\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Turn_Pen_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Turn_Pen, id_sqlite >::create_schema);

  // Parking
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.parking_value,
        i.parking_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // parking
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // type
    //
    t[4UL] = false;

    // use
    //
    t[5UL] = false;

    // start
    //
    t[6UL] = false;

    // end
    //
    t[7UL] = false;

    // space
    //
    t[8UL] = false;

    // time_in
    //
    t[9UL] = false;

    // time_out
    //
    t[10UL] = false;

    // hourly
    //
    t[11UL] = false;

    // daily
    //
    t[12UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // parking
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.parking_value;
      b[n].is_null = &i.parking_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // start
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // end
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.end_value;
    b[n].is_null = &i.end_null;
    n++;

    // space
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.space_value;
    b[n].is_null = &i.space_null;
    n++;

    // time_in
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_in_value;
    b[n].is_null = &i.time_in_null;
    n++;

    // time_out
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_out_value;
    b[n].is_null = &i.time_out_null;
    n++;

    // hourly
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hourly_value;
    b[n].is_null = &i.hourly_null;
    n++;

    // daily
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.daily_value;
    b[n].is_null = &i.daily_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // parking
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.parking;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.parking_value,
        is_null,
        v);
      i.parking_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // start
    //
    {
      double const& v =
        o.start;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.start_value,
        is_null,
        v);
      i.start_null = is_null;
    }

    // end
    //
    {
      double const& v =
        o.end;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.end_value,
        is_null,
        v);
      i.end_null = is_null;
    }

    // space
    //
    {
      int const& v =
        o.space;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.space_value,
        is_null,
        v);
      i.space_null = is_null;
    }

    // time_in
    //
    {
      double const& v =
        o.time_in;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_in_value,
        is_null,
        v);
      i.time_in_null = is_null;
    }

    // time_out
    //
    {
      double const& v =
        o.time_out;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_out_value,
        is_null,
        v);
      i.time_out_null = is_null;
    }

    // hourly
    //
    {
      int const& v =
        o.hourly;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.hourly_value,
        is_null,
        v);
      i.hourly_null = is_null;
    }

    // daily
    //
    {
      int const& v =
        o.daily;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.daily_value,
        is_null,
        v);
      i.daily_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // parking
    //
    {
      int& v =
        o.parking;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.parking_value,
        i.parking_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // start
    //
    {
      double& v =
        o.start;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // end
    //
    {
      double& v =
        o.end;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.end_value,
        i.end_null);
    }

    // space
    //
    {
      int& v =
        o.space;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.space_value,
        i.space_null);
    }

    // time_in
    //
    {
      double& v =
        o.time_in;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_in_value,
        i.time_in_null);
    }

    // time_out
    //
    {
      double& v =
        o.time_out;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_out_value,
        i.time_out_null);
    }

    // hourly
    //
    {
      int& v =
        o.hourly;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.hourly_value,
        i.hourly_null);
    }

    // daily
    //
    {
      int& v =
        o.daily;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.daily_value,
        i.daily_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Parking\" ("
  "\"parking\","
  "\"link\","
  "\"dir\","
  "\"offset\","
  "\"type\","
  "\"use\","
  "\"start\","
  "\"end\","
  "\"space\","
  "\"time_in\","
  "\"time_out\","
  "\"hourly\","
  "\"daily\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Parking\".\"parking\","
  "\"Parking\".\"link\","
  "\"Parking\".\"dir\","
  "\"Parking\".\"offset\","
  "\"Parking\".\"type\","
  "\"Parking\".\"use\","
  "\"Parking\".\"start\","
  "\"Parking\".\"end\","
  "\"Parking\".\"space\","
  "\"Parking\".\"time_in\","
  "\"Parking\".\"time_out\","
  "\"Parking\".\"hourly\","
  "\"Parking\".\"daily\""
  " FROM \"Parking\""
  " WHERE \"Parking\".\"parking\"=?";

  const char access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::update_statement[] =
  "UPDATE \"Parking\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"offset\"=?,"
  "\"type\"=?,"
  "\"use\"=?,"
  "\"start\"=?,"
  "\"end\"=?,"
  "\"space\"=?,"
  "\"time_in\"=?,"
  "\"time_out\"=?,"
  "\"hourly\"=?,"
  "\"daily\"=?"
  " WHERE \"parking\"=?";

  const char access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Parking\""
  " WHERE \"parking\"=?";

  const char access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Parking\".\"parking\","
  "\"Parking\".\"link\","
  "\"Parking\".\"dir\","
  "\"Parking\".\"offset\","
  "\"Parking\".\"type\","
  "\"Parking\".\"use\","
  "\"Parking\".\"start\","
  "\"Parking\".\"end\","
  "\"Parking\".\"space\","
  "\"Parking\".\"time_in\","
  "\"Parking\".\"time_out\","
  "\"Parking\".\"hourly\","
  "\"Parking\".\"daily\""
  " FROM \"Parking\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Parking\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Parking\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::table_name[] =
  "\"Parking\"";

  void access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.parking);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.parking);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Parking\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Parking\" (\n"
                      "  \"parking\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"start\" REAL,\n"
                      "  \"end\" REAL,\n"
                      "  \"space\" INTEGER NOT NULL,\n"
                      "  \"time_in\" REAL,\n"
                      "  \"time_out\" REAL,\n"
                      "  \"hourly\" INTEGER NOT NULL,\n"
                      "  \"daily\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Parking_parking_i\"\n"
                      "  ON \"Parking\" (\"parking\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Parking_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Parking, id_sqlite >::create_schema);

  // Location
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Location, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  const char alias_traits<  ::polaris::io::Zone,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Location, id_sqlite >::zone_tag>::
  table_name[] = "\"zone\"";

  access::object_traits_impl< ::polaris::io::Location, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.location_value,
        i.location_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // location
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // setback
    //
    t[4UL] = false;

    // zone
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // location
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.location_value;
      b[n].is_null = &i.location_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // setback
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_value;
    b[n].is_null = &i.setback_null;
    n++;

    // zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.zone_value;
    b[n].is_null = &i.zone_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // location
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.location;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.location_value,
        is_null,
        v);
      i.location_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // setback
    //
    {
      double const& v =
        o.setback;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_value,
        is_null,
        v);
      i.setback_null = is_null;
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Zone > const& v =
        o.zone;

      typedef object_traits< ::polaris::io::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.zone_value,
          is_null,
          id);
        i.zone_null = is_null;
      }
      else
        i.zone_null = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // location
    //
    {
      int& v =
        o.location;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.location_value,
        i.location_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // setback
    //
    {
      double& v =
        o.setback;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_value,
        i.setback_null);
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Zone >& v =
        o.zone;

      typedef object_traits< ::polaris::io::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Zone > > ptr_traits;

      if (i.zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.zone_value,
          i.zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Location, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Location, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Location\" ("
  "\"location\","
  "\"link\","
  "\"dir\","
  "\"offset\","
  "\"setback\","
  "\"zone\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Location, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Location\".\"location\","
  "\"Location\".\"link\","
  "\"Location\".\"dir\","
  "\"Location\".\"offset\","
  "\"Location\".\"setback\","
  "\"Location\".\"zone\""
  " FROM \"Location\""
  " WHERE \"Location\".\"location\"=?";

  const char access::object_traits_impl< ::polaris::io::Location, id_sqlite >::update_statement[] =
  "UPDATE \"Location\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"offset\"=?,"
  "\"setback\"=?,"
  "\"zone\"=?"
  " WHERE \"location\"=?";

  const char access::object_traits_impl< ::polaris::io::Location, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Location\""
  " WHERE \"location\"=?";

  const char access::object_traits_impl< ::polaris::io::Location, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Location\".\"location\","
  "\"Location\".\"link\","
  "\"Location\".\"dir\","
  "\"Location\".\"offset\","
  "\"Location\".\"setback\","
  "\"Location\".\"zone\""
  " FROM \"Location\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Location\".\"link\""
  " LEFT JOIN \"Zone\" AS \"zone\" ON \"zone\".\"zone\"=\"Location\".\"zone\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Location, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Location\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Location, id_sqlite >::table_name[] =
  "\"Location\"";

  void access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.location);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Location, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.location);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Location, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Location, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Location\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Location\" (\n"
                      "  \"location\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"setback\" REAL,\n"
                      "  \"zone\" INTEGER,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"zone_fk\"\n"
                      "    FOREIGN KEY (\"zone\")\n"
                      "    REFERENCES \"Zone\" (\"zone\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Location_location_i\"\n"
                      "  ON \"Location\" (\"location\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Location_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Location, id_sqlite >::create_schema);

  // Access
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Access, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  access::object_traits_impl< ::polaris::io::Access, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // from_id
    //
    t[2UL] = false;

    // from_type
    //
    t[3UL] = false;

    // to_id
    //
    t[4UL] = false;

    // to_type
    //
    t[5UL] = false;

    // dir
    //
    t[6UL] = false;

    // time
    //
    t[7UL] = false;

    // cost
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // from_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_id_value;
    b[n].is_null = &i.from_id_null;
    n++;

    // from_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_type_value;
    b[n].is_null = &i.from_type_null;
    n++;

    // to_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_id_value;
    b[n].is_null = &i.to_id_null;
    n++;

    // to_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_type_value;
    b[n].is_null = &i.to_type_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // cost
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cost_value;
    b[n].is_null = &i.cost_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // from_id
    //
    {
      int const& v =
        o.from_id;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_id_value,
        is_null,
        v);
      i.from_id_null = is_null;
    }

    // from_type
    //
    {
      int const& v =
        o.from_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_type_value,
        is_null,
        v);
      i.from_type_null = is_null;
    }

    // to_id
    //
    {
      int const& v =
        o.to_id;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_id_value,
        is_null,
        v);
      i.to_id_null = is_null;
    }

    // to_type
    //
    {
      int const& v =
        o.to_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_type_value,
        is_null,
        v);
      i.to_type_null = is_null;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // cost
    //
    {
      int const& v =
        o.cost;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cost_value,
        is_null,
        v);
      i.cost_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // from_id
    //
    {
      int& v =
        o.from_id;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_id_value,
        i.from_id_null);
    }

    // from_type
    //
    {
      int& v =
        o.from_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_type_value,
        i.from_type_null);
    }

    // to_id
    //
    {
      int& v =
        o.to_id;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_id_value,
        i.to_id_null);
    }

    // to_type
    //
    {
      int& v =
        o.to_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_type_value,
        i.to_type_null);
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // cost
    //
    {
      int& v =
        o.cost;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cost_value,
        i.cost_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Access, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Access, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Access\" ("
  "\"auto_id\","
  "\"link\","
  "\"from_id\","
  "\"from_type\","
  "\"to_id\","
  "\"to_type\","
  "\"dir\","
  "\"time\","
  "\"cost\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Access, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Access\".\"auto_id\","
  "\"Access\".\"link\","
  "\"Access\".\"from_id\","
  "\"Access\".\"from_type\","
  "\"Access\".\"to_id\","
  "\"Access\".\"to_type\","
  "\"Access\".\"dir\","
  "\"Access\".\"time\","
  "\"Access\".\"cost\""
  " FROM \"Access\""
  " WHERE \"Access\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Access, id_sqlite >::update_statement[] =
  "UPDATE \"Access\" SET "
  "\"link\"=?,"
  "\"from_id\"=?,"
  "\"from_type\"=?,"
  "\"to_id\"=?,"
  "\"to_type\"=?,"
  "\"dir\"=?,"
  "\"time\"=?,"
  "\"cost\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Access, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Access\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Access, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Access\".\"auto_id\","
  "\"Access\".\"link\","
  "\"Access\".\"from_id\","
  "\"Access\".\"from_type\","
  "\"Access\".\"to_id\","
  "\"Access\".\"to_type\","
  "\"Access\".\"dir\","
  "\"Access\".\"time\","
  "\"Access\".\"cost\""
  " FROM \"Access\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Access\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Access, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Access\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Access, id_sqlite >::table_name[] =
  "\"Access\"";

  void access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Access, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Access, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Access, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Access\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Access\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"from_id\" INTEGER NOT NULL,\n"
                      "  \"from_type\" INTEGER NOT NULL,\n"
                      "  \"to_id\" INTEGER NOT NULL,\n"
                      "  \"to_type\" INTEGER NOT NULL,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"time\" REAL,\n"
                      "  \"cost\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Access_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Access, id_sqlite >::create_schema);

  // Sign
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // sign
    //
    if (t[3UL])
    {
      i.sign_value.capacity (i.sign_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // sign
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.sign_value.data ();
    b[n].size = &i.sign_size;
    b[n].capacity = i.sign_value.capacity ();
    b[n].is_null = &i.sign_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // sign
    //
    {
      ::std::string const& v =
        o.sign;

      bool is_null (false);
      std::size_t cap (i.sign_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.sign_value,
        i.sign_size,
        is_null,
        v);
      i.sign_null = is_null;
      grew = grew || (cap != i.sign_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // sign
    //
    {
      ::std::string& v =
        o.sign;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.sign_value,
        i.sign_size,
        i.sign_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Sign\" ("
  "\"auto_id\","
  "\"link\","
  "\"dir\","
  "\"sign\")"
  " VALUES (?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Sign\".\"auto_id\","
  "\"Sign\".\"link\","
  "\"Sign\".\"dir\","
  "\"Sign\".\"sign\""
  " FROM \"Sign\""
  " WHERE \"Sign\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::update_statement[] =
  "UPDATE \"Sign\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"sign\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Sign\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Sign\".\"auto_id\","
  "\"Sign\".\"link\","
  "\"Sign\".\"dir\","
  "\"Sign\".\"sign\""
  " FROM \"Sign\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Sign\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Sign\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::table_name[] =
  "\"Sign\"";

  void access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Sign\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Sign\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"sign\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Sign_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Sign, id_sqlite >::create_schema);

  // Signal
  //

  const char alias_traits<  ::polaris::io::Node,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nodes_tag>::
  table_name[] = "\"nodes\"";

  // nested_records
  //

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  select_statement[] =
  "SELECT "
  "\"Signal_nested_records\".\"index\","
  "\"Signal_nested_records\".\"value_start\","
  "\"Signal_nested_records\".\"value_end\","
  "\"Signal_nested_records\".\"value_timing\","
  "\"Signal_nested_records\".\"value_phasing\""
  " FROM \"Signal_nested_records\""
  " WHERE \"Signal_nested_records\".\"object_id\"=?"
  " ORDER BY \"Signal_nested_records\".\"index\"";

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  insert_statement[] =
  "INSERT INTO \"Signal_nested_records\" ("
  "\"object_id\","
  "\"index\","
  "\"value_start\","
  "\"value_end\","
  "\"value_timing\","
  "\"value_phasing\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  delete_statement[] =
  "DELETE FROM \"Signal_nested_records\""
  " WHERE \"object_id\"=?";

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_sqlite >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  grow (data_image_type& i, bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    if (composite_value_traits< value_type, id_sqlite >::grow (
          i.value_value, t + 1UL))
    {
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  init (data_image_type& i, index_type* j, const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      composite_value_traits< value_type, id_sqlite >::init (
        i.value_value,
        v,
        sk);
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  init (index_type& j, value_type& v, const data_image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_sqlite >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());
    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  persist (const container_type& c, statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  load (container_type& c, statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  update (const container_type& c, statements_type& sts)
  {
    using namespace sqlite;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::nested_records_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.signal_value,
        i.signal_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // signal
    //
    t[0UL] = false;

    // group
    //
    t[1UL] = false;

    // times
    //
    t[2UL] = false;

    // nodes
    //
    t[3UL] = false;

    // type
    //
    if (t[4UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    // offset
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // signal
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.signal_value;
      b[n].is_null = &i.signal_null;
      n++;
    }

    // group
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.group_value;
    b[n].is_null = &i.group_null;
    n++;

    // times
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.times_value;
    b[n].is_null = &i.times_null;
    n++;

    // nodes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.nodes_value;
    b[n].is_null = &i.nodes_null;
    n++;

    // type
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.type_value.data ();
    b[n].size = &i.type_size;
    b[n].capacity = i.type_value.capacity ();
    b[n].is_null = &i.type_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // signal
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.signal;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.signal_value,
        is_null,
        v);
      i.signal_null = is_null;
    }

    // group
    //
    {
      int const& v =
        o.group;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.group_value,
        is_null,
        v);
      i.group_null = is_null;
    }

    // times
    //
    {
      int const& v =
        o.times;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.times_value,
        is_null,
        v);
      i.times_null = is_null;
    }

    // nodes
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node > const& v =
        o.nodes;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.nodes_value,
          is_null,
          id);
        i.nodes_null = is_null;
      }
      else
        i.nodes_null = true;
    }

    // type
    //
    {
      ::std::string const& v =
        o.type;

      bool is_null (false);
      std::size_t cap (i.type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.type_value,
        i.type_size,
        is_null,
        v);
      i.type_null = is_null;
      grew = grew || (cap != i.type_value.capacity ());
    }

    // offset
    //
    {
      int const& v =
        o.offset;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // signal
    //
    {
      int& v =
        o.signal;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.signal_value,
        i.signal_null);
    }

    // group
    //
    {
      int& v =
        o.group;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.group_value,
        i.group_null);
    }

    // times
    //
    {
      int& v =
        o.times;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.times_value,
        i.times_null);
    }

    // nodes
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node >& v =
        o.nodes;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      if (i.nodes_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.nodes_value,
          i.nodes_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      ::std::string& v =
        o.type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.type_value,
        i.type_size,
        i.type_null);
    }

    // offset
    //
    {
      int& v =
        o.offset;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::container_statement_cache_type
  {
    sqlite::container_statements_impl< nested_records_traits > nested_records;

    container_statement_cache_type (
      sqlite::connection& c,
      sqlite::binding& id)
    : nested_records (c, id)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Signal\" ("
  "\"signal\","
  "\"group\","
  "\"times\","
  "\"nodes\","
  "\"type\","
  "\"offset\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Signal\".\"signal\","
  "\"Signal\".\"group\","
  "\"Signal\".\"times\","
  "\"Signal\".\"nodes\","
  "\"Signal\".\"type\","
  "\"Signal\".\"offset\""
  " FROM \"Signal\""
  " WHERE \"Signal\".\"signal\"=?";

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::update_statement[] =
  "UPDATE \"Signal\" SET "
  "\"group\"=?,"
  "\"times\"=?,"
  "\"nodes\"=?,"
  "\"type\"=?,"
  "\"offset\"=?"
  " WHERE \"signal\"=?";

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Signal\""
  " WHERE \"signal\"=?";

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Signal\".\"signal\","
  "\"Signal\".\"group\","
  "\"Signal\".\"times\","
  "\"Signal\".\"nodes\","
  "\"Signal\".\"type\","
  "\"Signal\".\"offset\""
  " FROM \"Signal\""
  " LEFT JOIN \"Node\" AS \"nodes\" ON \"nodes\".\"node\"=\"Signal\".\"nodes\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Signal\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::table_name[] =
  "\"Signal\"";

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    id_image_type& i (sts.id_image ());
    init (i, obj.signal);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    {
      ::std::vector< ::polaris::io::signal_time > const& v =
        obj.nested_records;

      nested_records_traits::persist (
        v,
        sts.container_statment_cache ().nested_records);
    }

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.signal);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    // nested_records
    //
    {
      ::std::vector< ::polaris::io::signal_time > const& v =
        obj.nested_records;

      nested_records_traits::update (
        v,
        sts.container_statment_cache ().nested_records);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    nested_records_traits::erase (
      sts.container_statment_cache ().nested_records);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.signal);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  load_ (statements_type& sts, object_type& obj)
  {
    // nested_records
    //
    {
      ::std::vector< ::polaris::io::signal_time >& v =
        obj.nested_records;

      nested_records_traits::load (
        v,
        sts.container_statment_cache ().nested_records);
    }
  }

  result< access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Signal_nested_records\"");
          db.execute ("DROP TABLE IF EXISTS \"Signal\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Signal\" (\n"
                      "  \"signal\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"group\" INTEGER NOT NULL,\n"
                      "  \"times\" INTEGER NOT NULL,\n"
                      "  \"nodes\" INTEGER,\n"
                      "  \"type\" TEXT NOT NULL,\n"
                      "  \"offset\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"nodes_fk\"\n"
                      "    FOREIGN KEY (\"nodes\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Signal_signal_i\"\n"
                      "  ON \"Signal\" (\"signal\")");
          db.execute ("CREATE TABLE \"Signal_nested_records\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value_start\" REAL,\n"
                      "  \"value_end\" REAL,\n"
                      "  \"value_timing\" INTEGER NOT NULL,\n"
                      "  \"value_phasing\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"Signal\" (\"signal\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"Signal_nested_records_object_id_i\"\n"
                      "  ON \"Signal_nested_records\" (\"object_id\")");
          db.execute ("CREATE INDEX \"Signal_nested_records_index_i\"\n"
                      "  ON \"Signal_nested_records\" (\"index\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Signal_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Signal, id_sqlite >::create_schema);

  // Timing
  //

  const char alias_traits<  ::polaris::io::Signal,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::signal_tag>::
  table_name[] = "\"signal\"";

  // nested_records
  //

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  select_statement[] =
  "SELECT "
  "\"Timing_nested_records\".\"index\","
  "\"Timing_nested_records\".\"value_phase\","
  "\"Timing_nested_records\".\"value_barrier\","
  "\"Timing_nested_records\".\"value_ring\","
  "\"Timing_nested_records\".\"value_position\","
  "\"Timing_nested_records\".\"value_minimum\","
  "\"Timing_nested_records\".\"value_maximum\","
  "\"Timing_nested_records\".\"value_extend\","
  "\"Timing_nested_records\".\"value_yellow\","
  "\"Timing_nested_records\".\"value_red\""
  " FROM \"Timing_nested_records\""
  " WHERE \"Timing_nested_records\".\"object_id\"=?"
  " ORDER BY \"Timing_nested_records\".\"index\"";

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  insert_statement[] =
  "INSERT INTO \"Timing_nested_records\" ("
  "\"object_id\","
  "\"index\","
  "\"value_phase\","
  "\"value_barrier\","
  "\"value_ring\","
  "\"value_position\","
  "\"value_minimum\","
  "\"value_maximum\","
  "\"value_extend\","
  "\"value_yellow\","
  "\"value_red\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  delete_statement[] =
  "DELETE FROM \"Timing_nested_records\""
  " WHERE \"object_id\"=?";

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_sqlite >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  grow (data_image_type& i, bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    if (composite_value_traits< value_type, id_sqlite >::grow (
          i.value_value, t + 1UL))
    {
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  init (data_image_type& i, index_type* j, const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      composite_value_traits< value_type, id_sqlite >::init (
        i.value_value,
        v,
        sk);
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  init (index_type& j, value_type& v, const data_image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_sqlite >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());
    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  persist (const container_type& c, statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  load (container_type& c, statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  update (const container_type& c, statements_type& sts)
  {
    using namespace sqlite;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::nested_records_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // signal
    //
    t[1UL] = false;

    // timing
    //
    t[2UL] = false;

    // type
    //
    t[3UL] = false;

    // cycle
    //
    t[4UL] = false;

    // offset
    //
    t[5UL] = false;

    // phases
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // signal
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signal_value;
    b[n].is_null = &i.signal_null;
    n++;

    // timing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timing_value;
    b[n].is_null = &i.timing_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // cycle
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cycle_value;
    b[n].is_null = &i.cycle_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // phases
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phases_value;
    b[n].is_null = &i.phases_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Signal > const& v =
        o.signal;

      typedef object_traits< ::polaris::io::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Signal > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.signal_value,
          is_null,
          id);
        i.signal_null = is_null;
      }
      else
        i.signal_null = true;
    }

    // timing
    //
    {
      int const& v =
        o.timing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.timing_value,
        is_null,
        v);
      i.timing_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // cycle
    //
    {
      int const& v =
        o.cycle;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cycle_value,
        is_null,
        v);
      i.cycle_null = is_null;
    }

    // offset
    //
    {
      int const& v =
        o.offset;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // phases
    //
    {
      int const& v =
        o.phases;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phases_value,
        is_null,
        v);
      i.phases_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Signal >& v =
        o.signal;

      typedef object_traits< ::polaris::io::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Signal > > ptr_traits;

      if (i.signal_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.signal_value,
          i.signal_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // timing
    //
    {
      int& v =
        o.timing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.timing_value,
        i.timing_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // cycle
    //
    {
      int& v =
        o.cycle;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cycle_value,
        i.cycle_null);
    }

    // offset
    //
    {
      int& v =
        o.offset;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // phases
    //
    {
      int& v =
        o.phases;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phases_value,
        i.phases_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::container_statement_cache_type
  {
    sqlite::container_statements_impl< nested_records_traits > nested_records;

    container_statement_cache_type (
      sqlite::connection& c,
      sqlite::binding& id)
    : nested_records (c, id)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Timing\" ("
  "\"auto_id\","
  "\"signal\","
  "\"timing\","
  "\"type\","
  "\"cycle\","
  "\"offset\","
  "\"phases\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Timing\".\"auto_id\","
  "\"Timing\".\"signal\","
  "\"Timing\".\"timing\","
  "\"Timing\".\"type\","
  "\"Timing\".\"cycle\","
  "\"Timing\".\"offset\","
  "\"Timing\".\"phases\""
  " FROM \"Timing\""
  " WHERE \"Timing\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::update_statement[] =
  "UPDATE \"Timing\" SET "
  "\"signal\"=?,"
  "\"timing\"=?,"
  "\"type\"=?,"
  "\"cycle\"=?,"
  "\"offset\"=?,"
  "\"phases\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Timing\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Timing\".\"auto_id\","
  "\"Timing\".\"signal\","
  "\"Timing\".\"timing\","
  "\"Timing\".\"type\","
  "\"Timing\".\"cycle\","
  "\"Timing\".\"offset\","
  "\"Timing\".\"phases\""
  " FROM \"Timing\""
  " LEFT JOIN \"Signal\" AS \"signal\" ON \"signal\".\"signal\"=\"Timing\".\"signal\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Timing\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::table_name[] =
  "\"Timing\"";

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    {
      ::std::vector< ::polaris::io::timing_phase > const& v =
        obj.nested_records;

      nested_records_traits::persist (
        v,
        sts.container_statment_cache ().nested_records);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    // nested_records
    //
    {
      ::std::vector< ::polaris::io::timing_phase > const& v =
        obj.nested_records;

      nested_records_traits::update (
        v,
        sts.container_statment_cache ().nested_records);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    nested_records_traits::erase (
      sts.container_statment_cache ().nested_records);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  load_ (statements_type& sts, object_type& obj)
  {
    // nested_records
    //
    {
      ::std::vector< ::polaris::io::timing_phase >& v =
        obj.nested_records;

      nested_records_traits::load (
        v,
        sts.container_statment_cache ().nested_records);
    }
  }

  result< access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Timing_nested_records\"");
          db.execute ("DROP TABLE IF EXISTS \"Timing\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Timing\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"signal\" INTEGER,\n"
                      "  \"timing\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"cycle\" INTEGER NOT NULL,\n"
                      "  \"offset\" INTEGER NOT NULL,\n"
                      "  \"phases\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"signal_fk\"\n"
                      "    FOREIGN KEY (\"signal\")\n"
                      "    REFERENCES \"Signal\" (\"signal\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"Timing_nested_records\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value_phase\" INTEGER NOT NULL,\n"
                      "  \"value_barrier\" INTEGER NOT NULL,\n"
                      "  \"value_ring\" INTEGER NOT NULL,\n"
                      "  \"value_position\" INTEGER NOT NULL,\n"
                      "  \"value_minimum\" INTEGER NOT NULL,\n"
                      "  \"value_maximum\" INTEGER NOT NULL,\n"
                      "  \"value_extend\" INTEGER NOT NULL,\n"
                      "  \"value_yellow\" INTEGER NOT NULL,\n"
                      "  \"value_red\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"Timing\" (\"auto_id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"Timing_nested_records_object_id_i\"\n"
                      "  ON \"Timing_nested_records\" (\"object_id\")");
          db.execute ("CREATE INDEX \"Timing_nested_records_index_i\"\n"
                      "  ON \"Timing_nested_records\" (\"index\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Timing_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Timing, id_sqlite >::create_schema);

  // Phasing
  //

  const char alias_traits<  ::polaris::io::Signal,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::signal_tag>::
  table_name[] = "\"signal\"";

  // nested_records
  //

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  select_statement[] =
  "SELECT "
  "\"Phasing_nested_records\".\"index\","
  "\"Phasing_nested_records\".\"value_movement\","
  "\"Phasing_nested_records\".\"value_link\","
  "\"Phasing_nested_records\".\"value_dir\","
  "\"Phasing_nested_records\".\"value_to_link\","
  "\"Phasing_nested_records\".\"value_protect\""
  " FROM \"Phasing_nested_records\""
  " WHERE \"Phasing_nested_records\".\"object_id\"=?"
  " ORDER BY \"Phasing_nested_records\".\"index\"";

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  insert_statement[] =
  "INSERT INTO \"Phasing_nested_records\" ("
  "\"object_id\","
  "\"index\","
  "\"value_movement\","
  "\"value_link\","
  "\"value_dir\","
  "\"value_to_link\","
  "\"value_protect\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  delete_statement[] =
  "DELETE FROM \"Phasing_nested_records\""
  " WHERE \"object_id\"=?";

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_sqlite >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  grow (data_image_type& i, bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    if (composite_value_traits< value_type, id_sqlite >::grow (
          i.value_value, t + 1UL))
    {
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  init (data_image_type& i, index_type* j, const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_sqlite >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  init (index_type& j, value_type& v, const data_image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_sqlite >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());
    init (i, v, di, &sts.connection ().database ());

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  persist (const container_type& c, statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  load (container_type& c, statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  update (const container_type& c, statements_type& sts)
  {
    using namespace sqlite;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::nested_records_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // signal
    //
    t[1UL] = false;

    // phasing
    //
    t[2UL] = false;

    // phase
    //
    t[3UL] = false;

    // detectors
    //
    if (t[4UL])
    {
      i.detectors_value.capacity (i.detectors_size);
      grew = true;
    }

    // movements
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // signal
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signal_value;
    b[n].is_null = &i.signal_null;
    n++;

    // phasing
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phasing_value;
    b[n].is_null = &i.phasing_null;
    n++;

    // phase
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.phase_value;
    b[n].is_null = &i.phase_null;
    n++;

    // detectors
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.detectors_value.data ();
    b[n].size = &i.detectors_size;
    b[n].capacity = i.detectors_value.capacity ();
    b[n].is_null = &i.detectors_null;
    n++;

    // movements
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.movements_value;
    b[n].is_null = &i.movements_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Signal > const& v =
        o.signal;

      typedef object_traits< ::polaris::io::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Signal > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.signal_value,
          is_null,
          id);
        i.signal_null = is_null;
      }
      else
        i.signal_null = true;
    }

    // phasing
    //
    {
      int const& v =
        o.phasing;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phasing_value,
        is_null,
        v);
      i.phasing_null = is_null;
    }

    // phase
    //
    {
      int const& v =
        o.phase;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.phase_value,
        is_null,
        v);
      i.phase_null = is_null;
    }

    // detectors
    //
    {
      ::std::string const& v =
        o.detectors;

      bool is_null (false);
      std::size_t cap (i.detectors_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.detectors_value,
        i.detectors_size,
        is_null,
        v);
      i.detectors_null = is_null;
      grew = grew || (cap != i.detectors_value.capacity ());
    }

    // movements
    //
    {
      int const& v =
        o.movements;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.movements_value,
        is_null,
        v);
      i.movements_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // signal
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Signal >& v =
        o.signal;

      typedef object_traits< ::polaris::io::Signal > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Signal > > ptr_traits;

      if (i.signal_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.signal_value,
          i.signal_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // phasing
    //
    {
      int& v =
        o.phasing;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phasing_value,
        i.phasing_null);
    }

    // phase
    //
    {
      int& v =
        o.phase;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.phase_value,
        i.phase_null);
    }

    // detectors
    //
    {
      ::std::string& v =
        o.detectors;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.detectors_value,
        i.detectors_size,
        i.detectors_null);
    }

    // movements
    //
    {
      int& v =
        o.movements;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.movements_value,
        i.movements_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::container_statement_cache_type
  {
    sqlite::container_statements_impl< nested_records_traits > nested_records;

    container_statement_cache_type (
      sqlite::connection& c,
      sqlite::binding& id)
    : nested_records (c, id)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Phasing\" ("
  "\"auto_id\","
  "\"signal\","
  "\"phasing\","
  "\"phase\","
  "\"detectors\","
  "\"movements\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Phasing\".\"auto_id\","
  "\"Phasing\".\"signal\","
  "\"Phasing\".\"phasing\","
  "\"Phasing\".\"phase\","
  "\"Phasing\".\"detectors\","
  "\"Phasing\".\"movements\""
  " FROM \"Phasing\""
  " WHERE \"Phasing\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::update_statement[] =
  "UPDATE \"Phasing\" SET "
  "\"signal\"=?,"
  "\"phasing\"=?,"
  "\"phase\"=?,"
  "\"detectors\"=?,"
  "\"movements\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Phasing\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Phasing\".\"auto_id\","
  "\"Phasing\".\"signal\","
  "\"Phasing\".\"phasing\","
  "\"Phasing\".\"phase\","
  "\"Phasing\".\"detectors\","
  "\"Phasing\".\"movements\""
  " FROM \"Phasing\""
  " LEFT JOIN \"Signal\" AS \"signal\" ON \"signal\".\"signal\"=\"Phasing\".\"signal\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Phasing\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::table_name[] =
  "\"Phasing\"";

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    {
      ::std::vector< ::polaris::io::phase_movement > const& v =
        obj.nested_records;

      nested_records_traits::persist (
        v,
        sts.container_statment_cache ().nested_records);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    // nested_records
    //
    {
      ::std::vector< ::polaris::io::phase_movement > const& v =
        obj.nested_records;

      nested_records_traits::update (
        v,
        sts.container_statment_cache ().nested_records);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    // nested_records
    //
    nested_records_traits::erase (
      sts.container_statment_cache ().nested_records);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  load_ (statements_type& sts, object_type& obj)
  {
    // nested_records
    //
    {
      ::std::vector< ::polaris::io::phase_movement >& v =
        obj.nested_records;

      nested_records_traits::load (
        v,
        sts.container_statment_cache ().nested_records);
    }
  }

  result< access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Phasing_nested_records\"");
          db.execute ("DROP TABLE IF EXISTS \"Phasing\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Phasing\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"signal\" INTEGER,\n"
                      "  \"phasing\" INTEGER NOT NULL,\n"
                      "  \"phase\" INTEGER NOT NULL,\n"
                      "  \"detectors\" TEXT NOT NULL,\n"
                      "  \"movements\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"signal_fk\"\n"
                      "    FOREIGN KEY (\"signal\")\n"
                      "    REFERENCES \"Signal\" (\"signal\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"Phasing_nested_records\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value_movement\" TEXT NOT NULL,\n"
                      "  \"value_link\" INTEGER,\n"
                      "  \"value_dir\" INTEGER NOT NULL,\n"
                      "  \"value_to_link\" INTEGER,\n"
                      "  \"value_protect\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"Phasing\" (\"auto_id\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"value_link_fk\"\n"
                      "    FOREIGN KEY (\"value_link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"value_to_link_fk\"\n"
                      "    FOREIGN KEY (\"value_to_link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Phasing_nested_records_object_id_i\"\n"
                      "  ON \"Phasing_nested_records\" (\"object_id\")");
          db.execute ("CREATE INDEX \"Phasing_nested_records_index_i\"\n"
                      "  ON \"Phasing_nested_records\" (\"index\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Phasing_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Phasing, id_sqlite >::create_schema);

  // Detector
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.detector_value,
        i.detector_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // detector
    //
    t[0UL] = false;

    // link
    //
    t[1UL] = false;

    // dir
    //
    t[2UL] = false;

    // offset
    //
    t[3UL] = false;

    // length
    //
    t[4UL] = false;

    // lanes
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // use
    //
    t[7UL] = false;

    // low
    //
    t[8UL] = false;

    // high
    //
    t[9UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // detector
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.detector_value;
      b[n].is_null = &i.detector_null;
      n++;
    }

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // lanes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_value;
    b[n].is_null = &i.lanes_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // low
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.low_value;
    b[n].is_null = &i.low_null;
    n++;

    // high
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.high_value;
    b[n].is_null = &i.high_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // detector
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.detector;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.detector_value,
        is_null,
        v);
      i.detector_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // lanes
    //
    {
      int const& v =
        o.lanes;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_value,
        is_null,
        v);
      i.lanes_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // low
    //
    {
      int const& v =
        o.low;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.low_value,
        is_null,
        v);
      i.low_null = is_null;
    }

    // high
    //
    {
      int const& v =
        o.high;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.high_value,
        is_null,
        v);
      i.high_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // detector
    //
    {
      int& v =
        o.detector;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.detector_value,
        i.detector_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // lanes
    //
    {
      int& v =
        o.lanes;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_value,
        i.lanes_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // low
    //
    {
      int& v =
        o.low;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.low_value,
        i.low_null);
    }

    // high
    //
    {
      int& v =
        o.high;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.high_value,
        i.high_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Detector\" ("
  "\"detector\","
  "\"link\","
  "\"dir\","
  "\"offset\","
  "\"length\","
  "\"lanes\","
  "\"type\","
  "\"use\","
  "\"low\","
  "\"high\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Detector\".\"detector\","
  "\"Detector\".\"link\","
  "\"Detector\".\"dir\","
  "\"Detector\".\"offset\","
  "\"Detector\".\"length\","
  "\"Detector\".\"lanes\","
  "\"Detector\".\"type\","
  "\"Detector\".\"use\","
  "\"Detector\".\"low\","
  "\"Detector\".\"high\""
  " FROM \"Detector\""
  " WHERE \"Detector\".\"detector\"=?";

  const char access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::update_statement[] =
  "UPDATE \"Detector\" SET "
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"offset\"=?,"
  "\"length\"=?,"
  "\"lanes\"=?,"
  "\"type\"=?,"
  "\"use\"=?,"
  "\"low\"=?,"
  "\"high\"=?"
  " WHERE \"detector\"=?";

  const char access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Detector\""
  " WHERE \"detector\"=?";

  const char access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Detector\".\"detector\","
  "\"Detector\".\"link\","
  "\"Detector\".\"dir\","
  "\"Detector\".\"offset\","
  "\"Detector\".\"length\","
  "\"Detector\".\"lanes\","
  "\"Detector\".\"type\","
  "\"Detector\".\"use\","
  "\"Detector\".\"low\","
  "\"Detector\".\"high\""
  " FROM \"Detector\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Detector\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Detector\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::table_name[] =
  "\"Detector\"";

  void access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.detector);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.detector);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Detector\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Detector\" (\n"
                      "  \"detector\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"length\" REAL,\n"
                      "  \"lanes\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"low\" INTEGER NOT NULL,\n"
                      "  \"high\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Detector_detector_i\"\n"
                      "  ON \"Detector\" (\"detector\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Detector_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Detector, id_sqlite >::create_schema);

  // Stop
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.stop_value,
        i.stop_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // stop
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // link
    //
    t[2UL] = false;

    // dir
    //
    t[3UL] = false;

    // offset
    //
    t[4UL] = false;

    // use
    //
    t[5UL] = false;

    // type
    //
    t[6UL] = false;

    // space
    //
    t[7UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // stop
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.stop_value;
      b[n].is_null = &i.stop_null;
      n++;
    }

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;

    // offset
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.offset_value;
    b[n].is_null = &i.offset_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // space
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.space_value;
    b[n].is_null = &i.space_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // stop
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.stop;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.stop_value,
        is_null,
        v);
      i.stop_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    // offset
    //
    {
      double const& v =
        o.offset;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.offset_value,
        is_null,
        v);
      i.offset_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // space
    //
    {
      int const& v =
        o.space;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.space_value,
        is_null,
        v);
      i.space_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // stop
    //
    {
      int& v =
        o.stop;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.stop_value,
        i.stop_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }

    // offset
    //
    {
      double& v =
        o.offset;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.offset_value,
        i.offset_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // space
    //
    {
      int& v =
        o.space;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.space_value,
        i.space_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Stop\" ("
  "\"stop\","
  "\"name\","
  "\"link\","
  "\"dir\","
  "\"offset\","
  "\"use\","
  "\"type\","
  "\"space\")"
  " VALUES (?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Stop\".\"stop\","
  "\"Stop\".\"name\","
  "\"Stop\".\"link\","
  "\"Stop\".\"dir\","
  "\"Stop\".\"offset\","
  "\"Stop\".\"use\","
  "\"Stop\".\"type\","
  "\"Stop\".\"space\""
  " FROM \"Stop\""
  " WHERE \"Stop\".\"stop\"=?";

  const char access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::update_statement[] =
  "UPDATE \"Stop\" SET "
  "\"name\"=?,"
  "\"link\"=?,"
  "\"dir\"=?,"
  "\"offset\"=?,"
  "\"use\"=?,"
  "\"type\"=?,"
  "\"space\"=?"
  " WHERE \"stop\"=?";

  const char access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Stop\""
  " WHERE \"stop\"=?";

  const char access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Stop\".\"stop\","
  "\"Stop\".\"name\","
  "\"Stop\".\"link\","
  "\"Stop\".\"dir\","
  "\"Stop\".\"offset\","
  "\"Stop\".\"use\","
  "\"Stop\".\"type\","
  "\"Stop\".\"space\""
  " FROM \"Stop\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Stop\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Stop\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::table_name[] =
  "\"Stop\"";

  void access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.stop);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.stop);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Stop\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Stop\" (\n"
                      "  \"stop\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  \"offset\" REAL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"space\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Stop_stop_i\"\n"
                      "  ON \"Stop\" (\"stop\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Stop_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Stop, id_sqlite >::create_schema);

  // Fare
  //

  const char alias_traits<  ::polaris::io::Zone,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::from_zone_tag>::
  table_name[] = "\"from_zone\"";

  const char alias_traits<  ::polaris::io::Zone,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::to_zone_tag>::
  table_name[] = "\"to_zone\"";

  access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.fare_value,
        i.fare_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // from_zone
    //
    t[0UL] = false;

    // to_zone
    //
    t[1UL] = false;

    // from_mode
    //
    t[2UL] = false;

    // to_mode
    //
    t[3UL] = false;

    // period
    //
    t[4UL] = false;

    // type
    //
    t[5UL] = false;

    // fare
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // from_zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_zone_value;
    b[n].is_null = &i.from_zone_null;
    n++;

    // to_zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_zone_value;
    b[n].is_null = &i.to_zone_null;
    n++;

    // from_mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.from_mode_value;
    b[n].is_null = &i.from_mode_null;
    n++;

    // to_mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.to_mode_value;
    b[n].is_null = &i.to_mode_null;
    n++;

    // period
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.period_value;
    b[n].is_null = &i.period_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // fare
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.fare_value;
      b[n].is_null = &i.fare_null;
      n++;
    }
  }

  void access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // from_zone
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Zone > const& v =
        o.from_zone;

      typedef object_traits< ::polaris::io::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.from_zone_value,
          is_null,
          id);
        i.from_zone_null = is_null;
      }
      else
        i.from_zone_null = true;
    }

    // to_zone
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Zone > const& v =
        o.to_zone;

      typedef object_traits< ::polaris::io::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.to_zone_value,
          is_null,
          id);
        i.to_zone_null = is_null;
      }
      else
        i.to_zone_null = true;
    }

    // from_mode
    //
    {
      int const& v =
        o.from_mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.from_mode_value,
        is_null,
        v);
      i.from_mode_null = is_null;
    }

    // to_mode
    //
    {
      int const& v =
        o.to_mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.to_mode_value,
        is_null,
        v);
      i.to_mode_null = is_null;
    }

    // period
    //
    {
      int const& v =
        o.period;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.period_value,
        is_null,
        v);
      i.period_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // fare
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.fare;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.fare_value,
        is_null,
        v);
      i.fare_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // from_zone
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Zone >& v =
        o.from_zone;

      typedef object_traits< ::polaris::io::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Zone > > ptr_traits;

      if (i.from_zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.from_zone_value,
          i.from_zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // to_zone
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Zone >& v =
        o.to_zone;

      typedef object_traits< ::polaris::io::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Zone > > ptr_traits;

      if (i.to_zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.to_zone_value,
          i.to_zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // from_mode
    //
    {
      int& v =
        o.from_mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.from_mode_value,
        i.from_mode_null);
    }

    // to_mode
    //
    {
      int& v =
        o.to_mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.to_mode_value,
        i.to_mode_null);
    }

    // period
    //
    {
      int& v =
        o.period;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.period_value,
        i.period_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // fare
    //
    {
      int& v =
        o.fare;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.fare_value,
        i.fare_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Fare\" ("
  "\"from_zone\","
  "\"to_zone\","
  "\"from_mode\","
  "\"to_mode\","
  "\"period\","
  "\"type\","
  "\"fare\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Fare\".\"from_zone\","
  "\"Fare\".\"to_zone\","
  "\"Fare\".\"from_mode\","
  "\"Fare\".\"to_mode\","
  "\"Fare\".\"period\","
  "\"Fare\".\"type\","
  "\"Fare\".\"fare\""
  " FROM \"Fare\""
  " WHERE \"Fare\".\"fare\"=?";

  const char access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::update_statement[] =
  "UPDATE \"Fare\" SET "
  "\"from_zone\"=?,"
  "\"to_zone\"=?,"
  "\"from_mode\"=?,"
  "\"to_mode\"=?,"
  "\"period\"=?,"
  "\"type\"=?"
  " WHERE \"fare\"=?";

  const char access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Fare\""
  " WHERE \"fare\"=?";

  const char access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Fare\".\"from_zone\","
  "\"Fare\".\"to_zone\","
  "\"Fare\".\"from_mode\","
  "\"Fare\".\"to_mode\","
  "\"Fare\".\"period\","
  "\"Fare\".\"type\","
  "\"Fare\".\"fare\""
  " FROM \"Fare\""
  " LEFT JOIN \"Zone\" AS \"from_zone\" ON \"from_zone\".\"zone\"=\"Fare\".\"from_zone\""
  " LEFT JOIN \"Zone\" AS \"to_zone\" ON \"to_zone\".\"zone\"=\"Fare\".\"to_zone\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Fare\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::table_name[] =
  "\"Fare\"";

  void access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.fare);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.fare);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Fare\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Fare\" (\n"
                      "  \"from_zone\" INTEGER,\n"
                      "  \"to_zone\" INTEGER,\n"
                      "  \"from_mode\" INTEGER NOT NULL,\n"
                      "  \"to_mode\" INTEGER NOT NULL,\n"
                      "  \"period\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"fare\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  CONSTRAINT \"from_zone_fk\"\n"
                      "    FOREIGN KEY (\"from_zone\")\n"
                      "    REFERENCES \"Zone\" (\"zone\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"to_zone_fk\"\n"
                      "    FOREIGN KEY (\"to_zone\")\n"
                      "    REFERENCES \"Zone\" (\"zone\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Fare_fare_i\"\n"
                      "  ON \"Fare\" (\"fare\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Fare_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Fare, id_sqlite >::create_schema);

  // Line
  //

  const char alias_traits<  ::polaris::io::Stop,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Line, id_sqlite >::stops_tag>::
  table_name[] = "\"stops\"";

  const char alias_traits<  ::polaris::io::Stop,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Line, id_sqlite >::stop_tag>::
  table_name[] = "\"stop\"";

  const char alias_traits<  ::polaris::io::Zone,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Line, id_sqlite >::zone_tag>::
  table_name[] = "\"zone\"";

  access::object_traits_impl< ::polaris::io::Line, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // stops
    //
    t[2UL] = false;

    // mode
    //
    t[3UL] = false;

    // type
    //
    t[4UL] = false;

    // name
    //
    if (t[5UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // stop
    //
    t[6UL] = false;

    // zone
    //
    t[7UL] = false;

    // flag
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // stops
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stops_value;
    b[n].is_null = &i.stops_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;

    // zone
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.zone_value;
    b[n].is_null = &i.zone_null;
    n++;

    // flag
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.flag_value;
    b[n].is_null = &i.flag_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop > const& v =
        o.stops;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stops_value,
          is_null,
          id);
        i.stops_null = is_null;
      }
      else
        i.stops_null = true;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop > const& v =
        o.stop;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Zone > const& v =
        o.zone;

      typedef object_traits< ::polaris::io::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Zone > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.zone_value,
          is_null,
          id);
        i.zone_null = is_null;
      }
      else
        i.zone_null = true;
    }

    // flag
    //
    {
      int const& v =
        o.flag;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.flag_value,
        is_null,
        v);
      i.flag_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop >& v =
        o.stops;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      if (i.stops_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stops_value,
          i.stops_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop >& v =
        o.stop;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // zone
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Zone >& v =
        o.zone;

      typedef object_traits< ::polaris::io::Zone > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Zone > > ptr_traits;

      if (i.zone_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.zone_value,
          i.zone_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // flag
    //
    {
      int& v =
        o.flag;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.flag_value,
        i.flag_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Line, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Line, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Line\" ("
  "\"auto_id\","
  "\"route\","
  "\"stops\","
  "\"mode\","
  "\"type\","
  "\"name\","
  "\"stop\","
  "\"zone\","
  "\"flag\")"
  " VALUES (?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Line, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Line\".\"auto_id\","
  "\"Line\".\"route\","
  "\"Line\".\"stops\","
  "\"Line\".\"mode\","
  "\"Line\".\"type\","
  "\"Line\".\"name\","
  "\"Line\".\"stop\","
  "\"Line\".\"zone\","
  "\"Line\".\"flag\""
  " FROM \"Line\""
  " WHERE \"Line\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Line, id_sqlite >::update_statement[] =
  "UPDATE \"Line\" SET "
  "\"route\"=?,"
  "\"stops\"=?,"
  "\"mode\"=?,"
  "\"type\"=?,"
  "\"name\"=?,"
  "\"stop\"=?,"
  "\"zone\"=?,"
  "\"flag\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Line, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Line\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Line, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Line\".\"auto_id\","
  "\"Line\".\"route\","
  "\"Line\".\"stops\","
  "\"Line\".\"mode\","
  "\"Line\".\"type\","
  "\"Line\".\"name\","
  "\"Line\".\"stop\","
  "\"Line\".\"zone\","
  "\"Line\".\"flag\""
  " FROM \"Line\""
  " LEFT JOIN \"Stop\" AS \"stops\" ON \"stops\".\"stop\"=\"Line\".\"stops\""
  " LEFT JOIN \"Stop\" AS \"stop\" ON \"stop\".\"stop\"=\"Line\".\"stop\""
  " LEFT JOIN \"Zone\" AS \"zone\" ON \"zone\".\"zone\"=\"Line\".\"zone\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Line, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Line\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Line, id_sqlite >::table_name[] =
  "\"Line\"";

  void access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Line, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Line, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Line, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Line\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Line\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"stops\" INTEGER,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"stop\" INTEGER,\n"
                      "  \"zone\" INTEGER,\n"
                      "  \"flag\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"stops_fk\"\n"
                      "    FOREIGN KEY (\"stops\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"stop_fk\"\n"
                      "    FOREIGN KEY (\"stop\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"zone_fk\"\n"
                      "    FOREIGN KEY (\"zone\")\n"
                      "    REFERENCES \"Zone\" (\"zone\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Line_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Line, id_sqlite >::create_schema);

  // Schedule
  //

  const char alias_traits<  ::polaris::io::Stop,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::stops_tag>::
  table_name[] = "\"stops\"";

  const char alias_traits<  ::polaris::io::Stop,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::stop_tag>::
  table_name[] = "\"stop\"";

  access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // stops
    //
    t[2UL] = false;

    // stop
    //
    t[3UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // stops
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stops_value;
    b[n].is_null = &i.stops_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop > const& v =
        o.stops;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stops_value,
          is_null,
          id);
        i.stops_null = is_null;
      }
      else
        i.stops_null = true;
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop > const& v =
        o.stop;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // stops
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop >& v =
        o.stops;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      if (i.stops_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stops_value,
          i.stops_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop >& v =
        o.stop;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Schedule\" ("
  "\"auto_id\","
  "\"route\","
  "\"stops\","
  "\"stop\")"
  " VALUES (?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Schedule\".\"auto_id\","
  "\"Schedule\".\"route\","
  "\"Schedule\".\"stops\","
  "\"Schedule\".\"stop\""
  " FROM \"Schedule\""
  " WHERE \"Schedule\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::update_statement[] =
  "UPDATE \"Schedule\" SET "
  "\"route\"=?,"
  "\"stops\"=?,"
  "\"stop\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Schedule\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Schedule\".\"auto_id\","
  "\"Schedule\".\"route\","
  "\"Schedule\".\"stops\","
  "\"Schedule\".\"stop\""
  " FROM \"Schedule\""
  " LEFT JOIN \"Stop\" AS \"stops\" ON \"stops\".\"stop\"=\"Schedule\".\"stops\""
  " LEFT JOIN \"Stop\" AS \"stop\" ON \"stop\".\"stop\"=\"Schedule\".\"stop\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Schedule\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::table_name[] =
  "\"Schedule\"";

  void access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Schedule\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Schedule\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"stops\" INTEGER,\n"
                      "  \"stop\" INTEGER,\n"
                      "  CONSTRAINT \"stops_fk\"\n"
                      "    FOREIGN KEY (\"stops\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"stop_fk\"\n"
                      "    FOREIGN KEY (\"stop\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Schedule_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Schedule, id_sqlite >::create_schema);

  // Driver
  //

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::links_tag>::
  table_name[] = "\"links\"";

  const char alias_traits<  ::polaris::io::Link,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::link_tag>::
  table_name[] = "\"link\"";

  access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // links
    //
    t[2UL] = false;

    // type
    //
    t[3UL] = false;

    // subtype
    //
    t[4UL] = false;

    // link
    //
    t[5UL] = false;

    // dir
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // links
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.links_value;
    b[n].is_null = &i.links_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // subtype
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subtype_value;
    b[n].is_null = &i.subtype_null;
    n++;

    // link
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.link_value;
    b[n].is_null = &i.link_null;
    n++;

    // dir
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.dir_value;
    b[n].is_null = &i.dir_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // links
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.links;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.links_value,
          is_null,
          id);
        i.links_null = is_null;
      }
      else
        i.links_null = true;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // subtype
    //
    {
      int const& v =
        o.subtype;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subtype_value,
        is_null,
        v);
      i.subtype_null = is_null;
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link > const& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.link_value,
          is_null,
          id);
        i.link_null = is_null;
      }
      else
        i.link_null = true;
    }

    // dir
    //
    {
      int const& v =
        o.dir;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.dir_value,
        is_null,
        v);
      i.dir_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // links
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.links;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.links_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.links_value,
          i.links_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // subtype
    //
    {
      int& v =
        o.subtype;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subtype_value,
        i.subtype_null);
    }

    // link
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Link >& v =
        o.link;

      typedef object_traits< ::polaris::io::Link > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Link > > ptr_traits;

      if (i.link_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.link_value,
          i.link_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // dir
    //
    {
      int& v =
        o.dir;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.dir_value,
        i.dir_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Driver\" ("
  "\"auto_id\","
  "\"route\","
  "\"links\","
  "\"type\","
  "\"subtype\","
  "\"link\","
  "\"dir\")"
  " VALUES (?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Driver\".\"auto_id\","
  "\"Driver\".\"route\","
  "\"Driver\".\"links\","
  "\"Driver\".\"type\","
  "\"Driver\".\"subtype\","
  "\"Driver\".\"link\","
  "\"Driver\".\"dir\""
  " FROM \"Driver\""
  " WHERE \"Driver\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::update_statement[] =
  "UPDATE \"Driver\" SET "
  "\"route\"=?,"
  "\"links\"=?,"
  "\"type\"=?,"
  "\"subtype\"=?,"
  "\"link\"=?,"
  "\"dir\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Driver\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Driver\".\"auto_id\","
  "\"Driver\".\"route\","
  "\"Driver\".\"links\","
  "\"Driver\".\"type\","
  "\"Driver\".\"subtype\","
  "\"Driver\".\"link\","
  "\"Driver\".\"dir\""
  " FROM \"Driver\""
  " LEFT JOIN \"Link\" AS \"links\" ON \"links\".\"link\"=\"Driver\".\"links\""
  " LEFT JOIN \"Link\" AS \"link\" ON \"link\".\"link\"=\"Driver\".\"link\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Driver\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::table_name[] =
  "\"Driver\"";

  void access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Driver\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Driver\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"links\" INTEGER,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"subtype\" INTEGER NOT NULL,\n"
                      "  \"link\" INTEGER,\n"
                      "  \"dir\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"links_fk\"\n"
                      "    FOREIGN KEY (\"links\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"link_fk\"\n"
                      "    FOREIGN KEY (\"link\")\n"
                      "    REFERENCES \"Link\" (\"link\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Driver_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Driver, id_sqlite >::create_schema);

  // Route_Nodes
  //

  const char alias_traits<  ::polaris::io::Veh_Type,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::veh_type_tag>::
  table_name[] = "\"veh_type\"";

  const char alias_traits<  ::polaris::io::Node,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::nodes_tag>::
  table_name[] = "\"nodes\"";

  const char alias_traits<  ::polaris::io::Node,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::node_tag>::
  table_name[] = "\"node\"";

  access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // route
    //
    t[1UL] = false;

    // mode
    //
    t[2UL] = false;

    // veh_type
    //
    t[3UL] = false;

    // nodes
    //
    t[4UL] = false;

    // name
    //
    if (t[5UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // node
    //
    t[6UL] = false;

    // type
    //
    t[7UL] = false;

    // dwell
    //
    t[8UL] = false;

    // time
    //
    t[9UL] = false;

    // speed
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // veh_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.veh_type_value;
    b[n].is_null = &i.veh_type_null;
    n++;

    // nodes
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.nodes_value;
    b[n].is_null = &i.nodes_null;
    n++;

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // node
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_value;
    b[n].is_null = &i.node_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.dwell_value;
    b[n].is_null = &i.dwell_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_value;
    b[n].is_null = &i.speed_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // veh_type
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Veh_Type > const& v =
        o.veh_type;

      typedef object_traits< ::polaris::io::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Veh_Type > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.veh_type_value,
          is_null,
          id);
        i.veh_type_null = is_null;
      }
      else
        i.veh_type_null = true;
    }

    // nodes
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node > const& v =
        o.nodes;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.nodes_value,
          is_null,
          id);
        i.nodes_null = is_null;
      }
      else
        i.nodes_null = true;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // node
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node > const& v =
        o.node;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_value,
          is_null,
          id);
        i.node_null = is_null;
      }
      else
        i.node_null = true;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // dwell
    //
    {
      double const& v =
        o.dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.dwell_value,
        is_null,
        v);
      i.dwell_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // speed
    //
    {
      double const& v =
        o.speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_value,
        is_null,
        v);
      i.speed_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // veh_type
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Veh_Type >& v =
        o.veh_type;

      typedef object_traits< ::polaris::io::Veh_Type > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Veh_Type > > ptr_traits;

      if (i.veh_type_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.veh_type_value,
          i.veh_type_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // nodes
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node >& v =
        o.nodes;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      if (i.nodes_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.nodes_value,
          i.nodes_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // node
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Node >& v =
        o.node;

      typedef object_traits< ::polaris::io::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Node > > ptr_traits;

      if (i.node_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_value,
          i.node_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // dwell
    //
    {
      double& v =
        o.dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.dwell_value,
        i.dwell_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // speed
    //
    {
      double& v =
        o.speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_value,
        i.speed_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Route_Nodes\" ("
  "\"auto_id\","
  "\"route\","
  "\"mode\","
  "\"veh_type\","
  "\"nodes\","
  "\"name\","
  "\"node\","
  "\"type\","
  "\"dwell\","
  "\"time\","
  "\"speed\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Route_Nodes\".\"auto_id\","
  "\"Route_Nodes\".\"route\","
  "\"Route_Nodes\".\"mode\","
  "\"Route_Nodes\".\"veh_type\","
  "\"Route_Nodes\".\"nodes\","
  "\"Route_Nodes\".\"name\","
  "\"Route_Nodes\".\"node\","
  "\"Route_Nodes\".\"type\","
  "\"Route_Nodes\".\"dwell\","
  "\"Route_Nodes\".\"time\","
  "\"Route_Nodes\".\"speed\""
  " FROM \"Route_Nodes\""
  " WHERE \"Route_Nodes\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::update_statement[] =
  "UPDATE \"Route_Nodes\" SET "
  "\"route\"=?,"
  "\"mode\"=?,"
  "\"veh_type\"=?,"
  "\"nodes\"=?,"
  "\"name\"=?,"
  "\"node\"=?,"
  "\"type\"=?,"
  "\"dwell\"=?,"
  "\"time\"=?,"
  "\"speed\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Route_Nodes\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Route_Nodes\".\"auto_id\","
  "\"Route_Nodes\".\"route\","
  "\"Route_Nodes\".\"mode\","
  "\"Route_Nodes\".\"veh_type\","
  "\"Route_Nodes\".\"nodes\","
  "\"Route_Nodes\".\"name\","
  "\"Route_Nodes\".\"node\","
  "\"Route_Nodes\".\"type\","
  "\"Route_Nodes\".\"dwell\","
  "\"Route_Nodes\".\"time\","
  "\"Route_Nodes\".\"speed\""
  " FROM \"Route_Nodes\""
  " LEFT JOIN \"Veh_Type\" AS \"veh_type\" ON \"veh_type\".\"type\"=\"Route_Nodes\".\"veh_type\""
  " LEFT JOIN \"Node\" AS \"nodes\" ON \"nodes\".\"node\"=\"Route_Nodes\".\"nodes\""
  " LEFT JOIN \"Node\" AS \"node\" ON \"node\".\"node\"=\"Route_Nodes\".\"node\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Route_Nodes\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::table_name[] =
  "\"Route_Nodes\"";

  void access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Route_Nodes\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Route_Nodes\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"veh_type\" INTEGER,\n"
                      "  \"nodes\" INTEGER,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"node\" INTEGER,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"dwell\" REAL,\n"
                      "  \"time\" REAL,\n"
                      "  \"speed\" REAL,\n"
                      "  CONSTRAINT \"veh_type_fk\"\n"
                      "    FOREIGN KEY (\"veh_type\")\n"
                      "    REFERENCES \"Veh_Type\" (\"type\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"nodes_fk\"\n"
                      "    FOREIGN KEY (\"nodes\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"node_fk\"\n"
                      "    FOREIGN KEY (\"node\")\n"
                      "    REFERENCES \"Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Route_Nodes_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Route_Nodes, id_sqlite >::create_schema);

  // Veh_Type
  //

  access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.type_value,
        i.type_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // type
    //
    t[0UL] = false;

    // length
    //
    t[1UL] = false;

    // max_speed
    //
    t[2UL] = false;

    // max_accel
    //
    t[3UL] = false;

    // max_decel
    //
    t[4UL] = false;

    // op_cost
    //
    t[5UL] = false;

    // use
    //
    t[6UL] = false;

    // capacity
    //
    t[7UL] = false;

    // load
    //
    t[8UL] = false;

    // unload
    //
    t[9UL] = false;

    // method
    //
    t[10UL] = false;

    // min_dwell
    //
    t[11UL] = false;

    // max_dwell
    //
    t[12UL] = false;

    // subtype
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // type
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.type_value;
      b[n].is_null = &i.type_null;
      n++;
    }

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // max_speed
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_speed_value;
    b[n].is_null = &i.max_speed_null;
    n++;

    // max_accel
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_accel_value;
    b[n].is_null = &i.max_accel_null;
    n++;

    // max_decel
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_decel_value;
    b[n].is_null = &i.max_decel_null;
    n++;

    // op_cost
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.op_cost_value;
    b[n].is_null = &i.op_cost_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // capacity
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.capacity_value;
    b[n].is_null = &i.capacity_null;
    n++;

    // load
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.load_value;
    b[n].is_null = &i.load_null;
    n++;

    // unload
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.unload_value;
    b[n].is_null = &i.unload_null;
    n++;

    // method
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.method_value;
    b[n].is_null = &i.method_null;
    n++;

    // min_dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.min_dwell_value;
    b[n].is_null = &i.min_dwell_null;
    n++;

    // max_dwell
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.max_dwell_value;
    b[n].is_null = &i.max_dwell_null;
    n++;

    // subtype
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subtype_value;
    b[n].is_null = &i.subtype_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // type
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // max_speed
    //
    {
      double const& v =
        o.max_speed;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_speed_value,
        is_null,
        v);
      i.max_speed_null = is_null;
    }

    // max_accel
    //
    {
      double const& v =
        o.max_accel;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_accel_value,
        is_null,
        v);
      i.max_accel_null = is_null;
    }

    // max_decel
    //
    {
      double const& v =
        o.max_decel;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_decel_value,
        is_null,
        v);
      i.max_decel_null = is_null;
    }

    // op_cost
    //
    {
      double const& v =
        o.op_cost;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.op_cost_value,
        is_null,
        v);
      i.op_cost_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // capacity
    //
    {
      int const& v =
        o.capacity;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.capacity_value,
        is_null,
        v);
      i.capacity_null = is_null;
    }

    // load
    //
    {
      double const& v =
        o.load;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.load_value,
        is_null,
        v);
      i.load_null = is_null;
    }

    // unload
    //
    {
      double const& v =
        o.unload;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.unload_value,
        is_null,
        v);
      i.unload_null = is_null;
    }

    // method
    //
    {
      int const& v =
        o.method;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.method_value,
        is_null,
        v);
      i.method_null = is_null;
    }

    // min_dwell
    //
    {
      double const& v =
        o.min_dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.min_dwell_value,
        is_null,
        v);
      i.min_dwell_null = is_null;
    }

    // max_dwell
    //
    {
      double const& v =
        o.max_dwell;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.max_dwell_value,
        is_null,
        v);
      i.max_dwell_null = is_null;
    }

    // subtype
    //
    {
      int const& v =
        o.subtype;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subtype_value,
        is_null,
        v);
      i.subtype_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // max_speed
    //
    {
      double& v =
        o.max_speed;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_speed_value,
        i.max_speed_null);
    }

    // max_accel
    //
    {
      double& v =
        o.max_accel;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_accel_value,
        i.max_accel_null);
    }

    // max_decel
    //
    {
      double& v =
        o.max_decel;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_decel_value,
        i.max_decel_null);
    }

    // op_cost
    //
    {
      double& v =
        o.op_cost;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.op_cost_value,
        i.op_cost_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // capacity
    //
    {
      int& v =
        o.capacity;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.capacity_value,
        i.capacity_null);
    }

    // load
    //
    {
      double& v =
        o.load;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.load_value,
        i.load_null);
    }

    // unload
    //
    {
      double& v =
        o.unload;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.unload_value,
        i.unload_null);
    }

    // method
    //
    {
      int& v =
        o.method;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.method_value,
        i.method_null);
    }

    // min_dwell
    //
    {
      double& v =
        o.min_dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.min_dwell_value,
        i.min_dwell_null);
    }

    // max_dwell
    //
    {
      double& v =
        o.max_dwell;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.max_dwell_value,
        i.max_dwell_null);
    }

    // subtype
    //
    {
      int& v =
        o.subtype;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subtype_value,
        i.subtype_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Veh_Type\" ("
  "\"type\","
  "\"length\","
  "\"max_speed\","
  "\"max_accel\","
  "\"max_decel\","
  "\"op_cost\","
  "\"use\","
  "\"capacity\","
  "\"load\","
  "\"unload\","
  "\"method\","
  "\"min_dwell\","
  "\"max_dwell\","
  "\"subtype\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Veh_Type\".\"type\","
  "\"Veh_Type\".\"length\","
  "\"Veh_Type\".\"max_speed\","
  "\"Veh_Type\".\"max_accel\","
  "\"Veh_Type\".\"max_decel\","
  "\"Veh_Type\".\"op_cost\","
  "\"Veh_Type\".\"use\","
  "\"Veh_Type\".\"capacity\","
  "\"Veh_Type\".\"load\","
  "\"Veh_Type\".\"unload\","
  "\"Veh_Type\".\"method\","
  "\"Veh_Type\".\"min_dwell\","
  "\"Veh_Type\".\"max_dwell\","
  "\"Veh_Type\".\"subtype\""
  " FROM \"Veh_Type\""
  " WHERE \"Veh_Type\".\"type\"=?";

  const char access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::update_statement[] =
  "UPDATE \"Veh_Type\" SET "
  "\"length\"=?,"
  "\"max_speed\"=?,"
  "\"max_accel\"=?,"
  "\"max_decel\"=?,"
  "\"op_cost\"=?,"
  "\"use\"=?,"
  "\"capacity\"=?,"
  "\"load\"=?,"
  "\"unload\"=?,"
  "\"method\"=?,"
  "\"min_dwell\"=?,"
  "\"max_dwell\"=?,"
  "\"subtype\"=?"
  " WHERE \"type\"=?";

  const char access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Veh_Type\""
  " WHERE \"type\"=?";

  const char access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Veh_Type\".\"type\","
  "\"Veh_Type\".\"length\","
  "\"Veh_Type\".\"max_speed\","
  "\"Veh_Type\".\"max_accel\","
  "\"Veh_Type\".\"max_decel\","
  "\"Veh_Type\".\"op_cost\","
  "\"Veh_Type\".\"use\","
  "\"Veh_Type\".\"capacity\","
  "\"Veh_Type\".\"load\","
  "\"Veh_Type\".\"unload\","
  "\"Veh_Type\".\"method\","
  "\"Veh_Type\".\"min_dwell\","
  "\"Veh_Type\".\"max_dwell\","
  "\"Veh_Type\".\"subtype\""
  " FROM \"Veh_Type\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Veh_Type\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::table_name[] =
  "\"Veh_Type\"";

  void access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.type);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.type);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Veh_Type\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Veh_Type\" (\n"
                      "  \"type\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"length\" REAL,\n"
                      "  \"max_speed\" REAL,\n"
                      "  \"max_accel\" REAL,\n"
                      "  \"max_decel\" REAL,\n"
                      "  \"op_cost\" REAL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"capacity\" INTEGER NOT NULL,\n"
                      "  \"load\" REAL,\n"
                      "  \"unload\" REAL,\n"
                      "  \"method\" INTEGER NOT NULL,\n"
                      "  \"min_dwell\" REAL,\n"
                      "  \"max_dwell\" REAL,\n"
                      "  \"subtype\" INTEGER NOT NULL)");
          db.execute ("CREATE INDEX \"Veh_Type_type_i\"\n"
                      "  ON \"Veh_Type\" (\"type\")");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Veh_Type_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Veh_Type, id_sqlite >::create_schema);

  // Ridership
  //

  const char alias_traits<  ::polaris::io::Stop,
    id_sqlite,
    access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::stop_tag>::
  table_name[] = "\"stop\"";

  access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.auto_id_value,
        i.auto_id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // auto_id
    //
    t[0UL] = false;

    // mode
    //
    t[1UL] = false;

    // route
    //
    t[2UL] = false;

    // run
    //
    t[3UL] = false;

    // stop
    //
    t[4UL] = false;

    // schedule
    //
    t[5UL] = false;

    // time
    //
    t[6UL] = false;

    // board
    //
    t[7UL] = false;

    // alight
    //
    t[8UL] = false;

    // load
    //
    t[9UL] = false;

    // factor
    //
    t[10UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // auto_id
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.auto_id_value;
      b[n].is_null = &i.auto_id_null;
      n++;
    }

    // mode
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.mode_value;
    b[n].is_null = &i.mode_null;
    n++;

    // route
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.route_value;
    b[n].is_null = &i.route_null;
    n++;

    // run
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.run_value;
    b[n].is_null = &i.run_null;
    n++;

    // stop
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.stop_value;
    b[n].is_null = &i.stop_null;
    n++;

    // schedule
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.schedule_value;
    b[n].is_null = &i.schedule_null;
    n++;

    // time
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.time_value;
    b[n].is_null = &i.time_null;
    n++;

    // board
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.board_value;
    b[n].is_null = &i.board_null;
    n++;

    // alight
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.alight_value;
    b[n].is_null = &i.alight_null;
    n++;

    // load
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.load_value;
    b[n].is_null = &i.load_null;
    n++;

    // factor
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.factor_value;
    b[n].is_null = &i.factor_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // auto_id
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.auto_id;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.auto_id_value,
        is_null,
        v);
      i.auto_id_null = is_null;
    }

    // mode
    //
    {
      int const& v =
        o.mode;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.mode_value,
        is_null,
        v);
      i.mode_null = is_null;
    }

    // route
    //
    {
      int const& v =
        o.route;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.route_value,
        is_null,
        v);
      i.route_null = is_null;
    }

    // run
    //
    {
      int const& v =
        o.run;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.run_value,
        is_null,
        v);
      i.run_null = is_null;
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop > const& v =
        o.stop;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.stop_value,
          is_null,
          id);
        i.stop_null = is_null;
      }
      else
        i.stop_null = true;
    }

    // schedule
    //
    {
      double const& v =
        o.schedule;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.schedule_value,
        is_null,
        v);
      i.schedule_null = is_null;
    }

    // time
    //
    {
      double const& v =
        o.time;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.time_value,
        is_null,
        v);
      i.time_null = is_null;
    }

    // board
    //
    {
      int const& v =
        o.board;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.board_value,
        is_null,
        v);
      i.board_null = is_null;
    }

    // alight
    //
    {
      int const& v =
        o.alight;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.alight_value,
        is_null,
        v);
      i.alight_null = is_null;
    }

    // load
    //
    {
      int const& v =
        o.load;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.load_value,
        is_null,
        v);
      i.load_null = is_null;
    }

    // factor
    //
    {
      double const& v =
        o.factor;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.factor_value,
        is_null,
        v);
      i.factor_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // auto_id
    //
    {
      long unsigned int& v =
        o.auto_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.auto_id_value,
        i.auto_id_null);
    }

    // mode
    //
    {
      int& v =
        o.mode;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.mode_value,
        i.mode_null);
    }

    // route
    //
    {
      int& v =
        o.route;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.route_value,
        i.route_null);
    }

    // run
    //
    {
      int& v =
        o.run;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.run_value,
        i.run_null);
    }

    // stop
    //
    {
      ::std::tr1::shared_ptr< ::polaris::io::Stop >& v =
        o.stop;

      typedef object_traits< ::polaris::io::Stop > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::polaris::io::Stop > > ptr_traits;

      if (i.stop_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.stop_value,
          i.stop_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // schedule
    //
    {
      double& v =
        o.schedule;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.schedule_value,
        i.schedule_null);
    }

    // time
    //
    {
      double& v =
        o.time;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.time_value,
        i.time_null);
    }

    // board
    //
    {
      int& v =
        o.board;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.board_value,
        i.board_null);
    }

    // alight
    //
    {
      int& v =
        o.alight;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.alight_value,
        i.alight_null);
    }

    // load
    //
    {
      int& v =
        o.load;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.load_value,
        i.load_null);
    }

    // factor
    //
    {
      double& v =
        o.factor;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.factor_value,
        i.factor_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Ridership\" ("
  "\"auto_id\","
  "\"mode\","
  "\"route\","
  "\"run\","
  "\"stop\","
  "\"schedule\","
  "\"time\","
  "\"board\","
  "\"alight\","
  "\"load\","
  "\"factor\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Ridership\".\"auto_id\","
  "\"Ridership\".\"mode\","
  "\"Ridership\".\"route\","
  "\"Ridership\".\"run\","
  "\"Ridership\".\"stop\","
  "\"Ridership\".\"schedule\","
  "\"Ridership\".\"time\","
  "\"Ridership\".\"board\","
  "\"Ridership\".\"alight\","
  "\"Ridership\".\"load\","
  "\"Ridership\".\"factor\""
  " FROM \"Ridership\""
  " WHERE \"Ridership\".\"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::update_statement[] =
  "UPDATE \"Ridership\" SET "
  "\"mode\"=?,"
  "\"route\"=?,"
  "\"run\"=?,"
  "\"stop\"=?,"
  "\"schedule\"=?,"
  "\"time\"=?,"
  "\"board\"=?,"
  "\"alight\"=?,"
  "\"load\"=?,"
  "\"factor\"=?"
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Ridership\""
  " WHERE \"auto_id\"=?";

  const char access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Ridership\".\"auto_id\","
  "\"Ridership\".\"mode\","
  "\"Ridership\".\"route\","
  "\"Ridership\".\"run\","
  "\"Ridership\".\"stop\","
  "\"Ridership\".\"schedule\","
  "\"Ridership\".\"time\","
  "\"Ridership\".\"board\","
  "\"Ridership\".\"alight\","
  "\"Ridership\".\"load\","
  "\"Ridership\".\"factor\""
  " FROM \"Ridership\""
  " LEFT JOIN \"Stop\" AS \"stop\" ON \"stop\".\"stop\"=\"Ridership\".\"stop\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Ridership\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::table_name[] =
  "\"Ridership\"";

  void access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.auto_id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.auto_id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.auto_id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.auto_id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Ridership\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Ridership\" (\n"
                      "  \"auto_id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"mode\" INTEGER NOT NULL,\n"
                      "  \"route\" INTEGER NOT NULL,\n"
                      "  \"run\" INTEGER NOT NULL,\n"
                      "  \"stop\" INTEGER,\n"
                      "  \"schedule\" REAL,\n"
                      "  \"time\" REAL,\n"
                      "  \"board\" INTEGER NOT NULL,\n"
                      "  \"alight\" INTEGER NOT NULL,\n"
                      "  \"load\" INTEGER NOT NULL,\n"
                      "  \"factor\" REAL,\n"
                      "  CONSTRAINT \"stop_fk\"\n"
                      "    FOREIGN KEY (\"stop\")\n"
                      "    REFERENCES \"Stop\" (\"stop\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Ridership_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Ridership, id_sqlite >::create_schema);

  // Area_Type
  //

  access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.area_type_value,
        i.area_type_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // area_type
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // notes
    //
    if (t[2UL])
    {
      i.notes_value.capacity (i.notes_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // area_type
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.area_type_value;
      b[n].is_null = &i.area_type_null;
      n++;
    }

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // notes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.notes_value.data ();
    b[n].size = &i.notes_size;
    b[n].capacity = i.notes_value.capacity ();
    b[n].is_null = &i.notes_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // area_type
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.area_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.area_type_value,
        is_null,
        v);
      i.area_type_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // notes
    //
    {
      ::std::string const& v =
        o.notes;

      bool is_null (false);
      std::size_t cap (i.notes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.notes_value,
        i.notes_size,
        is_null,
        v);
      i.notes_null = is_null;
      grew = grew || (cap != i.notes_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // area_type
    //
    {
      int& v =
        o.area_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.area_type_value,
        i.area_type_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // notes
    //
    {
      ::std::string& v =
        o.notes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.notes_value,
        i.notes_size,
        i.notes_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Area_Type\" ("
  "\"area_type\","
  "\"name\","
  "\"notes\")"
  " VALUES (?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Area_Type\".\"area_type\","
  "\"Area_Type\".\"name\","
  "\"Area_Type\".\"notes\""
  " FROM \"Area_Type\""
  " WHERE \"Area_Type\".\"area_type\"=?";

  const char access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::update_statement[] =
  "UPDATE \"Area_Type\" SET "
  "\"name\"=?,"
  "\"notes\"=?"
  " WHERE \"area_type\"=?";

  const char access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Area_Type\""
  " WHERE \"area_type\"=?";

  const char access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Area_Type\".\"area_type\","
  "\"Area_Type\".\"name\","
  "\"Area_Type\".\"notes\""
  " FROM \"Area_Type\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Area_Type\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::table_name[] =
  "\"Area_Type\"";

  void access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.area_type);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.area_type);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Area_Type\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Area_Type\" (\n"
                      "  \"area_type\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"notes\" TEXT NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Area_Type_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Area_Type, id_sqlite >::create_schema);

  // Link_Type
  //

  access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::id_type
  access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        id,
        i.link_type_value,
        i.link_type_size,
        i.link_type_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // link_type
    //
    if (t[0UL])
    {
      i.link_type_value.capacity (i.link_type_size);
      grew = true;
    }

    // rank
    //
    t[1UL] = false;

    // use_codes
    //
    if (t[2UL])
    {
      i.use_codes_value.capacity (i.use_codes_size);
      grew = true;
    }

    // alternative_labels
    //
    if (t[3UL])
    {
      i.alternative_labels_value.capacity (i.alternative_labels_size);
      grew = true;
    }

    // notes
    //
    if (t[4UL])
    {
      i.notes_value.capacity (i.notes_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // link_type
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::image_traits<
        ::std::string,
        sqlite::id_text>::bind_value;
      b[n].buffer = i.link_type_value.data ();
      b[n].size = &i.link_type_size;
      b[n].capacity = i.link_type_value.capacity ();
      b[n].is_null = &i.link_type_null;
      n++;
    }

    // rank
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.rank_value;
    b[n].is_null = &i.rank_null;
    n++;

    // use_codes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.use_codes_value.data ();
    b[n].size = &i.use_codes_size;
    b[n].capacity = i.use_codes_value.capacity ();
    b[n].is_null = &i.use_codes_null;
    n++;

    // alternative_labels
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.alternative_labels_value.data ();
    b[n].size = &i.alternative_labels_size;
    b[n].capacity = i.alternative_labels_value.capacity ();
    b[n].is_null = &i.alternative_labels_null;
    n++;

    // notes
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.notes_value.data ();
    b[n].size = &i.notes_size;
    b[n].capacity = i.notes_value.capacity ();
    b[n].is_null = &i.notes_null;
    n++;
  }

  void access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.id_value.data ();
    b[n].size = &i.id_size;
    b[n].capacity = i.id_value.capacity ();
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // link_type
    //
    if (sk == statement_insert)
    {
      ::std::string const& v =
        o.link_type;

      bool is_null (false);
      std::size_t cap (i.link_type_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.link_type_value,
        i.link_type_size,
        is_null,
        v);
      i.link_type_null = is_null;
      grew = grew || (cap != i.link_type_value.capacity ());
    }

    // rank
    //
    {
      int const& v =
        o.rank;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.rank_value,
        is_null,
        v);
      i.rank_null = is_null;
    }

    // use_codes
    //
    {
      ::std::string const& v =
        o.use_codes;

      bool is_null (false);
      std::size_t cap (i.use_codes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.use_codes_value,
        i.use_codes_size,
        is_null,
        v);
      i.use_codes_null = is_null;
      grew = grew || (cap != i.use_codes_value.capacity ());
    }

    // alternative_labels
    //
    {
      ::std::string const& v =
        o.alternative_labels;

      bool is_null (false);
      std::size_t cap (i.alternative_labels_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.alternative_labels_value,
        i.alternative_labels_size,
        is_null,
        v);
      i.alternative_labels_null = is_null;
      grew = grew || (cap != i.alternative_labels_value.capacity ());
    }

    // notes
    //
    {
      ::std::string const& v =
        o.notes;

      bool is_null (false);
      std::size_t cap (i.notes_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.notes_value,
        i.notes_size,
        is_null,
        v);
      i.notes_null = is_null;
      grew = grew || (cap != i.notes_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // link_type
    //
    {
      ::std::string& v =
        o.link_type;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.link_type_value,
        i.link_type_size,
        i.link_type_null);
    }

    // rank
    //
    {
      int& v =
        o.rank;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.rank_value,
        i.rank_null);
    }

    // use_codes
    //
    {
      ::std::string& v =
        o.use_codes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.use_codes_value,
        i.use_codes_size,
        i.use_codes_null);
    }

    // alternative_labels
    //
    {
      ::std::string& v =
        o.alternative_labels;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.alternative_labels_value,
        i.alternative_labels_size,
        i.alternative_labels_null);
    }

    // notes
    //
    {
      ::std::string& v =
        o.notes;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.notes_value,
        i.notes_size,
        i.notes_null);
    }
  }

  void access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    bool grew (false);
    {
      bool is_null (false);
      std::size_t cap (i.id_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.id_value,
        i.id_size,
        is_null,
        id);
      i.id_null = is_null;
      grew = grew || (cap != i.id_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  struct access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::container_statement_cache_type
  {
    container_statement_cache_type (
      sqlite::connection&,
      sqlite::binding&)
    {
    }
  };

  const char access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Link_Type\" ("
  "\"link_type\","
  "\"rank\","
  "\"use_codes\","
  "\"alternative_labels\","
  "\"notes\")"
  " VALUES (?,?,?,?,?)";

  const char access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Link_Type\".\"link_type\","
  "\"Link_Type\".\"rank\","
  "\"Link_Type\".\"use_codes\","
  "\"Link_Type\".\"alternative_labels\","
  "\"Link_Type\".\"notes\""
  " FROM \"Link_Type\""
  " WHERE \"Link_Type\".\"link_type\"=?";

  const char access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::update_statement[] =
  "UPDATE \"Link_Type\" SET "
  "\"rank\"=?,"
  "\"use_codes\"=?,"
  "\"alternative_labels\"=?,"
  "\"notes\"=?"
  " WHERE \"link_type\"=?";

  const char access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Link_Type\""
  " WHERE \"link_type\"=?";

  const char access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Link_Type\".\"link_type\","
  "\"Link_Type\".\"rank\","
  "\"Link_Type\".\"use_codes\","
  "\"Link_Type\".\"alternative_labels\","
  "\"Link_Type\".\"notes\""
  " FROM \"Link_Type\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Link_Type\""
  " ";

  const char access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::table_name[] =
  "\"Link_Type\"";

  void access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.link_type);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::pointer_type
  access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.link_type);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::object_type >
  access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"Link_Type\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Link_Type\" (\n"
                      "  \"link_type\" TEXT NOT NULL PRIMARY KEY,\n"
                      "  \"rank\" INTEGER NOT NULL,\n"
                      "  \"use_codes\" TEXT NOT NULL,\n"
                      "  \"alternative_labels\" TEXT NOT NULL,\n"
                      "  \"notes\" TEXT NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_polaris_io_Link_Type_ (
    id_sqlite,
    "Supply",
    &access::object_traits_impl< ::polaris::io::Link_Type, id_sqlite >::create_schema);
}

#include <odb/post.hxx>
