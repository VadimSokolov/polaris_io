// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include "OutNetwork-odb.hxx"

#include <cassert>
#include <cstring>  // std::memcpy

#include <odb/schema-catalog-impl.hxx>
#include <odb/details/shared-ptr.hxx>

#include <odb/sqlite/traits.hxx>
#include <odb/sqlite/database.hxx>
#include <odb/sqlite/transaction.hxx>
#include <odb/sqlite/connection.hxx>
#include <odb/sqlite/statement.hxx>
#include <odb/sqlite/statement-cache.hxx>
#include <odb/sqlite/simple-object-statements.hxx>
#include <odb/sqlite/container-statements.hxx>
#include <odb/sqlite/exceptions.hxx>
#include <odb/sqlite/simple-object-result.hxx>

namespace odb
{
  // Node
  //

  access::object_traits< ::Node >::id_type
  access::object_traits< ::Node >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.node_value,
        i.node_null);
    }

    return id;
  }

  bool access::object_traits< ::Node >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // node
    //
    t[0UL] = false;

    // x
    //
    t[1UL] = false;

    // y
    //
    t[2UL] = false;

    // z
    //
    t[3UL] = false;

    // subarea
    //
    t[4UL] = false;

    // part
    //
    t[5UL] = false;

    return grew;
  }

  void access::object_traits< ::Node >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // node
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.node_value;
      b[n].is_null = &i.node_null;
      n++;
    }

    // x
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.x_value;
    b[n].is_null = &i.x_null;
    n++;

    // y
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.y_value;
    b[n].is_null = &i.y_null;
    n++;

    // z
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.z_value;
    b[n].is_null = &i.z_null;
    n++;

    // subarea
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.subarea_value;
    b[n].is_null = &i.subarea_null;
    n++;

    // part
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.part_value;
    b[n].is_null = &i.part_null;
    n++;
  }

  void access::object_traits< ::Node >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::Node >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // node
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.node;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.node_value,
        is_null,
        v);
      i.node_null = is_null;
    }

    // x
    //
    {
      double const& v =
        o.x;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.x_value,
        is_null,
        v);
      i.x_null = is_null;
    }

    // y
    //
    {
      double const& v =
        o.y;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.y_value,
        is_null,
        v);
      i.y_null = is_null;
    }

    // z
    //
    {
      double const& v =
        o.z;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.z_value,
        is_null,
        v);
      i.z_null = is_null;
    }

    // subarea
    //
    {
      int const& v =
        o.subarea;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.subarea_value,
        is_null,
        v);
      i.subarea_null = is_null;
    }

    // part
    //
    {
      int const& v =
        o.part;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.part_value,
        is_null,
        v);
      i.part_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::Node >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // node
    //
    {
      int& v =
        o.node;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.node_value,
        i.node_null);
    }

    // x
    //
    {
      double& v =
        o.x;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.x_value,
        i.x_null);
    }

    // y
    //
    {
      double& v =
        o.y;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.y_value,
        i.y_null);
    }

    // z
    //
    {
      double& v =
        o.z;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.z_value,
        i.z_null);
    }

    // subarea
    //
    {
      int& v =
        o.subarea;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.subarea_value,
        i.subarea_null);
    }

    // part
    //
    {
      int& v =
        o.part;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.part_value,
        i.part_null);
    }
  }

  void access::object_traits< ::Node >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::Node >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::Node >::persist_statement[] =
  "INSERT INTO \"relation_Node\" ("
  "\"node\","
  "\"x\","
  "\"y\","
  "\"z\","
  "\"subarea\","
  "\"part\")"
  " VALUES (?,?,?,?,?,?)";

  const char access::object_traits< ::Node >::find_statement[] =
  "SELECT "
  "\"relation_Node\".\"node\","
  "\"relation_Node\".\"x\","
  "\"relation_Node\".\"y\","
  "\"relation_Node\".\"z\","
  "\"relation_Node\".\"subarea\","
  "\"relation_Node\".\"part\""
  " FROM \"relation_Node\""
  " WHERE \"relation_Node\".\"node\"=?";

  const char access::object_traits< ::Node >::update_statement[] =
  "UPDATE \"relation_Node\" SET "
  "\"x\"=?,"
  "\"y\"=?,"
  "\"z\"=?,"
  "\"subarea\"=?,"
  "\"part\"=?"
  " WHERE \"node\"=?";

  const char access::object_traits< ::Node >::erase_statement[] =
  "DELETE FROM \"relation_Node\""
  " WHERE \"node\"=?";

  const char access::object_traits< ::Node >::query_statement[] =
  "SELECT "
  "\"relation_Node\".\"node\","
  "\"relation_Node\".\"x\","
  "\"relation_Node\".\"y\","
  "\"relation_Node\".\"z\","
  "\"relation_Node\".\"subarea\","
  "\"relation_Node\".\"part\""
  " FROM \"relation_Node\""
  " ";

  const char access::object_traits< ::Node >::erase_query_statement[] =
  "DELETE FROM \"relation_Node\""
  " ";

  const char access::object_traits< ::Node >::table_name[] =
  "\"relation_Node\"";

  void access::object_traits< ::Node >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::Node >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.node);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::Node >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::Node >::pointer_type
  access::object_traits< ::Node >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::Node >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::Node >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.node);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::Node >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::Node >::object_type >
  access::object_traits< ::Node >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::Node >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::Node >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"relation_Node\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"relation_Node\" (\n"
                      "  \"node\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"x\" REAL,\n"
                      "  \"y\" REAL,\n"
                      "  \"z\" REAL,\n"
                      "  \"subarea\" INTEGER NOT NULL,\n"
                      "  \"part\" INTEGER NOT NULL)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_Node_ (
    "",
    &access::object_traits< ::Node >::create_schema);

  // Link
  //

  access::object_traits< ::Link >::id_type
  access::object_traits< ::Link >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        id,
        i.link_value,
        i.link_null);
    }

    return id;
  }

  bool access::object_traits< ::Link >::
  grow (image_type& i, bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // link
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // node_a
    //
    t[2UL] = false;

    // node_b
    //
    t[3UL] = false;

    // length
    //
    t[4UL] = false;

    // setback_a
    //
    t[5UL] = false;

    // setback_b
    //
    t[6UL] = false;

    // bearing_a
    //
    t[7UL] = false;

    // bearing_b
    //
    t[8UL] = false;

    // type
    //
    t[9UL] = false;

    // divided
    //
    t[10UL] = false;

    // area_type
    //
    t[11UL] = false;

    // use
    //
    t[12UL] = false;

    // grade
    //
    t[13UL] = false;

    // lanes_ab
    //
    t[14UL] = false;

    // speed_ab
    //
    t[15UL] = false;

    // fspd_ab
    //
    t[16UL] = false;

    // cap_ab
    //
    t[17UL] = false;

    // lanes_ba
    //
    t[18UL] = false;

    // speed_ba
    //
    t[19UL] = false;

    // fspd_ba
    //
    t[20UL] = false;

    // cap_ba
    //
    t[21UL] = false;

    // left_ab
    //
    t[22UL] = false;

    // right_ab
    //
    t[23UL] = false;

    // left_ba
    //
    t[24UL] = false;

    // right_ba
    //
    t[25UL] = false;

    return grew;
  }

  void access::object_traits< ::Link >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // link
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.link_value;
      b[n].is_null = &i.link_null;
      n++;
    }

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // node_a
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_a_value;
    b[n].is_null = &i.node_a_null;
    n++;

    // node_b
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.node_b_value;
    b[n].is_null = &i.node_b_null;
    n++;

    // length
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.length_value;
    b[n].is_null = &i.length_null;
    n++;

    // setback_a
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_a_value;
    b[n].is_null = &i.setback_a_null;
    n++;

    // setback_b
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.setback_b_value;
    b[n].is_null = &i.setback_b_null;
    n++;

    // bearing_a
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bearing_a_value;
    b[n].is_null = &i.bearing_a_null;
    n++;

    // bearing_b
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bearing_b_value;
    b[n].is_null = &i.bearing_b_null;
    n++;

    // type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.type_value;
    b[n].is_null = &i.type_null;
    n++;

    // divided
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.divided_value;
    b[n].is_null = &i.divided_null;
    n++;

    // area_type
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.area_type_value;
    b[n].is_null = &i.area_type_null;
    n++;

    // use
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.use_value;
    b[n].is_null = &i.use_null;
    n++;

    // grade
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.grade_value;
    b[n].is_null = &i.grade_null;
    n++;

    // lanes_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_ab_value;
    b[n].is_null = &i.lanes_ab_null;
    n++;

    // speed_ab
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_ab_value;
    b[n].is_null = &i.speed_ab_null;
    n++;

    // fspd_ab
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.fspd_ab_value;
    b[n].is_null = &i.fspd_ab_null;
    n++;

    // cap_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cap_ab_value;
    b[n].is_null = &i.cap_ab_null;
    n++;

    // lanes_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.lanes_ba_value;
    b[n].is_null = &i.lanes_ba_null;
    n++;

    // speed_ba
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.speed_ba_value;
    b[n].is_null = &i.speed_ba_null;
    n++;

    // fspd_ba
    //
    b[n].type = sqlite::bind::real;
    b[n].buffer = &i.fspd_ba_value;
    b[n].is_null = &i.fspd_ba_null;
    n++;

    // cap_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.cap_ba_value;
    b[n].is_null = &i.cap_ba_null;
    n++;

    // left_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.left_ab_value;
    b[n].is_null = &i.left_ab_null;
    n++;

    // right_ab
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.right_ab_value;
    b[n].is_null = &i.right_ab_null;
    n++;

    // left_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.left_ba_value;
    b[n].is_null = &i.left_ba_null;
    n++;

    // right_ba
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.right_ba_value;
    b[n].is_null = &i.right_ba_null;
    n++;
  }

  void access::object_traits< ::Link >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits< ::Link >::
  init (image_type& i, const object_type& o, sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // link
    //
    if (sk == statement_insert)
    {
      int const& v =
        o.link;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.link_value,
        is_null,
        v);
      i.link_null = is_null;
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // node_a
    //
    {
      ::std::tr1::shared_ptr< ::Node > const& v =
        o.node_a;

      typedef object_traits< ::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_a_value,
          is_null,
          id);
        i.node_a_null = is_null;
      }
      else
        i.node_a_null = true;
    }

    // node_b
    //
    {
      ::std::tr1::shared_ptr< ::Node > const& v =
        o.node_b;

      typedef object_traits< ::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::Node > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.node_b_value,
          is_null,
          id);
        i.node_b_null = is_null;
      }
      else
        i.node_b_null = true;
    }

    // length
    //
    {
      double const& v =
        o.length;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.length_value,
        is_null,
        v);
      i.length_null = is_null;
    }

    // setback_a
    //
    {
      double const& v =
        o.setback_a;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_a_value,
        is_null,
        v);
      i.setback_a_null = is_null;
    }

    // setback_b
    //
    {
      double const& v =
        o.setback_b;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.setback_b_value,
        is_null,
        v);
      i.setback_b_null = is_null;
    }

    // bearing_a
    //
    {
      int const& v =
        o.bearing_a;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.bearing_a_value,
        is_null,
        v);
      i.bearing_a_null = is_null;
    }

    // bearing_b
    //
    {
      int const& v =
        o.bearing_b;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.bearing_b_value,
        is_null,
        v);
      i.bearing_b_null = is_null;
    }

    // type
    //
    {
      int const& v =
        o.type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.type_value,
        is_null,
        v);
      i.type_null = is_null;
    }

    // divided
    //
    {
      int const& v =
        o.divided;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.divided_value,
        is_null,
        v);
      i.divided_null = is_null;
    }

    // area_type
    //
    {
      int const& v =
        o.area_type;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.area_type_value,
        is_null,
        v);
      i.area_type_null = is_null;
    }

    // use
    //
    {
      int const& v =
        o.use;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.use_value,
        is_null,
        v);
      i.use_null = is_null;
    }

    // grade
    //
    {
      double const& v =
        o.grade;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.grade_value,
        is_null,
        v);
      i.grade_null = is_null;
    }

    // lanes_ab
    //
    {
      int const& v =
        o.lanes_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_ab_value,
        is_null,
        v);
      i.lanes_ab_null = is_null;
    }

    // speed_ab
    //
    {
      double const& v =
        o.speed_ab;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_ab_value,
        is_null,
        v);
      i.speed_ab_null = is_null;
    }

    // fspd_ab
    //
    {
      double const& v =
        o.fspd_ab;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.fspd_ab_value,
        is_null,
        v);
      i.fspd_ab_null = is_null;
    }

    // cap_ab
    //
    {
      int const& v =
        o.cap_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cap_ab_value,
        is_null,
        v);
      i.cap_ab_null = is_null;
    }

    // lanes_ba
    //
    {
      int const& v =
        o.lanes_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.lanes_ba_value,
        is_null,
        v);
      i.lanes_ba_null = is_null;
    }

    // speed_ba
    //
    {
      double const& v =
        o.speed_ba;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.speed_ba_value,
        is_null,
        v);
      i.speed_ba_null = is_null;
    }

    // fspd_ba
    //
    {
      double const& v =
        o.fspd_ba;

      bool is_null (true);
      sqlite::value_traits<
          double,
          sqlite::id_real >::set_image (
        i.fspd_ba_value,
        is_null,
        v);
      i.fspd_ba_null = is_null;
    }

    // cap_ba
    //
    {
      int const& v =
        o.cap_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.cap_ba_value,
        is_null,
        v);
      i.cap_ba_null = is_null;
    }

    // left_ab
    //
    {
      int const& v =
        o.left_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.left_ab_value,
        is_null,
        v);
      i.left_ab_null = is_null;
    }

    // right_ab
    //
    {
      int const& v =
        o.right_ab;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.right_ab_value,
        is_null,
        v);
      i.right_ab_null = is_null;
    }

    // left_ba
    //
    {
      int const& v =
        o.left_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.left_ba_value,
        is_null,
        v);
      i.left_ba_null = is_null;
    }

    // right_ba
    //
    {
      int const& v =
        o.right_ba;

      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.right_ba_value,
        is_null,
        v);
      i.right_ba_null = is_null;
    }

    return grew;
  }

  void access::object_traits< ::Link >::
  init (object_type& o, const image_type& i, database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // link
    //
    {
      int& v =
        o.link;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.link_value,
        i.link_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // node_a
    //
    {
      ::std::tr1::shared_ptr< ::Node >& v =
        o.node_a;

      typedef object_traits< ::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::Node > > ptr_traits;

      if (i.node_a_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_a_value,
          i.node_a_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // node_b
    //
    {
      ::std::tr1::shared_ptr< ::Node >& v =
        o.node_b;

      typedef object_traits< ::Node > obj_traits;
      typedef odb::pointer_traits< ::std::tr1::shared_ptr< ::Node > > ptr_traits;

      if (i.node_b_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.node_b_value,
          i.node_b_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          db->load< obj_traits::object_type > (id));
      }
    }

    // length
    //
    {
      double& v =
        o.length;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.length_value,
        i.length_null);
    }

    // setback_a
    //
    {
      double& v =
        o.setback_a;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_a_value,
        i.setback_a_null);
    }

    // setback_b
    //
    {
      double& v =
        o.setback_b;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.setback_b_value,
        i.setback_b_null);
    }

    // bearing_a
    //
    {
      int& v =
        o.bearing_a;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.bearing_a_value,
        i.bearing_a_null);
    }

    // bearing_b
    //
    {
      int& v =
        o.bearing_b;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.bearing_b_value,
        i.bearing_b_null);
    }

    // type
    //
    {
      int& v =
        o.type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.type_value,
        i.type_null);
    }

    // divided
    //
    {
      int& v =
        o.divided;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.divided_value,
        i.divided_null);
    }

    // area_type
    //
    {
      int& v =
        o.area_type;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.area_type_value,
        i.area_type_null);
    }

    // use
    //
    {
      int& v =
        o.use;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.use_value,
        i.use_null);
    }

    // grade
    //
    {
      double& v =
        o.grade;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.grade_value,
        i.grade_null);
    }

    // lanes_ab
    //
    {
      int& v =
        o.lanes_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_ab_value,
        i.lanes_ab_null);
    }

    // speed_ab
    //
    {
      double& v =
        o.speed_ab;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_ab_value,
        i.speed_ab_null);
    }

    // fspd_ab
    //
    {
      double& v =
        o.fspd_ab;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.fspd_ab_value,
        i.fspd_ab_null);
    }

    // cap_ab
    //
    {
      int& v =
        o.cap_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cap_ab_value,
        i.cap_ab_null);
    }

    // lanes_ba
    //
    {
      int& v =
        o.lanes_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.lanes_ba_value,
        i.lanes_ba_null);
    }

    // speed_ba
    //
    {
      double& v =
        o.speed_ba;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.speed_ba_value,
        i.speed_ba_null);
    }

    // fspd_ba
    //
    {
      double& v =
        o.fspd_ba;

      sqlite::value_traits<
          double,
          sqlite::id_real >::set_value (
        v,
        i.fspd_ba_value,
        i.fspd_ba_null);
    }

    // cap_ba
    //
    {
      int& v =
        o.cap_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.cap_ba_value,
        i.cap_ba_null);
    }

    // left_ab
    //
    {
      int& v =
        o.left_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.left_ab_value,
        i.left_ab_null);
    }

    // right_ab
    //
    {
      int& v =
        o.right_ab;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.right_ab_value,
        i.right_ab_null);
    }

    // left_ba
    //
    {
      int& v =
        o.left_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.left_ba_value,
        i.left_ba_null);
    }

    // right_ba
    //
    {
      int& v =
        o.right_ba;

      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_value (
        v,
        i.right_ba_value,
        i.right_ba_null);
    }
  }

  void access::object_traits< ::Link >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  struct access::object_traits< ::Link >::container_statement_cache_type
  {
    container_statement_cache_type (sqlite::connection&)
    {
    }
  };

  const char access::object_traits< ::Link >::persist_statement[] =
  "INSERT INTO \"relation_Link\" ("
  "\"link\","
  "\"name\","
  "\"node_a\","
  "\"node_b\","
  "\"length\","
  "\"setback_a\","
  "\"setback_b\","
  "\"bearing_a\","
  "\"bearing_b\","
  "\"type\","
  "\"divided\","
  "\"area_type\","
  "\"use\","
  "\"grade\","
  "\"lanes_ab\","
  "\"speed_ab\","
  "\"fspd_ab\","
  "\"cap_ab\","
  "\"lanes_ba\","
  "\"speed_ba\","
  "\"fspd_ba\","
  "\"cap_ba\","
  "\"left_ab\","
  "\"right_ab\","
  "\"left_ba\","
  "\"right_ba\")"
  " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

  const char access::object_traits< ::Link >::find_statement[] =
  "SELECT "
  "\"relation_Link\".\"link\","
  "\"relation_Link\".\"name\","
  "\"relation_Link\".\"node_a\","
  "\"relation_Link\".\"node_b\","
  "\"relation_Link\".\"length\","
  "\"relation_Link\".\"setback_a\","
  "\"relation_Link\".\"setback_b\","
  "\"relation_Link\".\"bearing_a\","
  "\"relation_Link\".\"bearing_b\","
  "\"relation_Link\".\"type\","
  "\"relation_Link\".\"divided\","
  "\"relation_Link\".\"area_type\","
  "\"relation_Link\".\"use\","
  "\"relation_Link\".\"grade\","
  "\"relation_Link\".\"lanes_ab\","
  "\"relation_Link\".\"speed_ab\","
  "\"relation_Link\".\"fspd_ab\","
  "\"relation_Link\".\"cap_ab\","
  "\"relation_Link\".\"lanes_ba\","
  "\"relation_Link\".\"speed_ba\","
  "\"relation_Link\".\"fspd_ba\","
  "\"relation_Link\".\"cap_ba\","
  "\"relation_Link\".\"left_ab\","
  "\"relation_Link\".\"right_ab\","
  "\"relation_Link\".\"left_ba\","
  "\"relation_Link\".\"right_ba\""
  " FROM \"relation_Link\""
  " WHERE \"relation_Link\".\"link\"=?";

  const char access::object_traits< ::Link >::update_statement[] =
  "UPDATE \"relation_Link\" SET "
  "\"name\"=?,"
  "\"node_a\"=?,"
  "\"node_b\"=?,"
  "\"length\"=?,"
  "\"setback_a\"=?,"
  "\"setback_b\"=?,"
  "\"bearing_a\"=?,"
  "\"bearing_b\"=?,"
  "\"type\"=?,"
  "\"divided\"=?,"
  "\"area_type\"=?,"
  "\"use\"=?,"
  "\"grade\"=?,"
  "\"lanes_ab\"=?,"
  "\"speed_ab\"=?,"
  "\"fspd_ab\"=?,"
  "\"cap_ab\"=?,"
  "\"lanes_ba\"=?,"
  "\"speed_ba\"=?,"
  "\"fspd_ba\"=?,"
  "\"cap_ba\"=?,"
  "\"left_ab\"=?,"
  "\"right_ab\"=?,"
  "\"left_ba\"=?,"
  "\"right_ba\"=?"
  " WHERE \"link\"=?";

  const char access::object_traits< ::Link >::erase_statement[] =
  "DELETE FROM \"relation_Link\""
  " WHERE \"link\"=?";

  const char access::object_traits< ::Link >::query_statement[] =
  "SELECT "
  "\"relation_Link\".\"link\","
  "\"relation_Link\".\"name\","
  "\"relation_Link\".\"node_a\","
  "\"relation_Link\".\"node_b\","
  "\"relation_Link\".\"length\","
  "\"relation_Link\".\"setback_a\","
  "\"relation_Link\".\"setback_b\","
  "\"relation_Link\".\"bearing_a\","
  "\"relation_Link\".\"bearing_b\","
  "\"relation_Link\".\"type\","
  "\"relation_Link\".\"divided\","
  "\"relation_Link\".\"area_type\","
  "\"relation_Link\".\"use\","
  "\"relation_Link\".\"grade\","
  "\"relation_Link\".\"lanes_ab\","
  "\"relation_Link\".\"speed_ab\","
  "\"relation_Link\".\"fspd_ab\","
  "\"relation_Link\".\"cap_ab\","
  "\"relation_Link\".\"lanes_ba\","
  "\"relation_Link\".\"speed_ba\","
  "\"relation_Link\".\"fspd_ba\","
  "\"relation_Link\".\"cap_ba\","
  "\"relation_Link\".\"left_ab\","
  "\"relation_Link\".\"right_ab\","
  "\"relation_Link\".\"left_ba\","
  "\"relation_Link\".\"right_ba\""
  " FROM \"relation_Link\""
  " LEFT JOIN \"relation_Node\" AS \"node_a\" ON \"node_a\".\"node\"=\"relation_Link\".\"node_a\""
  " LEFT JOIN \"relation_Node\" AS \"node_b\" ON \"node_b\".\"node\"=\"relation_Link\".\"node_b\""
  " ";

  const char access::object_traits< ::Link >::erase_query_statement[] =
  "DELETE FROM \"relation_Link\""
  " ";

  const char access::object_traits< ::Link >::table_name[] =
  "\"relation_Link\"";

  void access::object_traits< ::Link >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits< ::Link >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    callback (db, obj, callback_event::pre_update);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, obj.link);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (i.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, i);
        sts.id_image_version (i.version);
        idb.version++;
      }

      sts.update_id_image_version (i.version);

      if (!u)
        imb.version++;
    }

    if (sts.update_statement ().execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
  }

  void access::object_traits< ::Link >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits< ::Link >::pointer_type
  access::object_traits< ::Link >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj);
      sts.load_delayed ();
      l.unlock ();
      callback (db, obj, callback_event::post_load);
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits< ::Link >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::insert_guard ig (
      reference_cache_traits::insert (db, id, obj));

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    ig.release ();
    return true;
  }

  bool access::object_traits< ::Link >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.link);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj);
    sts.load_delayed ();
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits< ::Link >::
  find_ (statements_type& sts, const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits< ::Link >::object_type >
  access::object_traits< ::Link >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement + q.clause (),
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits< ::Link >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    delete_statement st (
      conn,
      erase_query_statement + q.clause (),
      q.parameters_binding ());

    return st.execute ();
  }

  bool access::object_traits< ::Link >::
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("DROP TABLE IF EXISTS \"relation_Link\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"relation_Link\" (\n"
                      "  \"link\" INTEGER NOT NULL PRIMARY KEY,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"node_a\" INTEGER,\n"
                      "  \"node_b\" INTEGER,\n"
                      "  \"length\" REAL,\n"
                      "  \"setback_a\" REAL,\n"
                      "  \"setback_b\" REAL,\n"
                      "  \"bearing_a\" INTEGER NOT NULL,\n"
                      "  \"bearing_b\" INTEGER NOT NULL,\n"
                      "  \"type\" INTEGER NOT NULL,\n"
                      "  \"divided\" INTEGER NOT NULL,\n"
                      "  \"area_type\" INTEGER NOT NULL,\n"
                      "  \"use\" INTEGER NOT NULL,\n"
                      "  \"grade\" REAL,\n"
                      "  \"lanes_ab\" INTEGER NOT NULL,\n"
                      "  \"speed_ab\" REAL,\n"
                      "  \"fspd_ab\" REAL,\n"
                      "  \"cap_ab\" INTEGER NOT NULL,\n"
                      "  \"lanes_ba\" INTEGER NOT NULL,\n"
                      "  \"speed_ba\" REAL,\n"
                      "  \"fspd_ba\" REAL,\n"
                      "  \"cap_ba\" INTEGER NOT NULL,\n"
                      "  \"left_ab\" INTEGER NOT NULL,\n"
                      "  \"right_ab\" INTEGER NOT NULL,\n"
                      "  \"left_ba\" INTEGER NOT NULL,\n"
                      "  \"right_ba\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"node_a_fk\"\n"
                      "    FOREIGN KEY (\"node_a\")\n"
                      "    REFERENCES \"relation_Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"node_b_fk\"\n"
                      "    FOREIGN KEY (\"node_b\")\n"
                      "    REFERENCES \"relation_Node\" (\"node\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_entry
  schema_catalog_entry_Link_ (
    "",
    &access::object_traits< ::Link >::create_schema);
}

#include <odb/post.hxx>
